\documentclass{llncs}
\usepackage[textwidth=3cm,tickmarkheight=3pt]{todonotes}
\usepackage[utf8]{inputenc}
\usepackage{amssymb, amsmath}
\usepackage{numprint}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\usepackage{color}
\definecolor{citeblue}{rgb}{0.1,0,.4}
\usepackage[pdftex%
,colorlinks=true%
,bookmarks=true%
,linkcolor=citeblue%
,citecolor=citeblue%
,urlcolor=blue%
,plainpages=false]{hyperref}
\hypersetup{colorlinks,citecolor=blue,linkcolor=blue,urlcolor=blue}
\AtBeginDocument{\hypersetup{pdfborder={0 0 1}}}
\usepackage[nameinlink,capitalize,noabbrev]{cleveref} % must come after hyperref
\usepackage{commath}
\usepackage[most]{tcolorbox}
\usepackage{enumitem}
\usepackage{orcidlink}

\newcommand{\sygus}{SyGuS\xspace}
\newcommand{\qedhere}{$\blacksquare$}
\newcommand{\numvar}[1]{|#1|}


\renewcommand{\algorithmicrequire}{\textbf{Input:}}
\renewcommand{\algorithmicensure}{\textbf{Output:}}

%\newtheorem{definition}{Definition}
%\newtheorem{property}{Property}
%\newtheorem{example}{Example}

%\newtheorem{theorem}{Theorem}
%\newtheorem{lemma}[theorem]{Lemma}
%\newtheorem{corollary}[theorem]{Corollary}
%\theoremstyle{remark}
%\newtheorem{claim}{Claim}
\usepackage{etoolbox}
%\AtEndEnvironment{proof}{\setcounter{claim}{0}}

\npthousandsep{,}
\newcommand{\gmodel}{\mathcal{M}}
\newcommand{\smt}{\textsc{smt}}
\newcommand{\args}{\text{args}}
\usepackage{xspace}
\newcommand{\req}{\emph{ReqPivot}\xspace}
\newcommand{\subst}[3]{#1[#2\leftarrow #3]}
\newcommand{\repr}[1]{\hat{#1}}

\newcommand{\todoSR}[1]{\todo[color=blue!40]{#1}}
\newcommand{\mj}[1]{\todo[color=green!30]{#1 -mik}}
\newcommand{\marek}[1]{\todo[color=red!10]{#1 -MD}}
\newcommand{\todoSN}[1]{\todo[color=orange!50]{#1 -SN}}

\title{Certifying Satisfiability of\\Universally Quantified Integer Arithmetic with\\ Uninterpreted Function Symbols%
}

% === TITLE SUGGESTIONS ===
%
% Formal/Academic:
% - Satisfiability Certificates for Quantified Integer Formulas via Inductive Propagation
% - Beyond Finite Models: Inductive Proofs for UFLIA Satisfiability
% - Cell Propagation: A Decision Procedure for Offset-Restricted UFLIA
% - Inductive Witnesses for Quantified Satisfiability over Integers
% - From Finite Base to Infinite Model: Certifying UFLIA Satisfiability
%
% Shorter/Punchier:
% - Satisfying the Unsatisfiable: Inductive Methods for UFLIA
% - When Models Are Too Big: Inductive UFLIA Satisfiability
% - Propagating Satisfiability in Quantified Integer Formulas
%
% Playful:
% - No Model? No Problem! Inductive Certificates for UFLIA
% - The SAT Side of UFLIA: Finding Models Without Building Them
% - Infinite Models, Finite Proofs: Taming Quantified Integer Constraints
% - Teaching SMT Solvers to Say Yes
% - Cell by Cell: An Inductive Journey to Satisfiability
% - Why Build a Model When You Can Prove One Exists?
% - The Optimist's Guide to UFLIA: Proving Satisfiability by Induction
%
% Wordplay:
% - Induction to the Rescue: Satisfiability Without Enumeration
% - Propagate, Don't Enumerate: Deciding Quantified Integer Formulas
%
% === END TITLE SUGGESTIONS ===

% \author{Stefan Ratschan \and Anggha Nugraha \and Mikoláš Janota \and Marek Dančo}
\author{Stefan Ratschan\inst{1}\orcidlink{0000-0003-1710-1513} \and
Anggha Nugraha\inst{1,2}\orcidlink{0000-0002-7139-4487} \and
Mikoláš Janota\inst{3}\orcidlink{0000-0003-3487-784X} \and 
Marek Dančo\inst{3}\orcidlink{0009-0008-3031-113X}}
%
\authorrunning{S. Ratschan et al.}
% First names are abbreviated in the running head.
% If there are more than two authors, 'et al.' is used.
%
\institute{Institute of Computer Science, The Czech Academy of Sciences,
Prague, Czech Republic \\
\email{stefan.ratschan@cs.cas.cz} \and 
Faculty of Information Technology, Czech Technical University in Prague,
Prague, Czech Republic \and 
Czech Institute of Informatics, Robotics and Cybernetics, Czech Technical University in Prague, Czech Republic}

\begin{document}
\maketitle

\begin{abstract}
The combination of integer arithmetic, uninterpreted function symbols, and universal quantification occurs in many applications of automated reasoning, for example, due to its ability to reason about arrays. However, the satisfiability of such formulas is, in general, undecidable. In practice, SMT solvers are often successful in the unsatisfiable case, using heuristics. However, in the satisfiable case, they rely on  explicit model construction, which fails for formulas whose smallest model is not small enough. We introduce an alternative approach that certifies satisfiability using induction arguments, and provide an algorithm that is able to prove satisfiability of formulas that are out of reach of current SMT solvers. 

%\keywords{First keyword  \and Second keyword \and Another keyword.}
\end{abstract}


\section{Introduction}

Current SMT solvers have mainly been designed to prove unsatisfiability. As a consequence,  they have limited capabilities to detect satisfiability of formulas not belonging to known decidable classes. However, the ability to detect satisfiability is important for identifying counter-examples, which is indispensable in many applications~\cite{clarke25}.

In this paper, we address this problem for formulas containing universal quantifiers, linear integer arithmetic, and uninterpreted function symbols. Such formulas belong to the SMTLIB logic UFLIA, which is undecidable~\cite{Downey:72,Horbach:17}. However, such formulas occur in important applications, for example, in program verification, where uninterpreted function symbols play an important role in reasoning about arrays\cite{bradley-manna07}. Current SMT solvers mainly rely on heuristics~\cite{Reynolds:17}\todoSR{Mikoláš, do you want to add some of your work?} to prove unsatisfiability of such formulas. To prove satisfiability, they explicitly construct a model~\cite{ge-cav09,reynolds2013finite}. This fails for formulas as simple as $f(0)=0\wedge \forall x \;.\; f(x+1)=f(x)+1$, which do not have a finite model, and is costly for formulas whose smallest model is finite, but large.

In this paper, we explore an alternative approach that avoids explicit model construction by proving satisfiability using inductive arguments, instead. More specifically, we
\begin{itemize}
\item introduce a notion of satisfiability certificate that represents inductive arguments for satisfiability of such formulas, we
\item introduce an algorithm that proves satisfiability by synthesizing such a satisfiability certificate for a sub-class of UFLIA formulas, we
\item prove soundness of this algorithm and completeness under the assumption that the input formula satisfies a certain semantic condition that enables inductive reasoning, we
\item introduce an SMT encoding of the formulas solved by this algorithm, and we 
\item demonstrate using computational experiments that this approach is able to prove satisfiability of formulas for which this is out of reach for current SMT solvers.
\end{itemize}

% \paragraph{How We Solve It.} Our approach is based on \emph{inductive cell propagation}. We view each quantifier instantiation as imposing constraints on \emph{cells}—terms $f(n_1,\dots,n_k)$ with integer arguments. The key insight is that if we can: 1) Find a finite interval $[b_{\min}, b_{\max}]$ where all instantiations are simultaneously satisfiable, and 2) Ensure that from this base, solutions can be \emph{propagated} outward in both directions without conflicts, then the entire universally quantified formula is satisfiable. This reduces the infinite satisfiability problem to checking two finite conditions: base satisfiability and a propagation property formalized as the \emph{multi-ReqPivot condition}.

% The key idea is to treat each quantifier instantiation as introducing infinitely many constraints on function calls, which we refer to as cells. A single cell may appear in multiple constraints, so we must ensure that it is assigned a consistent value throughout. To show satisfiability within our fragment, we impose an order on these constraints and construct a symbolic assignment to the cells such that, when processed in this order, no conflicting assignments arise.

% \paragraph{Contributions.} 
% This paper makes several contributions towards deciding satisfiability in our fragment. We formalize \emph{cell propagation certificates} (\cref{def:certificate}) that witness satisfiability through inductive extension of finite base assignments.  We introduce the \emph{\req condition} (\cref{def:reqpivot-param}), propagation conditions that allows multiple functions to serve as pivots simultaneously. Building on this, we present an interval‑based algorithm (\cref{alg:interval-check-param-withBigvee}) that searches for suitable base intervals and checks propagation conditions using satisfiability queries. We prove \emph{soundness} (\cref{cor:soundness-bigvee}) and \emph{relative completeness} (\cref{thm:completeness-bigvee}) for our algorithm. Finally\todoSN{Hopefully!}, we provide experimental evidence that our method handles problems beyond the reach of current SyGuS and MBQI approaches, often producing more interpretable models.

% \section{Related Work}\label{}
% Synthesis of recursive functions by Hozzov\'a et al.~\cite{hozzova-ijcar24}.
% Synthesis of strategies on LIA problems Murphy and Kincaid~\cite{kincaid-cav24}.
% Synthesis, single invocation Kun\v cak et
% al.~\cite{kuncak-pldi10,kuncak-sttt13}.

% Array decision procedures~\cite{bradley-vmcai06}: no arithmetic on universally quantified variables allowed.
% Habermehl et al.~\cite{habermehl-etaps08} allow difference bounded constraints on array offsets of the form $a[i+c]$. From the MBQI paper: ``For certain cases containing offsets on array indices, our procedure will result in an infinite set of instantiations, while a decision procedure of LIA\footnote{LIA does not refer to linear integer arithmetic, but to the logic allowed by Habermehl et al.}  will terminate. It leaves an open question for future research on how to reason about this type of formulas within an instantiation-based approach.''

% Alberti et al.~\cite{alberti2014decision}: only one universally quantified variable allowed.
% Elad et al.~\cite{elad2024infinite}: The fragment of FOL for which they prove decidability (OSC, Section~6) does not allow anything like integer arithmetic.

% \cite{reynolds2016model}: needs to user to ensure admissibility (Definition~2), the underlying finite model finding algorithm~\cite{reynolds2013finite} may introduce many case splits (``merge lemmas'') for satisfying cardinality constraints. \todoSR{I added a few words here}

% computer algebra algorithms for solving difference equations

% \subsection{What Can't the Previous Work Solve?}

% Here, I am considering the works~\cite{bradley-vmcai06,ge-cav09,habermehl-etaps08}.

% \paragraph{Infinitely Increasing But Bounded Integer Sequence}

% \[
% 	\forall{x}. \,f(x)<0 \,\land \,\forall{x}. \,f(x)<f(x+1)
% \]

% The syntax in~\cite{habermehl-etaps08} includes $\leq$ but does not include $<$. It does include negation though, but only if it
% results in the quantified variables being existential. This cannot be solved by~\cite{bradley-vmcai06} (see Theorem 4 in their paper).
% \textsc{Z3} cannot solve this on its own but with the addition of Lemma~\ref{eq:ind-needed-lemma} it can. Adding the lemma also helps Vampire but not \textsc{cvc5}.

% \paragraph{Two-Valued Constant Function}

% \[
% 	f(0) = 0 \,\land \,f(c) = 3 \,\land \,\forall{x}. \,f(x+1) = f(x)
% \]

% In the last meeting I hand-wavedly assumed this cannot be in the fragment of~\cite{habermehl-etaps08}.
% However, it is. They accept the literals $f(x) - f(x+1) \leq 0$ and $f(x+1) - f(x) \leq 0$, which in conjunction simplify
% to $f(x) = f(x+1)$. They can then universally quantify this to form an array property. The other equalities can
% be formed as value expressions $A \leq B \,\land \,B \leq A$. I can look more thoroughly at the paper
% to see how can they solve this.
% This cannot be solved by~\cite{bradley-vmcai06}, because the
% third conjunct contains $x+1$ as an argument of $f$ (Theorem 4 in their paper).
% \textsc{Z3} cannot solve this -- Compactness section in~\cite{ge-cav09}.

\section{Related Work}\todoSR{potentially relevant PC members: Reynolds, Barrett, Tinelli, Weidenbach, anybody else?}

Our work intersects several areas of automated reasoning: synthesis, decision procedures for arrays, and model-based quantifier instantiation.

\paragraph{Recursion.}
\cite{Farzan2021}
\cite{Kneuss2013}

\paragraph{Synthesis approaches.}
Syntax-Guided Synthesis (SyGuS)~\cite{cvc5} enumerates candidate functions from a grammar. Hence its performance depends crucially on the chosen grammar. Moreover, it synthesizes functions in an explicit representation, disallowing recursion\todoSR{right?}. Our method does beyond that, using inductive reasoning.
Kunčak et al.~\cite{kuncak-pldi10,kuncak-sttt13} introduces single-invocation synthesis. Hozzová et al.~\cite{hozzova-ijcar24} synthesize recursive programs from constraints.\todoSR{Do we want to keep these references? If yes, we need a better description. Do we want to add our CADE paper as a template based approach?}





% While powerful for template-matching problems, it fails on formulas requiring non-template solutions like periodic functions (Equation~\ref{eq:periodic}). 

% produce counterexamples for complex systems. Yet, counterexamples are important during modeling as they uncover  errors. For example, a user may wrongly assume that an input stream with increasing values will contain two equal consecutive values. Negating and skolemizing this assumption yields the simple UFLIA formula:
% \begin{equation}
% 	f(0)\neq f(1)\land\forall x:\mathbb{Z}.\,f(x)<f(x+1)
% \end{equation}

% While this formula has trivial counter-models (e.g. $f$ being the identity function), and such solutions can be found by synthesis approaches like \sygus, it is easy to get out of the reach of these tools because they are primarily based on templates and candidate-solution enumeration. The following modification is no longer solved by cvc5~\cite{cvc5} in its \sygus mode.

% \begin{equation}\label{eq:periodic}
% 	f(0)\neq f(1)\land\forall x:\mathbb{Z}.\,f(x)=f(x+2)
% \end{equation}

% These constraints allow only periodic functions whose neighboring values alternate. For such functions the \sygus grammar would have to guess an \textit{ite} term of the form $\mathit{ite}(x\,\mathit{mod}\,2 = 0\enspace a\enspace b)$, for integers $a \not = b$.
%Even if \sygus tools were improved, they could not yield a decision procedure for full UFLIA due to the inherent undecidability of integer arithmetic combines with uninterpreted functions. 


\paragraph{Decision procedures for arrays and quantified formulas.}
Bradley et al.~\cite{bradley-vmcai06} present a decision procedure for array properties but explicitly forbid arithmetic on the universally quantified variables. Habermehl et al.~\cite{habermehl-etaps08} allow constraints of the form $a[i+c]$ with difference bounds, but remain limited to offset-bounded indices. Alberti et al.~\cite{alberti2014decision} consider only one universally quantified variable. Elad et al.~\cite{elad2024infinite} prove decidability for a first‑order fragment without arithmetic, unable to express our constraints.

\paragraph{Model-based and instantiation methods.}
Reynolds et al.~\cite{reynolds2016model,reynolds2013finite} develop finite model finding techniques for quantified formulas. Their method requires users to ensure admissibility and may introduce many case splits (``merge lemmas'') to satisfy cardinality constraints. Ge and de Moura~\cite{ge-cav09} introduce the Model-Based Quantifier Instantiation (MBQI) but noting that ``For certain cases containing offsets on array indices, our procedure will result in an infinite set of instantiations, while a decision procedure of LIA\footnote{LIA refers to the logic of Habermehl et al.} will terminate. It leaves an open question for future research on how to reason about this type of formulas within an instantiation-based approach.'' Our work attempts to  address this open question.

\paragraph{Proof certificates and model representation.} move \cite{elad2024infinite} here? \cite{Ratschan:23} \cite{Barbosa:23}


\paragraph{Limitations illustrated.}\todoSN{In the previous version, there is a sentence: ``Here, I am considering the works~\cite{bradley-vmcai06,ge-cav09,habermehl-etaps08}." }
To see where existing methods fall short, consider:
\begin{itemize}
    \item \textbf{Infinitely increasing bounded sequence:} $\forall x.\, f(x) < 0 \land \forall x.\, f(x) < f(x+1)$. 
    Habermehl et al.'s fragment excludes strict inequalities. It does include negation, but only if it results in the quantified variables being existential. Bradley et al. forbid $x+1$ as an argument (Theorem 4 in~\cite{bradley-vmcai06}). \textsc{Z3} cannot solve this on its own\todoSN{In the previous version, there is ``but with the addition of Lemma~\ref{eq:ind-needed-lemma} it can. Adding the lemma also helps Vampire but not \textsc{cvc5}."}. 
    \item \textbf{Two‑valued constant function:} $f(0) = 0 \land f(c) = 3 \land \forall x.\, f(x+1) = f(x)$.
 In the last meeting I hand-wavedly assumed this cannot be in the fragment of~\cite{habermehl-etaps08}. However, it is. They accept the literals $f(x) - f(x+1) \leq 0$ and $f(x+1) - f(x) \leq 0$, which in conjunction simplify to $f(x) = f(x+1)$. They can then universally quantify this to form an array property. The other equalities can be formed as value expressions $A \leq B \,\land \,B \leq A$. I can look more thoroughly at the paper to see how can they solve this. This cannot be solved by~\cite{bradley-vmcai06}, because the third conjunct contains $x+1$ as an argument of $f$ (Theorem 4 in their paper).
\textsc{Z3} cannot solve this -- Compactness section in~\cite{ge-cav09}.
\end{itemize}

These examples demonstrate the need for a method that handles arithmetic offsets while providing finite certificates for satisfiability.

\section{Problem Statement}
\label{sec:problem-statement}

%\paragraph{Formula Class}
We introduce a method for certifying satisfiability of formulas of the form
\begin{equation}\label{eq:main-fragment}
    F \land \forall \bar{x}.\; Q%\bigl(f_1(x+t^{f_1}_1),\dots,f_1(x+t^{f_1}_{l_1}),\;\dots,\;f_r(x+t^{f_r}_1),\dots,f_r(x+t^{f_r}_{l_r})\bigr),
\end{equation}
where $F$  and $Q$ are quantifier‑free formulas in the SMTLIB theory UFLIA of uninterpreted function symbols and linear integer arithmetic and $\forall \bar{x}$ stands for universal quantification of arbitrarily many variables.  Based on this method, we will design an algorithm for detecting satisfiability under the following additional assumptions:
\begin{itemize}
%    \item $f_1,\dots,f_r$ are distinct uninterpreted function symbols,
%    \item for each $f_i$, the \emph{offset terms} $t^{f_i}_1,\dots,t^{f_i}_{l_i}$ are pairwise distinct LIA ground terms, and
    \item All uninterpreted function symbols have maximal arity $1$.  
    \item The number of quantified variables is $1$.
    \item The coefficient of the quantified variable is positive for all arguments of uninterpreted function symbols, and the same for all argument terms of the same uninterpreted function symbol.
    \end{itemize}
The algorithm is guaranteed to terminate under an additional semantic condition enabling induction (\cref{def:reqpivot-param}).

We illustrate the class of formulas our algorithm can handle using two examples. 
\begin{example}
  \label{ex:formula}
  \[f(0)=0 \wedge \forall x \,.\, f(2x+3)=g(x)+f(2x+c+1)-c,\]
  where $c$ is an uninterpreted constant, and the coefficient of the quantified variable~$x$ is $2$ for all arguments of $f$, and $1$ for all arguments of $g$.
\end{example}

\begin{example}[Invalid]
  \[\forall x \,.\, f(2x+3) = f(x+1)\]
  This formula is \emph{not} in our fragment because $f$ appears with arguments having different coefficients ($2$ and $1$).
\end{example}

Note that certain formulas with several quantified variables can be easily transformed to this class by a change of variables. For example, the formula
\[f(0)=0 \wedge \forall y,z \,.\, f(2y-2z+3)=g(y-z)+f(2y-2z+c+1)-c,\]
can be reduced to Example~\ref{ex:formula} by the change of variables $x=y-z$.

We are not aware of any result showing the decidability of this class. However, we are also not aware of any result proving it to be undecidable. Indeed, our goal is not decidability classification, but an algorithm for showing satisfiability that allows straightforward implementation in SMT solvers, and that is efficient in practice.



% \paragraph{Core Problem}
% Given a formula $\phi$ of the form~\eqref{eq:main-fragment}, the problem we address is:
% \begin{quote}
%     \emph{Decide whether $\phi$ is satisfiable over the standard integers, and if so, construct a model (an interpretation of all uninterpreted function symbols) that satisfies $\phi$.}
% \end{quote}

% \paragraph{Why is this Hard?}\todoSN{Not sure about this part! I'm just trying to summarize it from what's written in the Intro and Related Work sections.}
% Although UFLIA is undecidable in general, formulas of the above form constitute a fragment that appears frequently in verification conditions (e.g.\ for programs with arrays or recursive functions). Yet, existing SMT techniques struggle:
% \begin{itemize}
%     \item \textbf{Finite instantiation} may not terminate because the universal quantifier ranges over the infinite domain $\mathbb{Z}$.
%     \item \textbf{Synthesis-based approaches} (SyGuS) rely on syntactic templates and fail when the required function does not match the template.
%     \item \textbf{Model-based quantifier instantiation} (MBQI) can sometimes find models but often produces large, uninterpretable assignments and scales poorly.
%     \item \textbf{Specialized array decision procedures} either forbid arithmetic on indices or are limited to difference‑bounded constraints.
% \end{itemize}
% The presence of both arithmetic constraints and uninterpreted functions, combined with the universal quantifier, makes this fragment challenging for current solvers.

% \paragraph{Scope and Limitations}
% We make the following additional assumptions about the structure of the formulas:
% \begin{enumerate}
%     \item Each uninterpreted function symbol appears with only finitely many distinct argument terms in $Q$.
%     \item We do not allow nested applications of uninterpreted functions (e.g., $f(g(x))$ is excluded).
%     \item We do not consider multiple universal quantifiers over different variables or existential quantification over functions.
% \end{enumerate}
% These restrictions enable the inductive propagation reasoning that underlies our solution, while still covering many practical verification conditions. The technical details of our solution—how we detect satisfiability, what propagation conditions we require, and how we construct models—are presented in the following sections.

% \paragraph{Expected Outcomes}
% For formulas within this fragment, we aim to provide:
% \begin{itemize}
%     \item A \emph{sound} decision procedure: if the procedure returns \textsc{Sat}, the formula is indeed satisfiable.
%     \item A \emph{relatively complete} procedure: for a large subclass (characterized by a propagation condition), the procedure will terminate and return the correct answer.
%     \item Constructive models: when the formula is satisfiable, the procedure should produce an explicit interpretation of the uninterpreted functions.
% \end{itemize}


    
% \paragraph{Core Problem}
% Given a formula $\phi$ of the form~\eqref{eq:main-fragment}, we want to decide its satisfiability over the standard integers. Because the quantifier ranges over the infinite set $\mathbb{Z}$, a na\"ive instantiation‑based approach may not terminate. Instead, we aim to reduce the problem into checking two conditions on a finite interval $B = [b_{\min}, b_{\max}]$:

% \begin{enumerate}
%     \item \textbf{Base satisfiability:} $F \land \bigwedge_{z \in B} Q[z]$ is satisfiable (where $Q[z]$ denotes $Q$ with $x$ replaced by the numeral $z$).
%     \item \textbf{Propagation:} From a model of the base interval, we can extend the assignment to all integers $z \notin B$ without creating any conflicts. This requires that for each function $f_i$, certain occurrences in $Q$ can be treated as ``pivots'' whose values can be chosen after fixing all other occurrences.
% \end{enumerate}

% The second condition is formalized as the \emph{\req condition} in \cref{sec:alg}. Intuitively, it ensures that when moving outward from $B$ (to larger or smaller integers), we always have at least one cell in each instantiation whose value can be adjusted to satisfy $Q$, given the values already assigned to cells that appear in earlier instantiations.

% \paragraph{Challenges}\todoSN{Stefan R, could you please check whether I formulate this paragraph (and the next one) correctly?}
% \begin{itemize}
%     \item \textbf{Detecting propagability:} How can we automatically check whether a formula $Q$ satisfies the required pivot condition?
%     \item \textbf{Finding a suitable base interval:} The interval $B$ must be large enough to avoid clashes between cells generated during propagation and cells that appear in the ground part $F$.
%     \item \textbf{Completeness:} Under what conditions does the existence of a finite base interval together with propagation guarantees imply satisfiability? Conversely, when can unsatisfiability be detected finitely?
% \end{itemize}

% \paragraph{Our Contributions}
% We address these challenges through the following steps:
% \begin{enumerate}
%     \item We introduce \emph{cell propagation certificates} (Definition~\ref{def:certificate}) as a formal witness for satisfiability in our fragment.
%     \item We define the \emph{\req condition} (Definition~\ref{def:reqpivot-param}) that characterizes when propagation is possible.
%     \item We prove that if a formula satisfies the \req condition and a suitable base interval exists, then the formula is satisfiable (Theorem~\ref{thm:interval-certificate-param}).
%     \item We present an algorithm (Algorithm~\ref{alg:interval-check-param-withBigvee}) that enumerates candidate intervals and checks both base satisfiability and propagation conditions using an $\smt$ solver.
%     \item We establish soundness and relative completeness theorems for our algorithm (Corollary~\ref{cor:soundness-bigvee} and Theorem~\ref{thm:completeness-bigvee}).
% \end{enumerate}


\section{Notation and Terminology}

As usual in an SMT context, we will work with a first-order language that is sorted. We also assume variables to only occur in positions where they are bounded by a quantifier. We already used the notation $\forall \bar{x}$ as an abbreviation for universal quantification over several variables. In this case, we will write $\numvar{x}$ for the number of those variables. For a formula $F$ and uninterpreted function symbol $f$, $args(F, f)$ will denote the set of argument terms of $f$ in $F$. We will write $\subst{s}{v}{t}$ for the result of substituting the term $t$ for $v$ in the term or formula~$s$. Here, $v$ may again represent several variables, in which case we require $t$ to represent a $\numvar{v}$-vector of terms, and assume substitution to be parallel. For an integer $z\in\mathbb{Z}$, we will denote the constant representing $z$ in a logical formula by $\repr{z}$.


We will use the classical mathematical notion of a well-order. A well-order on a set $S$ is a total ordering on $S$ such that every non-empty subset of $S$ has a least element. Any well-order allows well-founded induction: For a  proving that a property $P$ holds for all $x$, it suffices to prove that for every $x\in S$, if for all $y\prec x$, $P(y)$ then also $P(x)$.


We use the notion of certificate in the following sense~\cite{McConnell:11}: Given a property~$P(x)$ that is typically difficult to check, a certificate for this property is an object $\Pi$ for which we have a property $P'(x,\Pi)$ and a proof that $P'(x,\Pi)$ implies $P(x)$, and for which $P'(x,\Pi)$ is easier to check than $P(x)$. Here, we will not always insist on a precise meaning of the notion of being easy to check. However, the final goal is a certificate $\Pi$, for which $P'(x,\Pi)$ can be checked more efficiently than the original property $P(x)$, using an algorithm that is in some sense simpler then an algorithm for checking $P(x)$. As a consequence, such a certificate will enable an efficient independent check of the correctness of the result of an algorithm for checking~$P(x)$.

\section{Satisfiability Certificates}
\label{sec:certificate}

\todoSR{I intend to add a running example and a figure}

In this section, we will define objects that certifies that a formula in the form defined in~\cref{sec:problem-statement} is satisfiable. In the next section, we will then introduce an algorithm to compute such certificates.

Traditionally, satisfiability of a logical formula is certified by an interpretation that assigns a value to each non-logical symbol in such way that the formula is true. However, the set of integers is infinite. Due to this,  the interpretation of an uninterpreted function symbol with integer domain is a function that assigns values to the infinitely many integers that form this domain. This opens the question of how to represent such a function using a finite object that can be represented on computers.

Our approach will not assign values to the whole infinite domain of uninterpreted function symbols in one step, but to each individual element of this domain:
\begin{definition}[Cell]\label{def:cell}
	A \emph{cell} is a term of the form $f(n_1,\dots, n_k)$ where $f$ is an uninterpreted function symbol and $n_1,\dots, n_k$ are integers.
\end{definition}
Examples of cells are $c$, and $f(7)$. The term $f(c+7)$ is not a cell.

\begin{definition}[Cell Interpretation]
	A \emph{cell interpretation} is a partial function whose domain is the set of cells. A cell interpretation $I$ is \emph{compatible} with an interpretation $\mathcal{I}$ iff $I$ and $\mathcal{I}$ agree on all cells where $I$ is defined.
\end{definition}

Given a cell interpretation $I$, we denote by $\mathit{def}(I)$ the set of cells for which $I$ is defined. Given a term $t$ and a cell interpretation $I$  we define $I(t):=\mathcal{I}(t)$, if  $\mathcal{I}(t)$ is unique for every interpretation $\mathcal{I}$ compatible with $I$, and otherwise $I(t):=\bot$.
For example, for $I=\{ f(0) \mapsto 7 \}$, $I(f(0))=7$, but $I(f(1))=\bot$. Also note that $I(f(1)-f(1))=0\neq\bot$. In a similar way, for a formula $\phi$, we define that a cell interpretation~$I$ satisfies $\phi$ iff for every interpretation $\mathcal{I}$ compatible with $I$, $\mathcal{I}$ satisfies $\phi$, in which case we also write $I\models \phi$.

In order to allow a computer representation of cell interpretations, we will always work with cell interpretations that are only defined on finitely many cells. However, we will want that at least those cells are defined, that allow us to check satisfaction of parts of formulas without quantifiers, and that for all universally quantified parts and instantiations of the universal quantifier, allow us to determine the value of all arguments of uninterpreted function symbols.

\begin{definition}
	\label{def:pre-sat-cert}
	Given a formula $\phi$ of the form $F\wedge \forall \bar{x}\;.\; Q$, we call a cell interpretation $I$ such that
	\begin{itemize}
		\item $I\models F$, and
		\item for all $z\in\mathbb{Z}^{\numvar{\bar{x}}}$, for every uninterpreted function symbol~$f$ and its argument terms $t\in args(Q, f)$, $I(\subst{t}{\bar{x}}{\repr{z}})\neq\bot$
	\end{itemize}
	a \emph{pre-satisfiability certificate} of $\phi$. For any $z\in\mathbb{Z}^{\numvar{\bar{x}}}$, we denote by $\Gamma_{I,z}(\phi)$
	the resulting set of cells \[\{ f(I(\subst{t}{\bar{x}}{\repr{z}})) \mid t\in args(Q, f), f \emph{ is an uninterpreted function symbol}\}.\]
\end{definition}
For example, $I=\{ c\mapsto 5 \}$ is a pre-satisfiability certificate of $c\geq 5 \wedge \forall x \;.\; f(x+c+1)= f(x+c)+1$, and $\Gamma_{I,10}(\phi)=\{ f(15), f(16)\}$.

Given a pre-satisfiability certificate, we can now certify the advisability of formulas by propagating the values given by a pre-satisfiablity certificate in such a way that for each value of the universally quantified variables, the corresponding quantified sub-formula holds.
\begin{definition}
	\label{def:certificate}
	Given a formula $\phi$  of the form $F\wedge \forall \bar{x}\;.\; Q$, a \emph{satisfiability certificate} is
	\begin{itemize}
        \item a pre-satisfiability certificate $I$ of $\phi$,
		\item a well-order $\preceq$ on $\mathbb{Z}^{\numvar{\bar{x}}}$,%\footnote{A well-order total order for which every non-empty subset has a least element. This enables induction. If we want to allow sub-formulas to be at the same place in the order, we either need to combine them into equivalence classes, or relax anti-symmetry (i.e., work with a pre-wellorder).}
		\item for every $z\in\mathbb{Z}^{\numvar{\bar{x}}}$
                  \begin{itemize}
                  \item a set $X_z\subseteq \Gamma_{I,z}(\phi)$  (the \emph{propagated cells}) such that \[X_z\cap \mathit{def}(I)=\emptyset \text{ and } X_z\cap\bigcup_{z'\prec z} \Gamma_{I,z'}(\phi)=\emptyset,\] and
                    %that are neither assigned a value by $I$, nor occur in any $\Gamma_{I,z'}(\phi)$ for any $z'\prec z$
                  \item a certificate (the \emph{satisfiability propagator}) showing that for all values of cells in $\Gamma_{I,z}(\phi)\setminus \mathit{def}(I)\setminus X_z$ there exist values for the cells in $X_z$ such that for the cell interpretation $I_{X_z}$ assigning these values to $X_z$, $I\cup I_{X_z}\models \subst{Q}{\bar{x}}{\repr{z}}$.
                  \end{itemize}

	\end{itemize}
\end{definition}

The notion of certificate defined here is abstract in the sense that it does not fix a concrete finite representation that allows for an independent check whether a given object is indeed a satisfiability certificate. For arriving at concrete independently checkable certificates, it suffices to fix a well-order and decide on a representation of propagated cells and satisfiability propagator that allows for such an independent check. For example, all these definitions could be written in the language of Presburger arithmetic, which allows the independent check to be done using a decision procedure for Presburger arithmetic. We will illustrate this in the next section for the special class of formulas described in \cref{sec:problem-statement}.

% For the sake of generality, the satisfiability propagator only shows existence of values for the propagated cells. At this point we do not require it to be constructive. Still, below we will work with algorithms computing actual values. In addition, the definition allows infinitely many different sets of propagated cells and satisfiability propagators. In practice, for allowing computer representation, we will only work with finitely many different ones.

Also note that for $z\in\mathbb{Z}^{\numvar{\bar{x}}}$ such that $\Gamma_{I,z}(\phi)\subseteq \mathit{def}(I)$, the definition requires the set of propagated cells $X_z$ to be empty. As a consequence, for such $z$, the satisfiability propagator only needs to certify that $I\models \subst{Q}{\bar{x}}{\repr{z}}$. In other words, the cell interpretation~$I$ serving as a pre-satisfiability certificate already plays the role of the satisfiability propagator. 

\begin{property}\label{prop:certThenSat}
	Every formula $\phi$  of the form $F\wedge \forall x\;.\; Q$ that has a satisfiability certificate is satisfiable.
\end{property}

\begin{proof}
	Assume a formula of the given form and assume that it  has a satisfiability certificate.
	The corresponding pre-satisfiability certificate $I$ satisfies the quantifier free part~$F$ of $\phi$.
    
    We start by showing that for every $z\in\mathbb{Z}^{\numvar{\bar{x}}}$ there is an extension $I'$ of $I$ such that $I'$ satisfies all quantifier instantiations occurring before $z$ wrt.\ the order $\preceq$, that is,  $I'\models\{ \subst{Q}{\bar{x}}{\repr{z}'} \mid z'\preceq z\}$. For this we use the principle of induction on well-orders: Let $z\in\mathbb{Z}^{\numvar{\bar{x}}}$, and let $\Phi$ be $\{ \subst{Q}{\bar{x}}{\repr{z}'} \mid z'\prec z\}$. We assume that there is an extension $I_{\Phi}$ of $I$ with $I_{\Phi}\models\Phi$, and prove that there is an extension $I'$ of $I$ with $I'\models\Phi\cup \{ \subst{Q}{\bar{x}}{\repr{z}}\}$. Since the formula has a satisfiability certificate, the propagated cells of $\subst{Q}{\bar{x}}{\repr{z}}$ do not occur in any element of $\Phi$. Let $I'$ be the extension of $I_{\Phi}$ that assigns to the propagated cells $X_z$ the values whose existence is  confirmed by the satisfiability propagator. Since these do not occur in $\Phi$, $I'$ and $I_{\Phi}$ coincide on cells occurring in $\Phi$. Hence $I'$ satisfies both $\Phi$ and $\subst{Q}{\bar{x}}{\repr{z}}$, and so it satisfies $\Phi\cup \{ \subst{Q}{\bar{x}}{\repr{z}}\}$.

	Now denote for every $z\in\mathbb{Z}^{\numvar{\bar{x}}}$ the cell interpretation  satisfying $\subst{Q}{\bar{x}}{\repr{z}}$ as constructed in the previous paragraph by $I_z$.
	% From the well-order $\prec$ we get a corresponding well-order on these cell interpretations.
	% Let $I_{\phi}$ be the cell interpretation that, for any cell $u$, assigns the value to $u$ that $I_{z}$ assigns to it for the smallest $z$ (wrt. $\prec$) that assigns a value to $u$. This smallest $z$ exists, since $\prec$ is a well-order. The cell interpretation $I_{\phi}$ satisfies $\phi$, and any classical interpretation compatible with the values assigned by $I_{\phi}$ satisfies $\phi$, as well.
    
    Observe that for every cell~$u$, and for all~$z, z'\in \mathbb{Z}^{\numvar{\bar{x}}}$ with $I_z(u)\neq \bot$ and $I_{z'}(u)\neq \bot$, $I_z(u)=I_{z'}(u)$.      Let $I_\phi$ be the assignment that, for any cell $u$, if there is a $z$ such that $I_z(u)\neq \bot$, then $I_\phi(u)=I_z(u)$, and otherwise $I_\phi(u)=0$. Certainly $I_\phi\models F$. Moreover, for every $z\in\mathbb{Z}$,  $I_\phi\models  \subst{Q}{\bar{x}}{\repr{z}}$, since $I_\phi$ coincides with $I_z$ for all elements, where it is defined. Hence  $I_\phi\models \phi$.
\qedhere\end{proof}

A satisfiability certificate only shows that a formula is satisfiable. It does not provide concrete values of the corresponding model. We now show how to compute such values from a given satisfiability certificate containing a pre-satisfiability certificate $I$. For this, we require the satisfiability propagators to be constructive. So, for $z\in\mathbb{Z}^{|x|}$ and for each $u\in X_z$ we assume a function $prop_{u,z}$ such that for
a cell interpretation $I'$ with $\mathit{def}(I')=\Gamma_{I,z}(\phi)\setminus \mathit{def}(I)\setminus X_z$, $I\cup I'\cup \{ u \mapsto prop_{u,z}(I\cup I') \mid u\in{X_z}\}\models\subst{Q}{\bar{x}}{\repr{z}}$.
 
% for any $\hat{v}_1,\dots,\hat{v}_r$, the cell interpretation
% \[\{ v_1\mapsto \hat{v}_1,\dots,v_r\mapsto \hat{v}_1, u_1\mapsto  prop_{u_1}(\hat{v}_1,\dots, \hat{v}_r),\dots, u_s\mapsto prop_{u_s}(\hat{v}_1,\dots,\hat{v}_r)\} \] satisfies $\psi$

% For any instantiation $\psi$ of a quantified sub-formula with propagated cells $u_1,\dots, u_s$ and non-propagated cells $v_1,\dots, v_r$, the satisfiability propagator defines  functions $prop_{u_1},\dots, prop_{u_s}$ such that for any $\hat{v}_1,\dots,\hat{v}_r$, the cell interpretation
% \[\{ v_1\mapsto \hat{v}_1,\dots,v_r\mapsto \hat{v}_1, u_1\mapsto  prop_{u_1}(\hat{v}_1,\dots, \hat{v}_r),\dots, u_s\mapsto prop_{u_s}(\hat{v}_1,\dots,\hat{v}_r)\} \] satisfies $\psi$. In many cases, these functions can be synthesized automatically from the corresponding quantifier elimination problem~\cite{kuncak-sttt13}.\marek{Is \cite{kuncak-sttt13} applicable in our case too?}


Now, observe that for any cell $u$ there is at most one $z\in\mathbb{Z}^{\numvar{z}}$ with $u\in X_z$ (if there would be more than one then, due to $\preceq$ being a well-order, there is a minimal one, let us say $z_{\min}$, and then, for any $z'\succ z$, the requirements on $X_{z'}$ exclude the possibility of $X_{z'}$ containing $u$, as well). So for any cell $u$, let $\mathit{inst}(u)$ either be the $z\in\mathbb{Z}^{\numvar{\bar{x}}}$ with $u\in X_z$ or $\bot$ if there is no such instantiation.

Then, for the assignment $I_\phi$ from the proof of Property~\ref{prop:certThenSat}, which satisfies a given formula~$\phi$, and a given cell~$u$, the value of $I_\phi(u)$ can be computed by the following recursive function $val(u)$:
\begin{tabbing}\hspace*{0.4cm}\=\hspace*{0.4cm}\=\kill
	\textbf{if} $I$ assigns a value $x$ to $u$ \textbf{then} \textbf{return} $x$\\
	\textbf{if} $\mathit{inst}(u)=\bot$ \textbf{then} \textbf{return} 0\\
	\textbf{return} $prop_{u,\mathit{inst}(u)}(I\cup \{ v\mapsto val(v) \mid v\in \Gamma_{I,\mathit{inst}(u)}(\phi)\setminus \mathit{def}(I)\setminus X_z\})$
\end{tabbing}

Here, the recursive calls go down the order $\prec$ in the following sense:
\begin{property}
	Let $u$ be a cell such that $\mathit{inst}(u)\neq\bot$. Then for any other cell~$v\in\Gamma_{I,\mathit{inst}(u)}(\phi)\setminus \mathit{def}(I)\setminus X_z$ with $\mathit{inst}(v)\neq\bot$, $\mathit{inst}(v)\prec \mathit{inst}(u)$.
\end{property}

\begin{proof}
  Assume a cell $u$ with $\mathit{inst}(u)\neq\bot$, a  cell~$v\in\Gamma_{I,\mathit{inst}(u)}(\phi)\setminus \mathit{def}(I)\setminus X_z$ with $\mathit{inst}(v)\neq\bot$, and assume that $\mathit{inst}(v)\succeq \mathit{inst}(u)$. Then both $v\in X_{\mathit{inst}(v)}$ and $v \in \Gamma_{I,\mathit{inst}(u)}(\phi)$, and hence $X_{\mathit{inst}(v)}\cap \Gamma_{I,\mathit{inst}(u)}(\phi)\neq\emptyset$. 
%  Then $u\in X_{\mathit{inst}(u)}\subseteq \Gamma_{I,\mathit{inst}(u)}$ and $v\in X_{\mathit{inst}(v)}$.
  This contradicts the requirement that $X_{inst(v)}\cap (\mathit{def}(I)\cup\bigcup_{z'\prec inst(v)} \Gamma_{I,z'}(\phi))=\emptyset$.
  \qedhere
\end{proof}

So each recursive call of the program $val$ either results in $\mathit{inst}(u)$ either decreasing or being $\bot$. In the latter case, the program terminates immediately, and the former case cannot happen infinitely often, since the used order is well-founded. So we have:
\begin{property}
The program $val$ terminates.
\end{property}

Note that, in general, it is not possible to compute $val(u)$ by computing the values of $X_z, z \in \mathbb{Z}^{\numvar{z}}$, with $z$ being initialized with the minimal $z$ wrt. $\prec$, and then using a loop that increases $z$ from one successor wrt. $\prec$ to the next. For example, if  $\prec$  orders all even numbers before all odd ones, then this loop would have to iterate over infinitely many even numbers before computing the value of an odd one.
     

The goal is now an algorithm that computes such satisfiability certificates and a converse of the property that shows for certain classes of satisfiable  formulas this algorithm succeeds.



\section{Algorithm}\label{sec:alg}

% Class of formulas:
% \[ F\wedge \forall x\;.\; Q(f_1(x+t^{f_1}_1),\dots,f_1(x+t^{f_1}_{l_1}),\dots,f_r(x+t^{f_r}_1),\dots,f_r(x+t^{f_r}_{l_r})),\]
% where $F$ is quantifier free, for every $i\in \{1,\dots,r\}$, and the  $t^{f_i}_{1},\dots,t^{f_i}_{l_i}$ are pairwise different LIA ground terms

In this section, we will introduce an algorithm that will check satisfiability of an input formula by computing a satisfiability certificate of a certain form. \todoSN{Might need to change ``While..."}While our certificate framework (~\cref{def:certificate}) supports formulas with arbitrary numbers of universally quantified variables, the algorithm presented here focuses on the case of a single universally quantified variable. We also assume that the coefficient of this variable in argument terms is non-negative, and that all non-zero coefficients of this variables are the same for the same uninterpreted function symbol.

The computed certificate will explicitly certify: (1) satisfiability of the quantifier-free part $F$, and (2) satisfiability over a finite interval $B = [b_{\min}, b_{\max}]$ of instantiations of the quantified part $Q$. For values outside $B$, it uses satisfiability propagators with an order that propagates upward from $b_{\max}+1$ and downward from $b_{\min}-1$.  We will show soundness of the algorithm and completeness relative to conditions that ensure that such propagation outward from a base interval $B$ is possible.

Throughout this section we assume that $\phi$ is a formula of the form $F \land \forall \bar{x}.\; Q$, as defined in ~\cref{sec:problem-statement}, but with $\bar{x}$ being a single variable $x$. Let $\mathcal{F}$ be the set of uninterpreted function symbols in $Q$, and $\mathcal{T}$ the set of terms of the form $f(t)$ in $Q$. 

We will now formalize the condition ensuring propagation outward from a base interval $B$ is possible. For upward propagation, we select a $\mathcal{S} \subseteq\mathcal{T}$ whose argument terms are \emph{maximal} (all equal and strictly greater than other argument terms of the same function symbol). The \emph{propagability condition} then guarantees that, no matter what values are assigned to the non‑maximal occurrences, we can find values $v_1,\dots,v_r$ such that assigning $v_i$ to all occurrences in $\mathcal{S}$ makes $Q$ true. Different functions may receive different values. The downward condition is symmetric, selecting \emph{minimal} terms.

\begin{definition}[\req Condition]
\label{def:reqpivot-param}

For any choice of subsets $\mathcal{S}\subseteq\mathcal{T}$, define:
\begin{itemize}
    \item \textbf{Maximality condition $\Phi_{\text{max}}(\mathcal{S})$:}
    \[
        \subst{ \bigwedge_{f\in\mathcal{F}}\left(\bigwedge_{f(t),f(t') \in \mathcal{S}} t = t' \;\land\;
        \bigwedge_{f(t) \in \mathcal{S}, f(t') \in \mathcal{T}\setminus\mathcal{S}} t > t'
        \right)}{x}{0}.
    \]
    
    \item \textbf{Upward propagability condition $\Phi_{\text{prop-up}}(\mathcal{S})$:}
        \[\forall x \forall \bar{u} \exists \bar{v}.\ Q'(\mathcal{S})\]
        where $\bar{u}$ corresponds to the variables $u_{f(t)}$ with $f(t)\in\mathcal{T}\setminus\mathcal{S}$ and $\bar{v}$ to the variables $v_{f(t)}$ with $f(t)\in \mathcal{S}$, and $Q'$ is obtained from $Q$ by simultaneously replacing
        \begin{itemize}
            \item every $f(t)\in\mathcal{T}\setminus\mathcal{S}$ by $u_{f(t)}$, and
            \item every $f(t)\in\mathcal{S}$ by $v_{f(t)}$.
        \end{itemize}
\end{itemize}
 
Symmetrically, for downward propagation with a subset $\mathcal{S}'\subseteq\mathcal{T}$, define $\Phi_{\text{min}}(\mathcal{S}')$ (with $<$ instead of $>$) and $\Phi_{\text{prop-down}}(\mathcal{S}')$.

We say that $Q$ satisfies the \emph{\req condition for $(\mathcal{S}, \mathcal{S}')$} if
\begin{itemize}
    \item $\Phi_{\text{max}}(\mathcal{S})$ and $\Phi_{\text{prop-up}}(\mathcal{S})$ hold,
    \item $\Phi_{\text{min}}(\mathcal{S}')$ and $\Phi_{\text{prop-down}}(\mathcal{S}')$ hold.
\end{itemize}

We say $Q$ satisfies the \emph{\req condition} if there exists \emph{some} pair~$(\mathcal{S}, \mathcal{S}')$ such that $Q$ satisfies the \req condition for $(\mathcal{S}, \mathcal{S}')$.
\end{definition}

\begin{example}[\req Illustration]
\label{ex:req-illustration}
Consider the formula:
\[
\forall x.\ f(x+c+3) + f(x+4) + f(x+1) = g(x+2) + h(x)
\]
where $c$ is a ground constant. All function arguments have the form $x + \tau$ where $\tau$ is ground. We extract the set of terms:
\begin{align*}
\mathcal{T} &= \{f(x+c+3), f(x+4), f(x+1), g(x+2), h(x)\}.
\end{align*}

\medskip\noindent\textbf{Upward propagation:}
Consider $\mathcal{S} = \{f(x+4),g(x+2)\}$.
\begin{enumerate}
    \item \textbf{Maximality $\Phi_{\text{max}}(\mathcal{S})$:}
        We need to check for each function:
        \begin{itemize}
            \item For $f$: $f(x+4) \in \mathcal{S}$, $f(x+c+3) \notin \mathcal{S}$, $f(x+1) \notin \mathcal{S}$, so we require $(x+4) > (x+c+3)$ and $(x+4) > (x+1)$.
            \item For $g$: only $g(x+2) \in \mathcal{S}$, so the equality condition is trivial, and there are no non-$\mathcal{S}$ terms to compare with.
            \item For $h$: no terms in $\mathcal{S}$, so no conditions.
        \end{itemize}
        Substituting $x=0$ gives: $(4 > c+3) \land (4 > 1)$, which simplifies to $c < 1$.
        
    \item \textbf{Propagability $\Phi_{\text{prop-up}}(\mathcal{S})$:}
        In $Q$, replace:
        \begin{itemize}
            \item $f(x+4)$ by a fresh variable $v_{f(x+4)}$,
            \item $g(x+2)$ by $v_{g(x+2)}$,
            \item $f(x+c+3)$ by $u_{f(x+c+3)}$,
            \item $f(x+1)$ by $u_{f(x+1)}$,
            \item $h(x)$ by $u_{h(x)}$.
        \end{itemize}
        The resulting formula is:
        % \[
        % \forall x \forall u_{f(x+c+3)} \forall u_{f(x+1)} \forall u_{h(x)} \exists v_{f(x+4)} \exists v_{g(x+2)}.\ 
        % u_{f(x+c+3)} + v_{f(x+4)} + u_{f(x+1)} = v_{g(x+2)} + u_{h(x)}.
        % \]

        \[
        \forall x \, \forall\bar{u}\, \exists \bar{v}\;. 
        \bigl( u_{f(x+c+3)} + v_{f(x+4)} + u_{f(x+1)} = v_{g(x+2)} + u_{h(x)} \bigr),
        \]
        
        where $\bar{u} = \big(u_{f(x+c+3)}, u_{f(x+1)}, u_{h(x)}\big)$ and $\bar{v} = \big(v_{f(x+4)}, v_{g(x+2)}\big)$. This universally quantified formula is valid: for any values of $u_{f(x+c+3)}, u_{f(x+1)}, u_{h(x)}$, we can choose $v_{g(x+2)} = 0$ and $v_{f(x+4)} = u_{h(x)} - u_{f(x+c+3)} - u_{f(x+1)}$.
\end{enumerate}

\medskip\noindent\textbf{Downward propagation:}
Consider $\mathcal{S}' = \{f(x+1),h(x)\}$.
\begin{enumerate}
    \item \textbf{Minimality $\Phi_{\text{min}}(\mathcal{S}')$:}
        We need to check for each function:
        \begin{itemize}
            \item For $f$: $f(x+1) \in \mathcal{S}'$, $f(x+c+3) \notin \mathcal{S}'$, $f(x+4) \notin \mathcal{S}'$, so we require $(x+1) < (x+c+3)$ and $(x+1) < (x+4)$.
            \item For $h$: only $h(x) \in \mathcal{S}'$, so the equality condition is trivial.
        \end{itemize}
        Substituting $x=0$ gives: $(1 < c+3) \land (1 < 4)$, which simplifies to $c > -2$.
        
    \item \textbf{Propagability $\Phi_{\text{prop-down}}(\mathcal{S}')$:}
        In $Q$, replace:
        \begin{itemize}
            \item $f(x+1)$ by $v'_{f(x+1)}$,
            \item $h(x)$ by $v'_{h(x)}$,
            \item $f(x+c+3)$ by $u_{f(x+c+3)}$,
            \item $f(x+4)$ by $u_{f(x+4)}$,
            \item $g(x+2)$ by $u_{g(x+2)}$.
        \end{itemize}
        The resulting formula is:
        % \[
        % \forall x \forall u_{f(x+c+3)} \forall u_{f(x+4)} \forall u_{g(x+2)} \exists v'_{f(x+1)} \exists v'_{h(x)}.\ 
        % u_{f(x+c+3)} + u_{f(x+4)} + v'_{f(x+1)} = u_{g(x+2)} + v'_{h(x)}.
        % \]

        \[
        \forall x \, \forall\bar{u} \, \exists \bar{v}'. 
        \bigl( u_{f(x+c+3)} + u_{f(x+4)} + v'_{f(x+1)} = u_{g(x+2)} + v'_{h(x)} \bigr),
        \]
        where $\bar{u} = \bigl(u_{f(x+c+3)}, u_{f(x+4)}, u_{g(x+2)}\bigr)$ and  $\bar{v}' = \bigl(v'_{f(x+1)}, v'_{h(x)}\bigr)$. This is also valid: choose $v'_{h(x)} = 0$ and $v'_{f(x+1)} = u_{g(x+2)} - u_{f(x+c+3)} - u_{f(x+4)}$.
\end{enumerate}

\medskip\noindent\textbf{Putting it together:}
$Q$ satisfies the \req condition for the pair $(\mathcal{S},\mathcal{S}')$ whenever $c$ satisfies both $c < 1$ (from upward maximality) and $c > -2$ (from downward minimality). Hence for any $c \in (-2, 1)$, the specific choices $\mathcal{S} = \{f(x+4),g(x+2)\}$ and $\mathcal{S}' = \{f(x+1),h(x)\}$ witness the \req condition.
\end{example}

Now, given a concrete interval $B = [b_{\min}, b_{\max}]$, we need additional ``clash conditions'' that prevent the cells generated during propagation from clashing with the ground part $F$.

\begin{definition}[Interval Extension Formulas]
\label{def:interval-extension-formulas-param}
For an interval $B = [b_{\min}, b_{\max}]$ and subsets $\mathcal{S},\mathcal{S}' \subseteq \mathcal{T}$, define: 
\begin{enumerate}
    \item \textbf{Upward extension formula $\Psi_{\text{up}}(B,\mathcal{S})$}:
    \[
    \Phi_{\text{max}}(\mathcal{S})\;\land\; 
    \Phi_{\text{prop-up}}(\mathcal{S}) \;\land
    \bigwedge_{f(t) \in \mathcal{S}} \bigwedge_{\substack{a \in \args(F,f)}} a \leq \subst{t}{x}{b_{\max}}
    \]
    where $\Phi_{\text{max}}(\mathcal{S})$ and $\Phi_{\text{prop-up}}(\mathcal{S})$ are as defined in \cref{def:reqpivot-param}. 
    
    \item \textbf{Downward extension formula $\Psi_{\text{down}}(B,\mathcal{S}')$}:
    \[
    \Phi_{\text{min}}(\mathcal{S}') \;\land\; 
    \Phi_{\text{prop-down}}(\mathcal{S}') \;\land
    \bigwedge_{f(t) \in \mathcal{S}'} \bigwedge_{\substack{a \in \args(F,f)}} a \geq \subst{t}{x}{b_{\min}}
    \]
    where $\Phi_{\text{min}}(\mathcal{S}')$ and $\Phi_{\text{prop-down}}(\mathcal{S}')$ are as defined in \cref{def:reqpivot-param}.
\end{enumerate}
\end{definition}

Thus, for any choice of subsets $\mathcal{S},\mathcal{S}'\subseteq\mathcal{T}$, $\Psi_{\text{up}}(B,\mathcal{S})$ (resp. $\Psi_{\text{down}}(B,\mathcal{S}')$) asserts that $\mathcal{S}$ satisfies the upward (resp.\ $\mathcal{S}'$ satisfies the downward) conditions of \req \emph{and additionally} satisfies the clash condition for interval $B$. The clash condition $a \leq \subst{t}{x}{b_{\max}}$ ensures that for every ground argument $a$ of $f$ appearing in $F$, the propagated cell $f(\subst{t}{x}{\repr{z}})$ with $z > b_{\max}$ and $f(t)\in\mathcal{S}$ is different from the ground cell $f_i(a)$; similarly for downward propagation.

\begin{theorem}[Interval Satisfiability]
\label{thm:interval-certificate-param}
Let $B = [b_{\min}, b_{\max}]$ be a non‑empty integer interval, and assume that
\[
  \Biggl(F \land \bigwedge_{x \in B} Q[x]\Biggr) \;\land\;
  \Biggl(\bigvee_{\mathcal{S}\subseteq \mathcal{T}}\Psi_{\text{up}}([b_{\min},b_{\max}],\mathcal{S})\Biggr)\;\land\;
  \Biggl(\bigvee_{\mathcal{S}'\subseteq \mathcal{T}}\Psi_{\text{down}}([b_{\min},b_{\max}],\mathcal{S}')\Biggr)
\]
is satisfiable, then $\phi$ has a satisfiability certificate, and hence is satisfiable.
\end{theorem}

\begin{proof}
  Suppose the conjunction is satisfiable,   let $I$ be an interpretation satisfying it, and let $\mathcal{S}$ be such that $I\models \Psi_{\text{up}}([b_{\min},b_{\max}],\mathcal{S})$, and $\mathcal{S}'$ such that $I\models \Psi_{\text{down}}([b_{\min},b_{\max}],\mathcal{S})$.  We construct a certificate as in \cref{def:certificate}:

\begin{enumerate}
    \item \textbf{Pre‑satisfiability assignment:} $I$ 
    
    \item \textbf{Well‑order $\preceq$ on $\mathbb{Z}$:}
    \[0, 1, -1, 2, -2, 3, -3, \dots, b_{\max}, b_{\min},b_{\max}+1, b_{\max}+2, \dots,b_{\min}-1, b_{\min}-2, \dots\]		
    
    \item \textbf{Propagated cells $X_z$ for $z \in \mathbb{Z}$:}
    \[
    X_z = 
    \begin{cases}
    \emptyset & \text{if } z \in B, \\[4pt]
    \bigl\{ f(I(\subst{t}{x}{z})) \mid f(t)\in\mathcal{S} \bigr\} & \text{if } z > b_{\max}, \\[4pt]
    \bigl\{ f(I(\subst{t}{x}{z})) \mid f(t)\in\mathcal{S}' \bigr\} & \text{if } z < b_{\min}.
    \end{cases}
    \]
    Note that the maximality and minimality conditions ensure that for $z\not\in B$, $f\in\mathcal{F}$, $|\{ n \mid f(n)\in X_z\}|\leq 1$.

    \item \textbf{Satisfiability propagators:}
    \begin{itemize}
        \item For $z \in B$: $I$ itself satisfies $Q[z]$.
        \item For $z > b_{\max}$: the condition $\Phi_{\text{prop-up}}(\mathcal{S})$ provides, for any given values for all non‑propagated cells in $\Gamma_{I,z}(\phi)$, values $v_{f(t)}$ for each $f(t)\in\mathcal{S}$ such that assigning these values to each corresponding cells in $X_z$ satisfies $Q[z]$.
        \item For $z < b_{\min}$: Symmetrically, use $\Phi_{\text{prop-down}}(\mathcal{S}')$ to assign values to propagated cells.
    \end{itemize}
\end{enumerate}

It remains to verify the disjointness condition of \cref{def:certificate}:
\[
X_z \cap (\mathit{def}(I) \cup \bigcup_{z' \prec z} \Gamma_{I,z'}(\phi)) = \emptyset.
\]

\begin{itemize}
    \item For $z \in B$, $X_z = \emptyset$ holds trivially.
    
    \item For $z > b_{\max}$, consider any $f(I(\subst{t}{x}{z}))$ with $f(t) \in \mathcal{S}$:
    \begin{itemize}
        \item It cannot belong to $\mathit{def}(I)$ because the clash condition $a \leq \subst{t}{x}{b_{\max}}$ in $\Psi_{\text{up}}(B,\mathcal{S})$ guarantees that for every ground argument $a \in \args(F,f)$:
        \[
        I(a) \leq I(\subst{t}{x}{b_{\max}}) < I(\subst{t}{x}{z}),
        \]
        where the strict inequality follows because $t$ contains $x$ with positive coefficient and $z > b_{\max}$.
        
        \item It cannot appear in any $\Gamma_{I,z'}(\phi)$ with $z' \prec z$ because:
        \begin{enumerate}
            \item If $z' \leq b_{\max}$: For any $f(t') \in \mathcal{T}$ with the same $f$, 
            \[
            I(\subst{t'}{x}{z'}) \leq I(\subst{t'}{x}{b_{\max}}) < I(\subst{t}{x}{z}),
            \]
            since $t$ is maximal among terms of $f$ in $\mathcal{T}$ by $\Phi_{\text{max}}(\mathcal{S})$ and $z > b_{\max}$.
            
            \item If $b_{\max} < z' < z$: Then 
            \[
            I(\subst{t'}{x}{z'}) \leq \max_{f(t'') \in \mathcal{T} \text{ with same } f} I(\subst{t''}{x}{z'}) < I(\subst{t}{x}{z})
            \]
            since $t$ is maximal and $z' < z$.
        \end{enumerate}        
    \end{itemize}

    \item The case $z < b_{\min}$ is symmetric, using $\Phi_{\text{min}}(\mathcal{S}')$ and the downward clash condition $a \geq \subst{t}{x}{b_{\min}}$.
\end{itemize}

Thus all certificate requirements are satisfied. By Property \ref{prop:certThenSat}, $\phi$ is satisfiable.
\qedhere\end{proof}

The formula in the premise of \cref{thm:interval-certificate-param} belongs to the language of Presburger arithmetic (i.e., SMTLIB LIA), and hence its satisfiability can be algorithmically checked. Due to this, an interval $[b_{\min},b_{\max}]$ such that this formula is satisfiable is an algorithmically checkable certificate for the satisfiability of $\phi$. In order to make the algorithmic check more efficient, one can also include the model of this formula (which has a straightforward finite representation) and the sets $\mathcal{S}$, $\mathcal{S}'$.

Algorithmic implementations of the satisfiability propagators whose existence is ensured by the proof of \cref{thm:interval-certificate-param} can often be obtained from the witness functions that are 
a side product of quantifier elimination on the
propagability conditions~$\Phi_{\text{prop-up}}(\mathcal{S})$ and~$\Phi_{\text{prop-down}}(\mathcal{S})$. These propagators  can then be used in the recursive evaluation function $val$ defined in \cref{sec:certificate} to compute values of the function that a model assigns to an uninterpreted function symbol.




The theorem immediately yields an algorithm that checks satisfiability by searching for the interval~$[b_{\min},b_{\max}]$. This can be seen in \cref{alg:interval-check-param-withBigvee}. An extension of the algorithm that in the case of the return value \textsc{Sat} also returns a corresponding certificate, is straightforward.


\begin{algorithm}
\caption{Interval‑Based Satisfiability Check}
\label{alg:interval-check-param-withBigvee}
\begin{algorithmic}[1]
\Require $\phi = F \land \forall x.\, Q$ in the fragment
\Ensure \textsc{Sat} or \textsc{Unsat}
\State $b_{\min} \gets 0$, $b_{\max} \gets 0$ 
% \State $I \gets \smt\!\left(F \land Q[0]\right)$
%\While{$I \neq \bot$}
\While{$F \land \bigwedge_{x=b_{\min}}^{b_{\max}} Q[x]$ is satisfiable}
    \State $\text{max}_\text{up}\gets\bigvee_{\mathcal{S}\subseteq \mathcal{T}}\Psi_{\text{up}}([b_{\min},b_{\max}],\mathcal{S}))$
    \State $\text{min}_\text{down}\gets\bigvee_{{\mathcal{S}'\subseteq \mathcal{T}}}\Psi_{\text{down}}([b_{\min},b_{\max}],\mathcal{S}))$ 
    \If{$\left(F \land \bigwedge_{x=b_{\min}}^{b_{\max}} Q[x]\right) \land \text{max}_{\text{up}} \land \text{min}_{\text{down}}$ is satisfiable}
        \State \Return \textsc{Sat} 
    \EndIf
    \State $b_{\min} \gets b_{\min} - 1$, $b_{\max} \gets b_{\max} + 1$ \Comment{Expand interval symmetrically}
    % \State $I \gets \smt\left(F \land \bigwedge_{x=b_{\min}}^{b_{\max}} Q[x]\right)$
\EndWhile
\State \Return \textsc{Unsat}
\end{algorithmic}
\end{algorithm}

% \begin{corollary}[Soundness]
% \label{cor:soundness-bigvee}
% If \cref{alg:interval-check-param-withBigvee} terminates, then it returns a correct result.

% \end{corollary}

% \begin{proof}
%   If the result is $\textsc{Unsat}$, then $F \land \bigwedge_{x=b_{\min}}^{b_{\max}} Q[x]$ is unsatisfiable. This formula is implied by the input formula, and hence the result is correct. 

%   If the result is $\textsc{Sat}$, then this happens during a certain iteration of the while loop. Then there exists:
% \begin{itemize}
%     \item An interval $B = [b_{\min}, b_{\max}]$,
%     \item An interpretation $I$ satisfying:
%     \[
%     I \models F \land \bigwedge_{x \in B} Q[x] \land \text{max}_{\text{up}} \land \text{min}_{\text{down}},
%     \]
%     where $\text{max}_{\text{up}}$ and $\text{min}_{\text{down}}$ are the disjunctions defined in lines 3--4 of the algorithm.
% \end{itemize}

% Since $I \models \text{max}_{\text{up}}$, there exists some $\mathcal{S}\subseteq\mathcal{T}$ such that 
% $I \models \Psi_{\text{up}}(B,\mathcal{S})$. Similarly, $I \models \text{min}_{\text{down}}$ implies there exists 
% $\mathcal{S}'\subseteq\mathcal{T}$ such that $I \models \Psi_{\text{down}}(B,\mathcal{S}')$. Thus $I$ satisfies:
% \[
% F \land \bigwedge_{x \in B} Q[x] \land \Psi_{\text{up}}(B,\mathcal{S}) \land \Psi_{\text{down}}(B,\mathcal{S}').
% \]

% By \cref{thm:interval-certificate-param}, this implies that $\phi$ has a satisfiability certificate 
% for the pair $(\mathcal{S},\mathcal{S}')$, and consequently $\phi$ is satisfiable.
% \qedhere\end{proof}


The correctness of the result \textsc{Sat} of the algorithm is an immediate consequence of \cref{alg:interval-check-param-withBigvee}. The correctness of the result \textsc{Unsat} follows from the fact that the termination condition of the while loop is a logical consequence of the input formula. However, it might also happen that the algorithm runs forever. We can exclude this under certain conditions:

\begin{theorem}[Relative Completeness]
\label{thm:completeness-bigvee}
If the input formula~$\phi$
\begin{enumerate}
    \item is satisfiable, and
    \item satisfies the \req condition for some pair $(\mathcal{S}^*,\mathcal{S}'^*)$ 
          as defined in \cref{def:reqpivot-param},
\end{enumerate}
then \cref{alg:interval-check-param-withBigvee} terminates and returns \textsc{Sat}.
\end{theorem}

\begin{proof}
Assume $\phi$ is satisfiable and satisfies \req for $(\mathcal{S}^*,\mathcal{S}'^*)$. 
Let $\mathcal{M}$ be a model of $\phi$ and extract the corresponding cell interpretation $I^*$. For each function $f \in \mathcal{F}$, let $c_f$ be the common coefficient of $x$ in all its arguments.

For each $f(t)\in\mathcal{F}$, define:
\[
v_{\max}^f = \max\{\, I^*(\subst{t}{x}{0}) \mid f(t) \in \mathcal{T}\,\}, \qquad
v_{\min}^f = \min\{\, I^*(\subst{t}{x}{0}) \mid f(t) \in \mathcal{T} \,\}.
\]
% where $t_0=\subst{t}{x}{0}$ for each $f(t)\in\mathcal{T}$.
The conditions $\Phi_{\text{max}}(\mathcal{S}^*)$ and $\Phi_{\text{min}}(\mathcal{S}'^*)$ ensure that:
\begin{itemize}
    \item For all $f(t) \in \mathcal{S}^*$: $I^*(\subst{t}{x}{0}) = v_{\max}^f$,
    \item For all $f(t) \in \mathcal{S}'^*$: $I^*(\subst{t}{x}{0}) = v_{\min}^f$.
\end{itemize}

% Now choose
% \[
% b_{\max} = \max\{\, I^*(t_g) - v_{\max}^i \mid t_g \in \args(F,f),\; f\in\mathcal{F}\}
% \]
% \[
% b_{\min} = \min\{\, I^*(t_g) - v_{\min}^i \mid t_g \in \args(F,f),\; f\in\mathcal{F}\}.
% \]

Now choose
\[
b_{\max} = \max\left\{\, \left\lceil \frac{I^*(a) - v_{\max}^f}{c_f} \right\rceil \;\middle|\; a \in \args(F,f), f \in \mathcal{F} \,\right\}
\]
\[
b_{\min} = \min\left\{\, \left\lfloor \frac{I^*(a) - v_{\min}^f}{c_f} \right\rfloor \;\middle|\; a \in \args(F,f), f \in \mathcal{F} \,\right\}.
\]

Set $B = [b_{\min}, b_{\max}]$. We verify that $I^*$ satisfies:

\begin{enumerate}
    \item \textbf{Base formula}: $I^* \models F \land \bigwedge_{x \in B} Q[x]$ (since $\mathcal{M} \models \phi$).
    
    \item \textbf{Upward disjunction $\text{max}_{\text{up}}$}: 
    For the specific $\mathcal{S}^*$, we have:
    \begin{itemize}
        \item $\Phi_{\text{max}}(\mathcal{S}^*)$ holds by definition,
        \item $\Phi_{\text{prop-up}}(\mathcal{S}^*)$ holds by the \req condition,
        \item For each $f(t)\in\mathcal{S}^*$ and $a \in \args(F,f)$:\\ Since $I^*(\subst{t}{x}{0})=v_{\max}^f$, we have:
        % \[
        % I^*(t_g) \leq b_{\max} + v_{\max}^f = b_{\max} + I^*(t)
        % \]
        \[
        I^*(a) \leq c_f \cdot b_{\max} + v_{\max}^f = c_f \cdot b_{\max} + I^*(\subst{t}{x}{0}) = I^*(\subst{t}{x}{b_{\max}})
        \]
        by construction of $b_{\max}$, which is exactly the clash condition.
    \end{itemize}
    Thus $I^* \models \Psi_{\text{up}}(B,\mathcal{S}^*)$, and consequently $I^* \models \text{max}_{\text{up}}$.
    
    \item \textbf{Downward disjunction $\text{min}_{\text{down}}$}: 
    Similarly, for $\mathcal{S}'^*$ we have:
    \begin{itemize}
        \item $\Phi_{\text{min}}(\mathcal{S}'^*)$ holds,
        \item $\Phi_{\text{prop-down}}(\mathcal{S}'^*)$ holds,
        \item For each $f(t)\in\mathcal{S}'^{*}$ and $a \in \args(F,f)$:
        % \[
        % I^*(t_g) \geq b_{\min} + v_{\min}^i = b_{\min} + I^*(t)
        % \]
        \[
        I^*(a) \geq c_f \cdot b_{\min} + v_{\min}^f = c_f \cdot b_{\min} + I^*(\subst{t}{x}{0}) = I^*(\subst{t}{x}{b_{\min}})
        \]
        by construction of $b_{\min}$.
    \end{itemize}
    Thus $I^* \models \Psi_{\text{down}}(B,\mathcal{S}'^*)$, and consequently $I^* \models \text{min}_{\text{down}}$.
\end{enumerate}

Let $N = \max(|b_{\min}|, |b_{\max}|)$. \cref{alg:interval-check-param-withBigvee} expands the interval symmetrically from $[0,0]$. When it reaches iteration $n = N$, the interval becomes $[-N, N]$, which contains $B$. At this iteration, line 5 will check the satisfiability of:
\[
F \land \bigwedge_{x=-N}^{N} Q[x] \land \text{max}_{\text{up}} \land \text{min}_{\text{down}}
\]
where $\text{max}_{\text{up}}$ and $\text{min}_{\text{down}}$ are constructed for the interval $[-N, N]$. Since $[-N, N]$ contains $B$, and $I^*$ satisfies all three conditions as shown above, this formula is satisfiable (witnessed by $I^*$). Therefore, the algorithm returns \textsc{Sat}.
\qedhere\end{proof}

While proofs of unsatisfiability are not the main goal of this paper, \Cref{alg:interval-check-param-withBigvee} can also detect unsatisfiability, in some cases.

\begin{theorem}[Termination for Finitely Unsatisfiable Formulas]
\label{thm:finiteunsatThenUNSAT}
If there exists a finite set $Z\subseteq\mathbb{Z}$ such that $F \land \bigwedge_{z\in Z} Q[x \mapsto \repr{z}]$ is unsatisfiable, then \cref{alg:interval-check-param-withBigvee} will terminate and return \textsc{Unsat}.
\end{theorem}

However, there are formulas that are not satisfiable in a standard model\todoSR{Should we make a more general statement? (see the discussion in the MBQI paper)}, for which the algorithm does not terminate.
%This occurs when the unsatisfiability relies on reasoning that cannot be captured by finite instantiation alone.

\begin{example}[Formula Requiring Induction]
Consider the formula:
\[
f(0) = 0 \land f(c) \neq 0 \land \forall x.\, f(x) = f(x+1)
\]
This formula is unsatisfiable in standard integer arithmetic (applying induction in both directions yields $\forall n.\, f(n) = 0$, contradicting $f(c) \neq 0$). However, any finite set of instantiations is satisfiable by choosing $c$ to be a sufficiently large integer. Thus, \cref{alg:interval-check-param-withBigvee} will expand the interval indefinitely without detecting unsatisfiability.
\end{example}


% \paragraph{Summary.}
% In summary, our algorithm:
% \begin{itemize}
%     \item Terminates with \textsc{Sat} for all satisfiable formulas within the fragment that satisfy the \req condition (\cref{thm:completeness-bigvee}).
%     \item Terminates with \textsc{Unsat} for formulas whose unsatisfiability can be detected through finite instantiation alone (\cref{thm:finiteunsatThenUNSAT}).
%     \item May not terminate for formulas whose unsatisfiability requires induction over all integers or instantiations at unbounded offsets.
% \end{itemize}

% \section{Multiple Quantified Variables}

% We now return to the case with multiple quantified variables $\bar{x}=\{x_1,\dots,x_k\}$. Under the assumptions stated in \cref{sec:problem-statement}, the coefficient vectors of all argument terms of uninterpreted function symbols in $Q$ are collinear, and the non-zero coefficient vectors of the arguments of each individual uninterpreted function symbol are identical. Formally, this means there exists a non-zero integer vector $a \in \mathbb{Z}^k$ and, for each function $f \in \mathcal{F}$, a positive integer multiplier $\lambda_f > 0$ such that every argument term $t$ of $f$ in $Q$ can be written as $t = \lambda_f (a \cdot \bar{x}) + b_t$, where $b_t$ is a ground term (independent of $\bar{x}$). 
% % Hence there is some vector $a$, constants $b_t$, $f(t)\in\mathcal{T}$ and multipliers $\lambda_{f}>0$, $f\in\mathcal{F}$ such that each argument of an  uninterpreted function symbol can be written in the form $\lambda_f a x + b_t$. 
% We can then perform a change of variables $z=a\cdot\bar{x}$, and get an equivalent formula that falls within the single‑variable fragment handled by \cref{alg:interval-check-param-withBigvee} in the previous section.

\section{Handling Disjunction Using Auxiliary Propositional Variables}

The algorithm presented so far relies on large disjunctions over all possible subset choices $\mathcal{S}\subseteq\mathcal{T}$ and $\mathcal{S}'\subseteq\mathcal{T}$. While theoretically elegant, these disjunctions lead to formulas with exponential size, making them computationally impractical. In this subsection, we present a compact CNF encoding that avoids this issue.

\paragraph{Encoding Idea.} Instead of enumerating all subset choices we introduce auxiliary Boolean variables that represent membership in the subsets $\mathcal{S}$ and $\mathcal{S}'$. For each term $f(t)\in\mathcal{T}$, we create:
\begin{itemize}
    \item $s_{f(t)}$: true iff $f(t) \in \mathcal{S}$ (for upward propagation)
    \item $s'_{f(t)}$: true iff $f(t) \in \mathcal{S}'$ (for downward propagation)
\end{itemize}

We then encode the conditions $\Phi_{\text{max}}$, $\Phi_{\text{min}}$, $\Psi_\text{up}$, $\Psi_\text{down}$, and the clash conditions using these variables.

\begin{definition}[CNF Encoding of Interval Extension Formulas]
\label{def:interval-extension-formulas-CNF}
For an interval $B = [b_{\min}, b_{\max}]$, define the encoded formulas:
\begin{align*}
\Psi_{\text{up}}^\text{e}(B) &\equiv \Phi_\text{max}^\text{e} \land \Phi_\text{prop-up}^\text{e} \land \text{ClashUpEnc} \\
\Psi_{\text{down}}^\text{e}(B) &\equiv \Phi_\text{min}^\text{e} \land \Phi_\text{prop-down}^\text{e} \land \text{ClashDownEnc}
\end{align*}
where:
\begin{itemize}
    \item Maximality encoding $\Phi_\text{max}^\text{e}$:
    \begin{align*}
        \subst{
        \bigwedge_{f \in \mathcal{F}}\ \bigwedge_{\substack{f(t),\, f(t') \in \mathcal{T}}}
        \left((s_{f(t)} \land s_{f(t')}) \Rightarrow t = t' \;\land\; (s_{f(t)} \land \neg s_{f(t')}) \Rightarrow t > t'\right)}{x}{0}
    \end{align*}
    
    \item Minimality encoding: $\Phi_\text{min}^\text{e}$ defined analogously with $s'_{f(t)}$ and $<$ instead of $>$.
    
    \item Upward propagation encoding $\Phi_{\text{prop-up}}^e$:
    \[
    \bigwedge_{\mathcal{T}_{\!-}\subseteq\mathcal{T}}
    \left(\bigwedge_{f(t)\in\mathcal{T}_{\!-}} \neg s_{f(t)} \;\wedge\; \bigwedge_{f(t)\in\mathcal{T}\setminus\mathcal{T}_{\!-}} s_{f(t)}\;\Rightarrow\; \forall x\, \forall \bar{u}\, \exists \bar{v}\; Q^{\mathcal{T}_{\!-}}\right),
    \]
    where $\bar{u}=(u_{f(t)})_{f(t)\in\mathcal{T}_{\!-}}$ and $\bar{v}=(v_{f(t)})_{f(t)\in\mathcal{T}\setminus\mathcal{T}_{\!-}}$, and $Q^{\mathcal{T}_{\!-}}$ is obtained from $Q$ by simultaneously replacing each $f(t)\in\mathcal{T}_{\!-}$ by $u_{f(t)}$ and each $f(t)\in\mathcal{T}\setminus\mathcal{T}_{\!-}$ by $v_{f(t)}$.

    % \[\bigwedge_{\substack{f(t)\in\mathcal{T} \\ \sigma_{f(t)}\in\{\neg,\cdot\}}} \left(\bigwedge_{f(t)\in\mathcal{T}} \sigma_{f(t)}s_{f(t)}\Rightarrow\forall x \forall \bar{u} \exists \bar{v}.\ Q'\right)\]

    % where $\bar{u}$ corresponds to the variables $u_{f(t)}$ where $\sigma_{f(t)}$ is $\neg$ and $\bar{v}$ to the variables $v_{f(t)}$ where $\sigma_{f(t)}$ is $\cdot$, and $Q'$ is obtained from $Q$ by simultaneously replacing
    % \begin{itemize}
    %     \item every $f(t)\in\mathcal{T}$ with $\sigma_{f(t)}=\neg$ by $u_{f(t)}$, and
    %     \item every $f(t)\in\mathcal{T}$ with $\sigma_{f(t)}=\cdot$ by $v_{f(t)}$, 
    % \end{itemize}
    % and $\cdot$ is a dummy symbol, and hence for any propositional variable $p$, $\cdot p$ is the same as $p$.
    
    \item Downward propagation encoding: This is defined symmetrically.
    
    \item Clash condition encoding:
    \begin{align*}
        \text{ClashUpEnc} &\equiv \bigwedge_{f(t)\in\mathcal {T}}\bigwedge_{a \in \args(F,f_i)} \big(s_{f(t)} \Rightarrow (a \leq \subst{t}{x}{b_{\max}})\big) \\
        \text{ClashDownEnc} &\equiv \bigwedge_{f(t)\in\mathcal
        {T}}\bigwedge_{a \in \args(F,f_i)} \big(s'_{f(t)} \Rightarrow (a \geq \subst{t}{x}{b_{\min}})\big)
    \end{align*}
\end{itemize}
\end{definition}

Note that if for some $f\in\mathcal{{F}}$ the ground parts of the argument terms (obtained by substituting $x=0$) are pairwise different, then at most one $s_{f(t)}$ can be true in any satisfying assignment of $\Psi_{\text{up}}^\text{e}(B)$ or $\Psi_{\text{down}}^\text{e}(B)$. This is because the maximality condition would require two different ground parts to be both equal and ordered, which is impossible. Similarly for minimality condition.

\begin{lemma}[Encoding Correctness]
\label{lem:encoding-correctness}
For any interval $B = [b_{\min}, b_{\max}]$:
\begin{enumerate}
    \item $\Psi_\text{up}^\text{e}(B)$ is satisfiable iff there exists $\mathcal{S}\subseteq\mathcal{T}$ such that $\Psi_{\text{up}}(B,\mathcal{S})$ holds.
    \item $\Psi_\text{down}^\text{e}(B)$ is satisfiable iff there exists $\mathcal{S}' \subseteq\mathcal{T}$ such that $\Psi_{\text{down}}(B,\mathcal{S}')$ holds.
\end{enumerate}
\end{lemma}
\begin{proof}
    ($\Rightarrow$) Suppose $\Psi_\text{up}^\text{e}(B)$ is satisfiable by an assignment $I$. Define $\mathcal{S} = \{f(t) \mid I(s_{f(t)}) = \text{true}\}$. By $\Phi_{\text{max}}^\text{e}$, for each function $f$, all $f(t) \in \mathcal{S}$ have equal ground parts under $I$, and they are strictly greater than those of any $f(t') \in \mathcal{T} \setminus \mathcal{S}$ with the same $f$. Since all terms have the same coefficient of $x$, this implies $\Phi_{\text{max}}(\mathcal{S})$ holds. By $\Phi_{\text{prop-up}}^\text{e}$, all $f(t) \in \mathcal{S}$ are equal to $v_{f(t)}$, satisfying the substitution in $\Phi_{\text{prop-up}}(\mathcal{S})$. Finally, $\text{ClashUpEnc}$ ensures the clash condition $a \leq \subst{t}{x}{b_{\max}}$ for all $f(t) \in \mathcal{S}$. Hence $\Psi_{\text{up}}(B,\mathcal{S})$ holds.

    ($\Leftarrow$) Suppose $\Psi_{\text{up}}(B,\mathcal{S})$ holds for some $\mathcal{S} \subseteq \mathcal{T}$. Set $s_{f(t)}$ true iff $f(t) \in \mathcal{S}$. By $\Phi_{\text{max}}(\mathcal{S})$, for each function $f$, all selected terms have equal ground parts (after $x=0$ substitution) and these are greater than non-selected ones, so $\Phi_{\text{max}}^\text{e}$ holds. Let $v_{f(t)}$ be the common value for $f(t) \in \mathcal{S}$ (guaranteed by $\Phi_{\text{prop-up}}(\mathcal{S})$), then $\Phi_{\text{prop-up}}^\text{e}$ holds. The clash condition from $\Psi_{\text{up}}(B,\mathcal{S})$ ensures $\text{ClashUpEnc}$. Thus $\Psi_\text{up}^\text{e}(B)$ is satisfiable.
    
    The proof for $\Psi_\text{down}^\text{e}(B)$ is symmetric.
\qedhere\end{proof}

\paragraph{Practical Considerations.}
The exponential disjunctions in \cref{alg:interval-check-param-withBigvee} 
(lines 3--4) can be replaced by the CNF encodings $\Psi_\text{up}^\text{e}$ and $\Psi_\text{down}^\text{e}$ as defined above, which are equi-satisfiable by \cref{lem:encoding-correctness}. This yields a practical implementation while preserving all theoretical guarantees. Thus, the CNF encoding approach provides a practical bridge between the theoretical \req framework and implementable algorithm, while avoiding exponential formula size.

\section{Experiments}

There are two basic reasons why verification conditions may fail to hold: (1) a bug, (2) underlying assertions not being inductive. In the first case, the counter-model will typically be finite, since program executions only modify finite memory. In the second case, the counter-model may be infinite. However, even in the first case our method may improve upon methods such as MBQI, due to two reasons:
\begin{itemize}
	\item the models produced by MBQI are very difficult to read
	\item run-time of MBQI increases with the size of the model
\end{itemize}

% For example, on my brand-new notebook, cvc5 with MBQI needs roughly 15sec to show the formula
% \[ f(0)=0 \wedge \forall x \;.\; x<0\vee x>1000\vee f(x+1)=f(x)+1 \]
% to be satisfiable, and then produces an unreadable model of size 25K. After changing the upper bound to 10000, cvc5 does not terminate in 10 minutes, so apparently, the growth is super-linear.

We have prepared a short test suite consisting of small problems such as
\begin{align}\label{eq:exp1}
	f(4)=7 \;\land\; \forall x.\; (0 \le x \le 10^c \;\Rightarrow\; f(x+1)=f(x)+1),
\end{align}
where we tested how well do the state of the art \textsc{smt} solvers \textsc{z3} and \textsc{cvc5}
(ran with the argument \texttt{--mbqi})
scale on such problems with increasing positive $c$. Note that on this particular example,
our algorithm has to check just that for all values of $f(x)$, there exists a value of $f(x+1)$
such that the equality holds. It suffices to consider the interval $[0,\, 4]$.

Another problem in our set is
\begin{align}\label{eq:exp2}
	F       & = (d > 1)\;\land\; f(0)=0 \;\land\; g(2) > f(d+1)             \notag \\
	Q(x)    & = (0 \le x \le 10^c \;\Rightarrow\; f(x-1)=f(x)+g(x)+g(x+d))  \notag \\
	\varphi & = F \;\land\; \forall x.\; Q(x)
\end{align}
Here, our algorithm terminates right after ensuring that \req holds for the interval $[0,\, 3]$.

We ran our experiments on (\textit{server specs}) with a 30-minute time limit.
When setting $c = 1$, the state of the art \textsc{smt} solvers terminate on our
problems immediately. On problem~\eqref{eq:exp1} with $c = 3$, \textsc{cvc5} takes
23 seconds to return \textsc{sat}, and for $c \geq 4$, the solver times out. With
$c \geq 2$, \textsc{z3} returns \textsc{unknown} after 11 seconds. On problem~\eqref{eq:exp2},
\textsc{cvc5} times out with $c \geq 3$ and \textsc{z3} returns \textsc{unknown} starting
from $c = 2$.


\section{Conclusion}

\bibliographystyle{abbrv}
\bibliography{refs}



\appendix




\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
