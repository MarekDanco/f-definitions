\documentclass{llncs}
\usepackage[textwidth=3cm,tickmarkheight=3pt]{todonotes}
\usepackage[utf8]{inputenc}
\usepackage{amssymb, amsmath}
\usepackage{numprint}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\usepackage{color}
\definecolor{citeblue}{rgb}{0.1,0,.4}
\usepackage[pdftex%
,colorlinks=true%
,bookmarks=true%
,linkcolor=citeblue%
,citecolor=citeblue%
,urlcolor=blue%
,plainpages=false]{hyperref}
\hypersetup{colorlinks,citecolor=blue,linkcolor=blue,urlcolor=blue}
\AtBeginDocument{\hypersetup{pdfborder={0 0 1}}}
\usepackage[nameinlink,capitalize,noabbrev]{cleveref} % must come after hyperref
\usepackage{commath}
\usepackage[most]{tcolorbox}
\usepackage{enumitem}

\usepackage{accents} % for \ubar
\newcommand{\ubar}[1]{\underaccent{\bar}{#1}}
\newcommand{\sygus}{SyGuS\xspace}
\newcommand{\qedhere}{$\blacksquare$}

\renewcommand{\algorithmicrequire}{\textbf{Input:}}
\renewcommand{\algorithmicensure}{\textbf{Output:}}

%\newtheorem{definition}{Definition}
%\newtheorem{property}{Property}
%\newtheorem{example}{Example}

%\newtheorem{theorem}{Theorem}
%\newtheorem{lemma}[theorem]{Lemma}
%\newtheorem{corollary}[theorem]{Corollary}
%\theoremstyle{remark}
%\newtheorem{claim}{Claim}
\usepackage{etoolbox}
%\AtEndEnvironment{proof}{\setcounter{claim}{0}}

\npthousandsep{,}
\newcommand{\gmodel}{\mathcal{M}}
\newcommand{\smt}{\textsc{smt}}
\newcommand{\args}{\text{args}}
\usepackage{xspace}
\newcommand{\req}{\emph{ReqPivot}\xspace}
\newcommand{\subst}[3]{#1[#2\leftarrow #3]}
\newcommand{\repr}[1]{\hat{#1}}

\newcommand{\todoSR}[1]{\todo[color=blue!40]{#1}}
\newcommand{\mj}[1]{\todo[color=green!30]{#1 -mik}}
\newcommand{\marek}[1]{\todo[color=red!10]{#1 -MD}}
\newcommand{\todoSN}[1]{\todo[color=orange!50]{#1 -SN}}

\title{%
    Inductive Function Definitions
}
\author{Stefan Ratschan \and Stefan Nugraha \and Mikoláš Janota \and Marek Dančo}
\date{}

\begin{document}
\maketitle
\section{Introduction}

\marek{Mention these \cite{bradley-manna07,bradley-vmcai06,ge-cav09,habermehl-etaps08}}

Current as SMT solvers have limited capabilities to produce counterexamples for complex systems. Yet, counterexamples are important during modeling as they uncover  errors. For example, the user may wrongly assume that an input stream with increasing values will contain  two neighboring values that are equal.  Negating and skolemizing yields the following simple SMT formula.
\begin{equation}
	f(0)\neq f(1)\land\forall x:\mathbb{Z}.\,f(x)<f(x+1)
\end{equation}

The formula has trivial counter-models, e.g. $f$ being the identity function. Such solution can be found by synthesis approaches, such as \sygus.  But it is  easy to get out of the reach of these tools because they are primarily based on templates and candidate-solution enumeration. The following modification is no longer solved by cvc5~\cite{cvc5} in its \sygus mode.

\begin{equation}\label{eq:periodic}
	f(0)\neq f(1)\land\forall x:\mathbb{Z}.\,f(x)=f(x+2)
\end{equation}

These constraints allow only periodic functions whose neighboring values alternate. For such functions the \sygus grammar would have to guess an \textit{ite} term of the form $\mathit{ite}(x\,\mathit{mod}\,2 = 0\enspace a\enspace b)$, for integers $a \not = b$. Even if \sygus tools were improved, they could not yield a decision procedure for UFLIA, due to the inherent undecidability of arithmetic.

We instead isolate a fragment of UFLIA where formulas like~\eqref{eq:periodic} can be decided using SMT techniques. Succinctly, we show that if the arguments of non-constant uninterpreted function symbols are restricted to terms of the form $x + k$, where $x$ is universally quantified and $k$ is a numeral, then the formula’s satisfiability becomes decidable via an inductive argument.

We treat each quantifier as introducing infinitely many constraints on function calls,
which we refer to as cells. A single cell may appear in multiple constraints, so we must
ensure that it is assigned a consistent value throughout. To show satisfiability within
our fragment, we impose an order on these constraints and construct a symbolic assignment
to the cells such that, when processed in this order, no conflicting assignments arise.

\section{Related Work}\label{}
Synthesis of recursive functions by Hozzov\'a et al.~\cite{hozzova-ijcar24}.
Synthesis of strategies on LIA problems Murphy and Kincaid~\cite{kincaid-cav24}.
Synthesis, single invocation Kun\v cak et
al.~\cite{kuncak-pldi10,kuncak-sttt13}.
Array decision procedures~\cite{bradley-vmcai06}: no arithmetic on universally quantified variables allowed.
Habermehl et al.~\cite{habermehl-etaps08} allow difference bounded constraints on array offsets of the form $a[i+c]$. From the MBQI paper: ``For certain cases containing offsets on array indices, our procedure will result in an infinite set of instantiations, while a decision procedure of LIA\footnote{LIA does not refer to linear integer arithmetic, but to the logic allowed by Habermehl et al.}  will terminate. It leaves an open question for future research on how to reason about this type of formulas within an instantiation-based approach.''
Alberti et al.~\cite{alberti2014decision}: only one universally quantified variable allowed.
Elad et al.~\cite{elad2024infinite}: The fragment of FOL for which they prove decidability (OSC, Section~6) does not allow anything like integer arithmetic.

\cite{reynolds2016model}: needs to user to ensure admissibility (Definition~2), the underlying finite model finding algorithm~\cite{reynolds2013finite} may introduce many case splits (``merge lemmas'') for satisfying cardinality constraints. \todoSR{I added a few words here}

computer algebra algorithms for solving difference equations

\subsection{What Can't the Previous Work Solve?}

Here, I am considering the works~\cite{bradley-vmcai06,ge-cav09,habermehl-etaps08}.

\paragraph{Infinitely Increasing But Bounded Integer Sequence}

\[
	\forall{x}. \,f(x)<0 \,\land \,\forall{x}. \,f(x)<f(x+1)
\]

The syntax in~\cite{habermehl-etaps08} includes $\leq$ but does not include $<$. It does include negation though, but only if it
results in the quantified variables being existential. This cannot be solved by~\cite{bradley-vmcai06} (see Theorem 4 in their paper).
\textsc{Z3} cannot solve this on its own but with the addition of Lemma~\ref{eq:ind-needed-lemma} it can. Adding the lemma also helps Vampire but not \textsc{cvc5}.

\paragraph{Two-Valued Constant Function}

\[
	f(0) = 0 \,\land \,f(c) = 3 \,\land \,\forall{x}. \,f(x+1) = f(x)
\]

In the last meeting I hand-wavedly assumed this cannot be in the fragment of~\cite{habermehl-etaps08}.
However, it is. They accept the literals $f(x) - f(x+1) \leq 0$ and $f(x+1) - f(x) \leq 0$, which in conjunction simplify
to $f(x) = f(x+1)$. They can then universally quantify this to form an array property. The other equalities can
be formed as value expressions $A \leq B \,\land \,B \leq A$. I can look more thoroughly at the paper
to see how can they solve this.
This cannot be solved by~\cite{bradley-vmcai06}, because the
third conjunct contains $x+1$ as an argument of $f$ (Theorem 4 in their paper).
\textsc{Z3} cannot solve this -- Compactness section in~\cite{ge-cav09}.

\section{Problem Statement}

\section{Notation}\todoSR{We will see where to put this, in the end}

We will write $\subst{s}{v}{t}$ for the result of substituting the term $t$ for $v$ in the term~$s$. For an integer $z\in\mathbb{Z}$, we will denote the constant representing $z$ in a logical formula by $\repr{z}$\todoSR{Does there exist some standard notation for this?}.

For a formula $F$ and uninterpreted function symbol $f$, $args(F, f)$ will denote the set of argument terms of $f$ in $F$.

Include information on well-orders and induction on well-orders, here?


\section{Definitions}
\todoSR{I intend to add a running example and a figure}
We will view quantifier-free formulas as formulas with a universal quantifier that ranges over an empty tuple of variables. Hence, quantifier-free formulas have precisely one instantiation.

\begin{definition}[Cell]\label{def:cell}
	A \emph{cell} is a term of the form $f(n_1,\dots, n_k)$ where $f$ is an uninterpreted function symbol and $n_1,\dots, n_k$ are integers.\todoSR{Mikoláš used the term ``cell'', which might more succinct and descriptive.}
	\mj{Potentially change notation from $c_i$ to $n_i$ to distinguish numerals
		and constants.}
\end{definition}
Examples of cells are $c$, and $f(7)$. The term $f(c+7)$ is not a cell.

\begin{definition}[Cell Interpretation]
	A \emph{cell interpretation} is a partial function whose domain is the set of cells. A cell interpretation $I$ is \emph{compatible} with an interpretation $\mathcal{I}$ iff $I$ and $\mathcal{I}$ agree on all cells where $I$ is defined.
\end{definition}

Given a cell interpretation $I$, we denote by $\mathit{def}(I)$ the set of cells for which $I$ is defined. Given a term $t$ and a cell interpretation $I$  we define $I(t):=\mathcal{I}(t)$, if  $\mathcal{I}(t)$ is unique for every interpretation $\mathcal{I}$ compatible with $I$, and otherwise $I(t):=\bot$.\todoSR{This is not completely formal, we could also use a more formal, but less readable version.}
For example, for $I=\{ f(0) \mapsto 7 \}$, $I(f(0))=7$, but $I(f(1))=\bot$. Also note that $I(f(1)-f(1))=0\neq\bot$\todoSR{I went for a semantic definition here, since it works very generally without taking much space to define.}. In a similar way, for a formula $\phi$, we define that a cell interpretation~$I$ satisfies $\phi$ iff for every interpretation $\mathcal{I}$ compatible with $I$, $\mathcal{I}$ satisfies $\phi$, in which case we also write $I\models \phi$.

\begin{definition}
	\label{def:pre-sat-cert}
	Given a formula $\phi$ of the form $F\wedge \forall x\;.\; Q$, we call a cell interpretation $I$ such that
        \begin{itemize}
        \item $I\models F$, and
        \item for all $z\in\mathbb{Z}$, for every uninterpreted function symbol~$f$ and its argument terms $t\in args(Q, f)$, $I(\subst{t}{x}{\repr{z}})\neq\bot$
        \end{itemize}
 a \emph{pre-satisfiability assignment} of $\phi$. For any $z\in\mathbb{Z}$, we denote by $\Gamma_{I,z}(\phi)$ the resulting set of cells \[\{ I(\subst{t}{x}{\repr{z}}) \mid t\in args(Q, f), f \emph{ is an uninterpreted function symbol}\}.\]
\end{definition}

For example, $I=\{ c\mapsto 5 \}$ is a pre-satisfiability assignment of $c\geq 5 \wedge \forall x \;.\; f(x+c+1)= f(x+c)+1$, and $\Gamma_{I,10}(\phi)=\{ f(15), f(16)\}$.

\begin{definition}
	\label{def:certificate}
	Given a formula $\phi$  of the form $F\wedge \forall x\;.\; Q$, a \emph{cell propagation certificate} is
	\begin{itemize}
		\item a well-order $\preceq$ on $\mathbb{Z}$,%\footnote{A well-order total order for which every non-empty subset has a least element. This enables induction. If we want to allow sub-formulas to be at the same place in the order, we either need to combine them into equivalence classes, or relax anti-symmetry (i.e., work with a pre-wellorder).}
		\item a pre-satisfiability assignment $I$ of $\phi$,
		\item for every $z\in\mathbb{Z}$
                  \begin{itemize}
                  \item a set $X_z\subseteq \Gamma_{I,z}(\phi)$  (the \emph{propagated cells})\todoSR{alternative term ``propagated cells''} such that \[X_z\cap (\mathit{def}(I)\cup\bigcup_{z'\prec z} \Gamma_{I,z'}(\phi))=\emptyset,\] and
                    %that are neither assigned a value by $I$, nor occur in any $\Gamma_{I,z'}(\phi)$ for any $z'\prec z$
                  \item a certificate (the \emph{satisfiability propagator}) showing that for all values of cells in $\Gamma_{I,z}(\phi)\setminus \mathit{def}(I)\setminus X_z$ there exist values for the cells in $X_z$ such that for the cell interpretation $I_{X_z}$ assigning these values to $X_z$, $I\cup I_{X_z}\models \subst{Q}{x}{\repr{z}}$.
                  \end{itemize}

	\end{itemize}
\end{definition}

For the sake of generality, at this point we do not require the satisfiability propagator to be constructive. Below, we will then work with algorithms computing the values only required to exist, here.

Also note that for $z\in\mathbb{Z}$ such that $\Gamma_{I,z}\subseteq \mathit{def}(I)$, the set of fresh variables $X_z$ must be empty, and the satisfiability propagator only needs to certify that $I\models \subst{Q}{x}{\repr{z}}$. In other words, the cell interpretation~$I$ serving as a pre-satisfiability assignment already plays the role of the satisfiability propagator. 

\begin{property}\label{prop:certThenSat}
	Every formula formula $\phi$  of the form $F\wedge \forall x\;.\; Q$ that has a cell propagation certificate is satisfiable.
\end{property}

\begin{proof}
	Assume a formula of the given form and assume that it  has a cell propagation certificate.
	The corresponding pre-satisfiability assignment $I$ satisfies the quantifier free part~$F$ of $\phi$.

We start by showing
 that for every $z\in\mathbb{Z}$ there is an extension $I'$ of $I$ such that $I'\models\{ \subst{Q}{x}{\repr{z}'} \mid z'\preceq z\}$. For this we use the principle of induction on well-orders: Let $z\in\mathbb{Z}$, and let $\Phi$ be $\{ \subst{Q}{x}{\repr{z}'} \mid z'\prec z\}$. We assume that there is an extension $I_{\Phi}$ of $I$ with $I_{\Phi}\models\Phi$, and prove that there is an extension $I'$ of $I$ with $I'\models\Phi\cup \{ \subst{Q}{x}{\repr{z}}\}$. Since the formula has a cell propagation certificate, the propagated cells of $\subst{Q}{x}{\repr{z}}$ do not occur in any element of $\Phi$. Let $I'$ be the extension of $I_{\Phi}$ that assigns to the propagated cells $X_z$ the values whose existence is  confirmed by the satisfiability propagator. Since these do not occur in $\Phi$, $I'$ and $I_{\Phi}$ coincide on cells occurring in $\Phi$. Hence $I'$ satisfies both $\Phi$ and $\subst{Q}{x}{\repr{z}}$, and so it satisfies $\Phi\cup \{ \subst{Q}{x}{\repr{z}}\}$.

	Now denote for every $z\in\mathbb{Z}$ the cell interpretation  satisfying $\subst{Q}{x}{\repr{z}}$ as constructed in the previous paragraph by $I_z$.
	% From the well-order $\prec$ we get a corresponding well-order on these cell interpretations.
	% Let $I_{\phi}$ be the cell interpretation that, for any cell $u$, assigns the value to $u$ that $I_{z}$ assigns to it for the smallest $z$ (wrt. $\prec$) that assigns a value to $u$. This smallest $z$ exists, since $\prec$ is a well-order. The cell interpretation $I_{\phi}$ satisfies $\phi$, and any classical interpretation compatible with the values assigned by $I_{\phi}$ satisfies $\phi$, as well.
Observe that for every cell $u$, and $z, z'\in \mathbb{Z}$ with $I_z(u)\neq \bot$ and $I_{z'}(u)\neq \bot$, $I_z(u)=I_{z'}(u)$.      Let $I_\phi$ be the assignment that, for any cell $u$, if there is a $z$ such that $I_z(u)\neq \bot$, then $I_\phi(u)=I_z(u)$, and otherwise $I_\phi(u)=0$. Certainly $I_\phi\models F$. Moreover, for every $z\in\mathbb{Z}$,  $I_\phi\models  \subst{Q}{x}{\repr{z}}$, since $I_\phi$ coincides with $I_z$ for all elements, where it is defined. Hence  $I_\phi\models \phi$.
\end{proof}

A cell propagation certificate only shows that a formula is satisfiable. It does not provide concrete values of the corresponding model. We now show how to compute such values from a given cell propagation certificate containing a pre-satisfiability assignment $I$. For this, we require the satisfiability propagators to be constructive. So, for $z\in\mathbb{Z}$ and for each $u\in X_z$ we assume a function $prop_{u,z}$ such that for
a cell interpretation $I'$ with $\mathit{def}(I')=\Gamma_{I,z}(\phi)\setminus \mathit{def}(I)\setminus X_z$, $I\cup I'\cup \{ u \mapsto prop_{u,z}(I\cup I') \mid u\in{X_z}\}\models\subst{Q}{x}{\repr{z}}$.
 
% for any $\hat{v}_1,\dots,\hat{v}_r$, the cell interpretation
% \[\{ v_1\mapsto \hat{v}_1,\dots,v_r\mapsto \hat{v}_1, u_1\mapsto  prop_{u_1}(\hat{v}_1,\dots, \hat{v}_r),\dots, u_s\mapsto prop_{u_s}(\hat{v}_1,\dots,\hat{v}_r)\} \] satisfies $\psi$

% For any instantiation $\psi$ of a quantified sub-formula with propagated cells $u_1,\dots, u_s$ and non-propagated cells $v_1,\dots, v_r$, the satisfiability propagator defines  functions $prop_{u_1},\dots, prop_{u_s}$ such that for any $\hat{v}_1,\dots,\hat{v}_r$, the cell interpretation
% \[\{ v_1\mapsto \hat{v}_1,\dots,v_r\mapsto \hat{v}_1, u_1\mapsto  prop_{u_1}(\hat{v}_1,\dots, \hat{v}_r),\dots, u_s\mapsto prop_{u_s}(\hat{v}_1,\dots,\hat{v}_r)\} \] satisfies $\psi$. In many cases, these functions can be synthesized automatically from the corresponding quantifier elimination problem~\cite{kuncak-sttt13}.\marek{Is \cite{kuncak-sttt13} applicable in our case too?}


Now, observe that for any cell $u$ there is at most one $z\in\mathbb{Z}$ with $u\in X_z$ (if there would be more than one then, due to $\preceq$ being a well-order, there is a minimal one, let us say $z_{\min}$, and then, for any $z'\succ z$, the requirements on $X_{z'}$ exclude the possibility of $X_{z'}$ containing $u$, as well). So for any cell $u$, let $\mathit{inst}(u)$ either be the $z\in\mathbb{Z}$ with $u\in X_z$ or $\bot$ if there is no such instantiation.

Then, for the assignment $I_\phi$ from the proof of Property~\ref{prop:certThenSat}, which satisfies a given formula~$\phi$, and a given cell~$u$, the value of $I_\phi(u)$ can be computed by the following recursive function $val(u)$:
\begin{tabbing}\hspace*{0.4cm}\=\hspace*{0.4cm}\=\kill
	\textbf{if} $I$ assigns a value $x$ to $u$ \textbf{then} \textbf{return} $x$\\
	\textbf{if} $\mathit{inst}(u)=\bot$ \textbf{then} \textbf{return} 0\\
	\textbf{return} $prop_{u,\mathit{inst}(u)}(I\cup \{ v\mapsto val(v) \mid v\in \Gamma_{I,\mathit{inst}(u)}(\phi)\setminus \mathit{def}(I)\setminus X_z\})$
\end{tabbing}

Here, the recursive calls go down the order $\prec$ in the following sense:
\begin{property}
	Let $u$ be a cell such that $\mathit{inst}(u)\neq\bot$. Then for any $v\in\Gamma_{I,\mathit{inst}(u)}(\phi)\setminus \mathit{def}(I)\setminus X_z$ with $\mathit{inst}(v)\neq\bot$, $\mathit{inst}(v)\prec \mathit{inst}(u)$.
\end{property}

So each recursive call of the program $val$ either results in $\mathit{inst}(u)$ either decreasing or being $\bot$. In the latter case, the program terminates immediately, and the former case cannot happen infinitely often, since the used order is well-founded. So we have:
\begin{property}
The program $val$ terminates.
\end{property}

Note that, in general, it is not possible to compute $val(u)$ by computing the values of $X_z, z \in \mathbb{Z}$, with $z$ being initialized with the minimal $z$ wrt. $\prec$, and then using a loop that increases $z$ from one successor wrt. $\prec$ to the next. For example, if  $\prec$  orders all even numbers before all odd ones, then this loop would have to iterate over infinitely many even numbers before computing the value of an odd one.
     

The goal is now an algorithm that computes such cell propagation certificates and a converse of the property that shows for certain classes of satisfiable  formulas this algorithm succeeds.

\section{Algorithm}\label{sec:alg}

Class of formulas:
\[ F\wedge \forall x\;.\; Q(f_1(x+t^{f_1}_1),\dots,f_1(x+t^{f_1}_{l_1}),\dots,f_r(x+t^{f_r}_1),\dots,f_r(x+t^{f_r}_{l_r})),\]
where $F$ is quantifier free, for every $i\in \{1,\dots,r\}$, and the  $t^{f_i}_{1},\dots,t^{f_i}_{l_i}$ are pairwise different LIA ground terms.~\todoSR{We are about to extend the algorithm to this case. Is ``LIA ground term'' correct terminology?}


% We will satisfy the universal quantifier by an inductive argument going both up and down. For making this argument work, we require that for one of the $f_1,\dots,f_r$, let us say for $f_{i^*}$, for both its highest argument $f_{i^*}(x+c^{f_{i^*}}_{l_{i^*}})$ and lowest argument $f_{i^*}(x+c^{f_{i^*}}_1)$ we can always find values satisfying $Q$. More formally, there must be an $i^*\in \{1,\dots, r\}$ such that
% % \mj{Just to be clear, the requirement above does not apply to $f(x)<f(x+1)\land f(x+1)<f(x+3)$?}
% % \todoSR{Correct. It applies to both parts individually, but not to the conjunction. This is  restrictive, of course, but allowed for an easy generalization to the case of several occurrences of the same function symbol with different arguments.}
% \begin{itemize}
%     \item for all values of cells\mj{I still think that the terminology is wrong. Cell is $f(1)$, not $f(x+1)$ by \cref{def:cell}.} in $Q$ except for $f_{i^*}(x+c^{f_{i^*}}_{l_{i^*}})$ there is a value for $f_{i^*}(x+c^{f_{i^*}}_{l_{i^*}})$ satisfying $Q$, and
%     \item for all values of cells in $Q$ except for $f_{i^*}(x+c^{f_{i^*}}_1)$ there is a value for $f_{i^*}(x+c^{f_{i^*}}_1)$ satisfying $Q$.
% \end{itemize}

% In the following, we will call this condition \req. We will assume that we have corresponding satisfiability propagators (see Definition~\ref{def:certificate})
% available.

We will satisfy the universal quantifier by an inductive argument going both up and down. For making this argument work, we require the multi-\req condition described as follows.


% \paragraph{\textbf{Multi-\req Condition}} First, we formalise the condition that enables propagation in both directions, generalising the single-pivot \req condition to allow multiple functions to serve as pivots.

\begin{definition}[Multi-\req Condition (parametric version)]
\label{def:multi-reqpivot-param}
Let $f_1, \dots, f_r$ be the uninterpreted function symbols appearing in $Q$, with $T_i = \{t^{f_i}_1, \dots, t^{f_i}_{l_i}\}$ being the offset terms for $f_i$.

For any choice of subsets $\mathcal{S} = (S_1,\dots,S_r)$ with $S_i \subseteq T_i$, define:

\begin{itemize}
    \item \textbf{Maximality condition $\Phi_{\text{max}}(\mathcal{S})$:}
        \[
        \bigwedge_{i=1}^{r} \left(
        \bigwedge_{t,t' \in S_i} t = t' \;\land\;
        \bigwedge_{t \in S_i, t' \in T_i \setminus S_i} t > t'
        \right).
        \]
    \item \textbf{Upward propagability condition $\Phi_{\text{prop-up}}(\mathcal{S})$:}\\
        \[\forall x \forall \bar{u}_1 \dots \forall \bar{u}_r \exists v_1\dots \exists v_r.\ Q'(\mathcal{S})\] where  $Q'(\mathcal{S})$ is the formula obtained from $Q$ by simultaneously replacing for all $i\in\{1,\dots,r\}$,
        \begin{itemize}
            \item every $f_i(x+t)$ such that $t \in S_i$ by $v_i$,
            \item every $f_i(x+t)$ such that $t \in T_i \setminus S_i$ by the corresponding $u_i^t \in \bar{u}_i$, where $\bar{u}_i = \{u_i^t \mid t \in T_i \setminus S_i\}$.
        \end{itemize}
\end{itemize}

Symmetrically, for downward propagation with subsets $\mathcal{S}' = (S'_1,\dots,S'_r)$, define $\Phi_{\text{min}}(\mathcal{S}')$ (with $<$ instead of $>$) and $\Phi_{\text{prop-down}}(\mathcal{S}')$.

We say that $Q$ satisfies the \emph{multi-\req condition for $(\mathcal{S}, \mathcal{S}')$} if
\begin{itemize}
    \item $\Phi_{\text{max}}(\mathcal{S})$ and $\Phi_{\text{prop-up}}(\mathcal{S})$ hold,
    \item $\Phi_{\text{min}}(\mathcal{S}')$ and $\Phi_{\text{prop-down}}(\mathcal{S}')$ hold.
\end{itemize}

We say $Q$ satisfies the \emph{multi-\req condition} if there exists \emph{some} pair~$(\mathcal{S}, \mathcal{S}')$ such that $Q$ satisfies the multi-\req condition for $(\mathcal{S}, \mathcal{S}')$.
\end{definition}

Intuitively, the multi‑\req condition generalises the single‑pivot \req condition by allowing \emph{multiple functions} to serve as pivots simultaneously. For upward propagation, we select for each function $f_i$ a subset $S_i$ of its offsets that are maximal (all equal and strictly greater than other offsets of $f_i$). The propagability condition then guarantees that, no matter what values are assigned to the non‑maximal occurrences, we can find values $v_1,\dots,v_r$ such that assigning $v_i$ to all occurrences $f_i(x+t)$ with $t\in S_i$ makes $Q$ true. Different functions may receive different values. The old single‑pivot \req is the special case where exactly one $S_i$ is non‑empty and contains a single offset. The downward condition is symmetric.


\begin{example}[Multi-\req Illustration]
Consider the formula:
\[
\forall x.\ f(x+c+3) + f(x+4) + f(x+1) = g(x+2) + h(x)
\]
where $c$ is a ground constant. The offset terms for each function are:
\begin{align*}
T_f &= \{c+3,\ 4,\ 1\}, \quad T_g = \{2\}, \quad T_h = \{0\}.
\end{align*}
We have three offsets for $f$: a ground term $c+3$, and two numerals $4$ and $1$.

\medskip\noindent\textbf{Upward propagation:}
% Consider two possible choices:

% \begin{enumerate}
%     \item \textbf{Choice 1: Take only the numerically maximal offset}
Consider the choice $\mathcal{S} = (S_f, S_g, S_h) = (\{4\}, \{2\}, \emptyset)$.
    \begin{enumerate}
        \item \textbf{Maximality $\Phi_{\text{max}}(\mathcal{S})$:}
        \begin{itemize}
        \item For $f$: $S_f = \{4\}$, $T_f \setminus S_f = \{c+3, 1\}$
            \item For $g$: $S_g = \{2\}$, $T_g \setminus S_g = \emptyset$
            \item For $h$: $S_h = \emptyset$
            \end{itemize}
This results in $\Phi_{\text{max}}(\mathcal{S})\equiv 4 = 4 \land 4 > c+3 \land 4 > 1 \land\ 2=2$, which is true 
provided $c < 1$.

        \item \textbf{Propagability $\Phi_{\text{prop-up}}(\mathcal{S})$:}
        We introduce
        \begin{itemize}
            \item $v_f$ for $f(x+4)$,
            \item $v_g$ for $g(x+2)$,
            \item $u_f^{c+3}$ for $f(x+c+3)$ and $u_f^1$ for $f(x+1)$,
            \item $u_h^0$ for $h(x)$,
        \end{itemize}

         and get the propagability condition 
        \[
        \forall x \forall u_f^{c+3} \forall u_f^1 \forall u_h^0 \exists v_f \exists v_g.\ 
        u_f^{c+3} + v_f + u_f^1 = v_g + u_h^0.
        \]
        This is true: for any $u_f^{c+3}, u_f^1, u_h^0$, choose $v_g = 0$ and $v_f = u_h^0 - u_f^{c+3} - u_f^1$.
    \end{enumerate}
    
%     \item \textbf{Choice 2: Take the general term if it's maximal}
%     Alternatively, if $c+3 \geq 4$ (i.e., $c \geq 1$), we could choose:
%     \[
%     S_f = \{c+3\}, \quad S_g = \{2\}, \quad S_h = \emptyset.
%     \]
%     Then $\Phi_{\text{max}}$ requires $c+3 > 4$ and $c+3 > 1$, i.e., $c > 1$.
% \end{enumerate}

\medskip\noindent\textbf{Downward propagation:}
Consider the choice %Choice for downward: Take the numerically minimal offset}
$\mathcal{S}' = (S'_f, S'_g, S'_h) = (\{1\}, \emptyset, \{0\})$.
\begin{enumerate}
    \item \textbf{Minimality $\Phi_{\text{min}}(\mathcal{S}')$:}
    \begin{itemize}
        \item For $f$: $S'_f = \{1\}$, $T_f \setminus S'_f = \{c+3, 4\}$
        \item For $h$: $S'_h = \{0\}$, $T_h \setminus S'_h = \emptyset$
        \item For $g$: $S'_g = \emptyset$
        \end{itemize}
This results in $\Phi_{\text{min}(\mathcal{S}')}\equiv 1 = 1\land 1 < c+3 \land 1 < 4 \ \land\  0=0$, which is true provided
 $c > -2$.

    \item \textbf{Propagability $\Phi_{\text{prop-down}}(\mathcal{S}')$:}
    We introduce
    \begin{itemize}
        \item $v'_f$ for $f(x+1)$,
        \item $v'_h$ for $h(x)$,
        \item $u_f^{c+3}$ for $f(x+c+3)$ and $u_f^4$ for $f(x+4)$,
        \item $u_g^2$ for $g(x+2)$,
    \end{itemize}
    and get the propagability condition
    \[
    \forall x \forall u_f^{c+3} \forall u_f^4 \forall u_g^2 \exists v'_f \exists v'_h.\ 
    u_f^{c+3} + u_f^4 + v'_f = u_g^2 + v'_h
    \]
    This is true: choose $v'_h = 0$ and $v'_f = u_g^2 - u_f^{c+3} - u_f^4$.
\end{enumerate}

\noindent\textbf{Putting it together:}
$Q$ satisfies multi-\req for the pair $(\mathcal{S},\mathcal{S}')$ if we can find $c$ satisfying both:
\begin{itemize}
    \item For upward: $c < 1$
    \item For downward: $c > -2$
\end{itemize}
Thus any $c \in (-2, 1)$ works. This demonstrates that for such $c$, the specific choices $\mathcal{S} = (\{4\},\{2\},\emptyset)$ and $\mathcal{S}' = (\{1\},\emptyset,\{0\})$ witness the multi‑\req condition.
\end{example}

Now, given a concrete interval $B = [b_{\min}, b_{\max}]$, we need additional ``clash conditions'' that prevent the cells generated during propagation from clashing with the ground part $F$.

\begin{definition}[Interval Extension Formulas (parameterised)]
\label{def:interval-extension-formulas-param}
For an interval $B = [b_{\min}, b_{\max}]$ and subsets $\mathcal{S} = (S_1,\dots,S_r)$, $\mathcal{S}' = (S'_1,\dots,S'_r)$, define:

\begin{enumerate}
    \item \textbf{Upward extension formula $\Psi_{\text{up}}(B,\mathcal{S})$}:
    \[
    \Phi_{\text{max}}(\mathcal{S})\;\land\; 
    \Phi_{\text{prop-up}}(\mathcal{S}) \;\land
    \bigwedge_{i=1}^{r} \bigwedge_{\substack{t_g \in \args(F,f_i) \\ t \in S_i}} t_g \leq b_{\max}+t
    \]
    where $\Phi_{\text{max}}(\mathcal{S})$ and $\Phi_{\text{prop-up}}(\mathcal{S})$ are as defined in \cref{def:multi-reqpivot-param}.
    
    \item \textbf{Downward extension formula $\Psi_{\text{down}}(B,\mathcal{S}')$}:
    \[
    \Phi_{\text{min}}(\mathcal{S}') \;\land\; 
    \Phi_{\text{prop-down}}(\mathcal{S}') \;\land
    \bigwedge_{i=1}^{r} \bigwedge_{\substack{t_g \in \args(F,f_i) \\ t \in S_i'}} t_g \geq b_{\min}+t
    \]
    where $\Phi_{\text{min}}(\mathcal{S}')$ and $\Phi_{\text{prop-down}}(\mathcal{S}')$ are as defined in \cref{def:multi-reqpivot-param}.
\end{enumerate}
\end{definition}

Thus, for any choice of subsets $\mathcal{S} = (S_1,\dots,S_r)$, $\Psi_{\text{up}}(\mathcal{S}, B)$ (resp.\ $\Psi_{\text{down}}(\mathcal{S}', B)$) asserts that $\mathcal{S}$ satisfies the upward (resp.\ $\mathcal{S}'$ satisfies the downward) conditions of multi‑\req \emph{and additionally} satisfies the clash condition for interval $B$. The clash condition ensures that no cell $f_i(z+t)$ with $z > b_{\max}$ (resp. $z < b_{\min}$) and $t \in S_i$ already appears in the ground part $F$.

\begin{theorem}[Interval Satisfiability (parameterised version)]
\label{thm:interval-certificate-param}
Let $B = [b_{\min}, b_{\max}]$ be a non‑empty integer interval, and let $\mathcal{S} = (S_1,\dots,S_r)$, $\mathcal{S}' = (S'_1,\dots,S'_r)$ be subsets satisfying the multi-\req condition for $(\mathcal{S}, \mathcal{S}')$ as defined in \cref{def:multi-reqpivot-param}.  
Then $\phi = F \land \forall x.\, Q$ has a cell propagation certificate — and hence is satisfiable — provided that
\[
\Bigl(F \land \bigwedge_{x \in B} Q[x]\Bigr) \;\land\; \Psi_{\text{up}}(B,\mathcal{S}) \;\land\; \Psi_{\text{down}}(B,\mathcal{S}')
\]
holds.
\end{theorem}

\begin{proof}
Suppose the conditions of the theorem hold, and let $I$ be an interpretation satisfying
\[
F \land \bigwedge_{x \in B} Q[x]\;\land\; \Psi_{\text{up}}(B,\mathcal{S}) \;\land\; \Psi_{\text{down}}(B,\mathcal{S}').
\]

We construct a certificate as in \cref{def:certificate}:

\begin{enumerate}
    \item \textbf{Well‑order $\preceq$ on $\mathbb{Z}$:}
    \[0, 1, -1, 2, -2, 3, -3, \dots, b_{\max}, b_{\min},b_{\max}+1, b_{\max}+2, \dots,b_{\min}-1, b_{\min}-2, \dots\]		
        
    \item \textbf{Pre‑satisfiability assignment:} $I$ 
    
    \item \textbf{Propagated cells $X_z$ for $z \in \mathbb{Z}$:}
    \[
    X_z = 
    \begin{cases}
    \emptyset & \text{if } z \in B, \\[4pt]
    \bigl\{ f_i(z+t) \mid i=1,\dots,r,\; t \in S_i \bigr\} & \text{if } z > b_{\max}, \\[4pt]
    \bigl\{ f_i(z+t) \mid i=1,\dots,r,\; t \in S_i' \bigr\} & \text{if } z < b_{\min}.
    \end{cases}
    \]
    
    \item \textbf{Satisfiability propagators:}
    \begin{itemize}
        \item For $z \in B$: $I$ itself satisfies $Q[z]$.
        \item For $z > b_{\max}$: the condition $\Phi_{\text{prop-up}}(\mathcal{S})$ provides a function that, given values for all non‑propagated cells in $\Gamma_{I,z}(\phi)$, returns values $v_1,\dots,v_r$ to assign to every $f_i(z+t)$ with $t \in S_i$, thereby satisfying $Q[z]$.
        \item For $z < b_{\min}$: the condition $\Phi_{\text{prop-down}}(\mathcal{S}')$ yields a propagator for the cells $f_i(z+t)$ with $t \in S_i'$.
    \end{itemize}
\end{enumerate}

It remains to verify the disjointness condition of \cref{def:certificate}:
\[
X_z \cap (\mathit{def}(I) \cup \bigcup_{z' \prec z} \Gamma_{I,z'}(\phi)) = \emptyset.
\]

\begin{itemize}
    \item For $z \in B$, $X_z = \emptyset$ holds trivially.
    \item For $z > b_{\max}$, consider any $f_i(z+t)$ with $t \in S_i$.
    \begin{itemize}
        \item It cannot belong to $\mathit{def}(I)$ because the clash condition $t_g \leq b_{\max} + t$ in $\Psi_{\text{up}}(B,\mathcal{S})$ guarantees $I(t_g) \leq b_{\max} + I(t) < z + I(t)$ for every $t_g \in \args(F,f_i)$.
        \item It cannot appear in any $\Gamma_{I,z'}(\phi)$ with $z' \prec z$ because either:
        \begin{enumerate}
            \item $z' \leq b_{\max}$: then $z'+I(t') \leq b_{\max} + I(t') < z + I(t)$ for all $t' \in T_i$,
            \item $b_{\max} < z' < z$: then $z'+I(t') \leq z'+ \max_{t'' \in T_i} I(t'') < z + I(t)$ since $I(t)$ is maximal among $\{I(t'') \mid t'' \in T_i\}$ by $\Phi_{\text{max}}(\mathcal{S})$.
        \end{enumerate}
    \end{itemize}

    \item The case $z < b_{\min}$ is symmetric, using $\Phi_{\text{min}}(\mathcal{S}')$ and the downward clash condition.
\end{itemize}

Thus all certificate requirements are satisfied. By Property \ref{prop:certThenSat}, $\phi$ is satisfiable.
\end{proof}

\cref{thm:interval-certificate-param} immediately yields an algorithm that searches for an interval $B$ satisfying the three conditions. This can be seen in \cref{alg:interval-check-param-withBigvee}.

\begin{algorithm}
\caption{Interval‑Based Sat Check (par. multi-\req) with $\bigvee$}
\label{alg:interval-check-param-withBigvee}
\begin{algorithmic}[1]
\Require $\phi = F \land \forall x.\, Q$ in the fragment
\Ensure \textsc{Sat} or \textsc{Unsat}
\State $b_{\min} \gets 0$, $b_{\max} \gets 0$ 
\State $I \gets \smt\!\left(F \land Q[0]\right)$
\While{$I \neq \bot$}
    \State $\text{max}_\text{up}\gets\bigvee_{S_1\subseteq T_1,\dots,S_r\subseteq T_r}\Psi_{\text{up}}([b_{\min},b_{\max}],(S_1,\dots,S_r))$
    \State $\text{min}_\text{down}\gets\bigvee_{S_1'\subseteq T_1,\dots,S_r'\subseteq T_r}\Psi_{\text{down}}([b_{\min},b_{\max}],(S_1',\dots,S_r'))$ 
    \If{$\smt\left(F \land \bigwedge_{x=b_{\min}}^{b_{\max}} Q[x] \land \text{max}_{\text{up}} \land \text{min}_{\text{down}}\right) \neq \bot$}
        \State \Return \textsc{Sat} 
    \EndIf
    \State $b_{\min} \gets b_{\min} - 1$, $b_{\max} \gets b_{\max} + 1$ \Comment{Expand interval symmetrically}
    \State $I \gets \smt\left(F \land \bigwedge_{x=b_{\min}}^{b_{\max}} Q[x]\right)$
\EndWhile
\State \Return \textsc{Unsat}
\end{algorithmic}
\end{algorithm}

\begin{corollary}[Soundness of \cref{alg:interval-check-param-withBigvee}]
\label{cor:soundness-bigvee}
\cref{alg:interval-check-param-withBigvee} is sound: if it returns \textsc{Sat}, then $\phi = F \land \forall x.\, Q$ is satisfiable.
\end{corollary}

\begin{proof}
Assume \cref{alg:interval-check-param-withBigvee} returns \textsc{Sat} at some iteration. Then there exists:
\begin{itemize}
    \item An interval $B = [b_{\min}, b_{\max}]$,
    \item An interpretation $I$ satisfying:
    \[
    I \models F \land \bigwedge_{x \in B} Q[x] \land \text{max}_{\text{up}} \land \text{min}_{\text{down}},
    \]
    where $\text{max}_{\text{up}}$ and $\text{min}_{\text{down}}$ are the disjunctions defined in lines 4--5 of the algorithm.
\end{itemize}

Since $I \models \text{max}_{\text{up}}$, there exists some $\mathcal{S} = (S_1,\dots,S_r)$ such that 
$I \models \Psi_{\text{up}}(B,\mathcal{S})$. Similarly, $I \models \text{min}_{\text{down}}$ implies there exists 
$\mathcal{S}' = (S'_1,\dots,S'_r)$ such that $I \models \Psi_{\text{down}}(B,\mathcal{S}')$.

Thus $I$ satisfies:
\[
F \land \bigwedge_{x \in B} Q[x] \land \Psi_{\text{up}}(B,\mathcal{S}) \land \Psi_{\text{down}}(B,\mathcal{S}').
\]

By \cref{thm:interval-certificate-param}, this implies that $\phi$ has a cell propagation certificate 
for the pair $(\mathcal{S},\mathcal{S}')$, and consequently $\phi$ is satisfiable.
\end{proof}

\begin{theorem}[Relative Completeness of \cref{alg:interval-check-param-withBigvee}]
\label{thm:completeness-bigvee}
Let $\phi = F \land \forall x.\, Q$ be a formula in our fragment. If
\begin{enumerate}
    \item $\phi$ is satisfiable, and
    \item $\phi$ satisfies the multi‑\req condition for some pair $(\mathcal{S}^*,\mathcal{S}'^*)$ 
          as defined in \cref{def:multi-reqpivot-param},
\end{enumerate}
then \cref{alg:interval-check-param-withBigvee} terminates and returns \textsc{Sat}.
\end{theorem}

\begin{proof}
Assume $\phi$ is satisfiable and satisfies multi‑\req for $(\mathcal{S}^*,\mathcal{S}'^*)$. 
Let $\mathcal{M}$ be a model of $\phi$ and extract the corresponding cell interpretation $I^*$.

For each $i$, define:
\[
v_{\max}^i = \max\{\, I^*(t) \mid t \in T_i \,\}, \qquad
v_{\min}^i = \min\{\, I^*(t) \mid t \in T_i \,\}.
\]

The conditions $\Phi_{\text{max}}(\mathcal{S}^*)$ and $\Phi_{\text{min}}(\mathcal{S}'^*)$ ensure that:
\begin{itemize}
    \item For all $t \in S_i^*$: $I^*(t) = v_{\max}^i$,
    \item For all $t \in S_i'^*$: $I^*(t) = v_{\min}^i$.
\end{itemize}

Now choose
\[
b_{\max} = \max\{\, I^*(t_g) - v_{\max}^i \mid t_g \in \args(F,f_i),\; i=1,\dots,r \,\},
\]
\[
b_{\min} = \min\{\, I^*(t_g) - v_{\min}^i \mid t_g \in \args(F,f_i),\; i=1,\dots,r \,\}.
\]

Set $B = [b_{\min}, b_{\max}]$. We verify that $I^*$ satisfies:

\begin{enumerate}
    \item \textbf{Base formula}: $I^* \models F \land \bigwedge_{x \in B} Q[x]$ (since $\mathcal{M} \models \phi$).
    
    \item \textbf{Upward disjunction $\text{max}_{\text{up}}$}: 
    For the specific $\mathcal{S}^*$, we have:
    \begin{itemize}
        \item $\Phi_{\text{max}}(\mathcal{S}^*)$ holds by definition,
        \item $\Phi_{\text{prop-up}}(\mathcal{S}^*)$ holds by the multi-\req condition,
        \item For each $i$ and $t_g \in \args(F,f_i)$ with $t \in S_i^*$:
        \[
        I^*(t_g) \leq b_{\max} + v_{\max}^i = b_{\max} + I^*(t)
        \]
        by construction of $b_{\max}$.
    \end{itemize}
    Thus $I^* \models \Psi_{\text{up}}(B,\mathcal{S}^*)$, and consequently $I^* \models \text{max}_{\text{up}}$.
    
    \item \textbf{Downward disjunction $\text{min}_{\text{down}}$}: 
    Similarly, for $\mathcal{S}'^*$ we have:
    \begin{itemize}
        \item $\Phi_{\text{min}}(\mathcal{S}'^*)$ holds,
        \item $\Phi_{\text{prop-down}}(\mathcal{S}'^*)$ holds,
        \item For each $i$ and $t_g \in \args(F,f_i)$ with $t \in S_i'^*$:
        \[
        I^*(t_g) \geq b_{\min} + v_{\min}^i = b_{\min} + I^*(t)
        \]
        by construction of $b_{\min}$.
    \end{itemize}
    Thus $I^* \models \Psi_{\text{down}}(B,\mathcal{S}'^*)$, and consequently $I^* \models \text{min}_{\text{down}}$.
\end{enumerate}

Let $N = \max(|b_{\min}|, |b_{\max}|)$. Algorithm~\ref{alg:interval-check-param-withBigvee} expands the interval symmetrically from $[0,0]$. When it reaches iteration $n = N$, the interval becomes $[-N, N]$, which contains $B$.

At this iteration, the $\smt$ call on line 6 checks:
\[
F \land \bigwedge_{x=-N}^{N} Q[x] \land \text{max}_{\text{up}} \land \text{min}_{\text{down}}
\]
where $\text{max}_{\text{up}}$ and $\text{min}_{\text{down}}$ are constructed for the interval $[-N, N]$.

Since $[-N, N]$ contains $B$, and $I^*$ satisfies all three conditions as shown above, this formula is satisfiable (witnessed by $I^*$). Therefore, the algorithm returns \textsc{Sat}.
\end{proof}

\section{Experiments}

There are two basic reasons why verification conditions may fail to hold: (1) a bug, (2) underlying assertions not being inductive. In the first case, the counter-model will typically be finite, since program executions only modify finite memory. In the second case, the counter-model may be infinite. However, even in the first case our method may improve upon methods such as MBQI, due to two reasons:
        \begin{itemize}
        \item the models produced by MBQI are very difficult to read
        \item run-time of MBQI increases with the size of the model
        \end{itemize}

        For example, on my brand-new notebook, CVC5 with MBQI needs roughly 15sec to show the formula
        \[ f(0)=0 \wedge \forall x \;.\; x<0\vee x>1000\vee f(x+1)=f(x)+1 \]
        to be satisfiable, and then produces an unreadable model of size 25K. After changing the upper bound to 10000, CVC5 does not terminate in 10 minutes, so apparently, the growth is super-linear.


\section{Conclusion}

\bibliographystyle{abbrv}
\bibliography{refs}



\appendix

\section{Discussion on Completeness}\label{sec:completeness}
The completeness of algorithms that operate on integers in SMT is tricky because
integers themselves are not recursively axiomatizable.
% Hence, it is meaningful to discuss completeness with respect to some set
% of axioms.
Further, nonlinear integer arithmetic is undecidable already without
quantifiers. So for the following discussion we assume that ground problems are
always decided on line~\ref{ln:check} of \cref{alg:sr}.

% \cref{alg:sr} terminates if the given formula satisfies \req and is satisfiable in integers.
% Unsatisfible formulas are more nuanced. Consider the following formula,
% which requires $f$ to be bounded by 0 but to be strictly increasing.
% \begin{equation}\label{eq:completeness}
%     \forall{x}. \,f(x)<0 \,\land \,\forall{x}. \,f(x)<f(x+1)
% \end{equation}
% The formula is unsatisfiable as long as we have access to induction.%
% \footnote{%
% By induction show that $\forall n\in\mathbb{N}.\,f(n)\geq n+f(0)$.
% From~\eqref{eq:completeness}, $f(0)<0$, substituting $-f(0)$ for $n$ gives the
% contradiction $f(-f(0))\geq 0$.
% }
%%%%%%%%%%%
\cref{alg:sr} terminates if the given formula satisfies \req and is satisfiable in integers.
Unsatisfiable formulas are more nuanced. Consider the following formula,
which requires $f$ to be constantly $0$, yet different from $0$ at some point.
\begin{equation}\label{eq:completeness}
	f(0)=0\land f(c)\neq 0\land\forall x.\,f(x)=f(x+1)
\end{equation}
The formula is unsatisfiable as long as we have access to induction.%
\footnote{Apply induction in both directions to obtain $\forall n.\,f(n)=0$.}
%%%%%%%%%%%
Formula~\eqref{eq:completeness} satisfies \req but
\cref{alg:sr} does not terminate since the interval~$I$ will grow
indefinitely. This is due to the fact that instantiating~\eqref{eq:completeness}
finitely many times always yields a satisfiable ground formula by setting the
value of $c$ to an arbitrary large integer.
Further, the formula has a model, which does not admit induction.
Consider all polynomials on $\mathbb{Z}$, which gives the ring $\mathbb{Z}[X]$,
where two polynomials are ordered lexicographically---giving a total order.
Then, the function $f(p)$ can be defined as $0$ for all constant polynomials and
$1$ everywhere else and then set $c$ to  an arbitrary non-constant polynomial,
such as $x$.
% Further, the formula has a model, which does not admit induction.
% Consider all polynomials on $\mathbb{Z}$, which gives the ring $\mathbb{Z}[X]$,
% where two polynomials are ordered lexicographically---giving a total order.
% Then, the function $f(p)$ can be defined as $-x + \text{``constant term of }p\text{''}$.
% Such function is always below the $0$ polynomial, and it is increasing.

\cref{alg:sr} terminates if the given formula is unsatisfiable in
arithmetic without induction.\mj{We need to make more
	specific what this means. Is it clear that it hols?}

\todoSN{So I think we need to remove the above sentence because of the counter example $f(c)=f(c+1)\land\forall x.f(x)<f(x+1)$? If we need to say something about \textsc{Unsat} formulas, perhaps like this one below?}
~\cref{alg:sr} terminates with \textsc{Unsat} for formulas whose unsatisfiability can be detected through finite instantiation alone. Formally:
\begin{theorem}
    \label{thm:finiteunsatThenUNSAT}
    Let $\phi$ be a formula of the form described in \cref{thm:satisfiableThenSAT} that is unsatisfiable in the standard model of integer arithmetic. If there exists a finite set of instantiations $\{x = k_1, \dots, x = k_n\}$ such that $F\land\bigwedge_{i=1}^n Q[x\mapsto k_i]$ is unsatisfiable, then Algorithm~\ref{alg:sr} will terminate and return \textsc{Unsat}.
\end{theorem}
\begin{proof}
    If such a finite set exists, let $M = \max\{|k_1|, \dots, |k_n|\}$. Algorithm~\ref{alg:sr} expands the interval $I$ symmetrically from $[0,0]$ to $[-m,m]$ at each iteration. When $m\geq M$, the interval $[-m,m]$ contains all $k_i$, making the formula $F \land \bigwedge_{x=-m}^{m} Q$ unsatisfiable. At this iteration, the $\smt$ call on line~9 returns $\bot$, causing the algorithm to exit the while-loop and return \textsc{Unsat}.
\end{proof}

In general, \cref{alg:sr} is complete in the following senses:
\begin{itemize}
    \item For \textsc{Sat}: It terminates on all satisfiable formulas within the fragment that satisfy \req (\cref{thm:satisfiableThenSAT}).
    \item For \textsc{Unsat}: It terminates on formulas whose unsatisfiability is detectable through finite instantiation (\cref{thm:finiteunsatThenUNSAT}).
    \item For formulas whose unsatisfiability relies on instantiations at offsets not captured by the expanding interval $I$, the algorithm may not terminate. This includes both inductive cases like Formula \eqref{eq:completeness} and non‑inductive cases like $f(c)=f(c+1)\land\forall x.f(x)<f(x+1)$ whose unsatisfiability does not require induction over all integers.
    \end{itemize}

\section{Handling Disjunction Using Auxiliary Propositional Variables}

The algorithm presented so far relies on large disjunctions over all possible subset choices $\mathcal{S} = (S_1,\dots,S_r)$ and $\mathcal{S}' = (S'_1,\dots,S'_r)$. While theoretically elegant, these disjunctions lead to formulas with exponential size, making them computationally impractical. In this subsection, we present a compact CNF encoding that avoids this issue.

\paragraph{Encoding Idea.} Instead of enumerating all subset choices, we introduce auxiliary Boolean variables that represent membership in the subsets $S_i$ and $S'_i$. For each offset term $t_j^{f_i} \in T_i$, we create:
\begin{itemize}
    \item $s_{i,j}$: true iff $t_j^{f_i} \in S_i$ (for upward propagation)
    \item $s'_{i,j}$: true iff $t_j^{f_i} \in S'_i$ (for downward propagation)
\end{itemize}

We then encode the conditions $\Phi_{\text{max}}$, $\Phi_{\text{min}}$, $\Psi_\text{up}$, $\Psi_\text{down}$, and the clash conditions using these variables.

\begin{definition}[CNF Encoding of Interval Extension Formulas]
\label{def:interval-extension-formulas-CNF}
For an interval $B = [b_{\min}, b_{\max}]$, define the encoded formulas:
\begin{align*}
\Psi_{\text{up}}^\text{e}(B) &\equiv \Phi_\text{max}^\text{e} \land \Phi_\text{prop-up}^\text{e} \land \text{ClashUpEnc} \\
\Psi_{\text{down}}^\text{e}(B) &\equiv \Phi_\text{min}^\text{e} \land \Phi_\text{prop-down}^\text{e} \land \text{ClashDownEnc}
\end{align*}
where:
\begin{itemize}
    \item Maximality encoding:\todoSN{Or use its $\lor$-equivalent.}
    \begin{align*}
    \Phi_\text{max}^\text{e} \equiv \bigwedge_{i=1}^r \Big[& 
        \bigwedge_{j<k} \big(s_{i,j} \land s_{i,k} \Rightarrow (t_j^{f_i} = t_k^{f_i})\big) \ \land \\
        & \bigwedge_{j,k} \big(s_{i,j} \land \neg s_{i,k} \Rightarrow (t_j^{f_i} > t_k^{f_i})\big) \Big]
    \end{align*}
    
    \item Minimality encoding: $\Phi_\text{min}^\text{e}$ defined analogously with $s'_{i,j}$ and $<$ instead of $>$.
    
    \item Upward propagation encoding: Given Boolean variables $\{s_{i,j}\}$ representing the choice $\mathcal{S} = (S_1,\dots,S_r)$ where $S_i = \{t_j^{f_i} \mid s_{i,j} \text{ is true}\}$, we define:
    \begin{align*}
        \Phi_{\text{prop-up}}^\text{e}(\{s_{i,j}\}) &\equiv \forall x \forall \bar{u}_1 \dots \forall \bar{u}_r \exists v_1 \dots \exists v_r.\ Q' 
    \end{align*}
    where each $\bar{u}_i$, $i\in \{1,\dots,r\}$ stands for those variables $u_{i,j}$ for which $\neg s_{i,j}$, $j\in \{1,\dots, l_i\}$.
    The formula $Q'$ is obtained from $Q$ by simultaneously substituting:
    \begin{itemize}
        \item $f_i(x+t_j^{f_i})$ by $v_i$ whenever $s_{i,j}$ is true,
        \item $f_i(x+t_j^{f_i})$ by $u_{i,j}$ whenever $s_{i,j}$ is false.
    \end{itemize}

    \item Downward propagation encoding: Symmetrically, for downward propagation with variables $\{s'_{i,j}\}$ representing $\mathcal{S}'$, define $\Phi_{\text{prop-down}}^\text{e}(\{s'_{i,j}\})$.
    
    \item Clash condition encoding:
    \begin{align*}
    \text{ClashUpEnc} &\equiv \bigwedge_{i=1}^r \bigwedge_{t_g \in \args(F,f_i)} \bigwedge_{j=1}^{l_i}
           \big(s_{i,j} \Rightarrow (t_g \leq b_{\max} + t_j^{f_i})\big) \\
    \text{ClashDownEnc} &\equiv \bigwedge_{i=1}^r \bigwedge_{t_g \in \args(F,f_i)} \bigwedge_{j=1}^{l_i}
           \big(s'_{i,j} \Rightarrow (t_g \geq b_{\min} + t_j^{f_i})\big)
    \end{align*}
\end{itemize}
\end{definition}

Note that if for some $i\in \{1,\dots, r\}$ all offset terms of $f_i$ are pairwise different numerals, then at most one $s_{i,j}$ can be true in any satisfying assignment of $\Psi_{\text{up}}^\text{e}(B)$ or $\Psi_{\text{down}}^\text{e}(B)$. This is because the maximality condition $\bigwedge_{t,t' \in S_i} t = t'$ would require two different numerals to be equal, which is impossible. Similarly for minimality condition.

\begin{lemma}[Encoding Correctness]
\label{lem:encoding-correctness}
For any interval $B = [b_{\min}, b_{\max}]$:
\begin{enumerate}
    \item $\Psi_\text{up}^\text{e}(B)$ is satisfiable iff there exists $\mathcal{S} = (S_1,\dots,S_r)$ such that $\Psi_{\text{up}}(B,\mathcal{S})$ holds.
    \item $\Psi_\text{down}^\text{e}(B)$ is satisfiable iff there exists $\mathcal{S}' = (S'_1,\dots,S'_r)$ such that $\Psi_{\text{down}}(B,\mathcal{S}')$ holds.
\end{enumerate}
\end{lemma}
\begin{proof}
    ($\Rightarrow$) Suppose $\Psi_\text{up}^\text{e}(B)$ is satisfiable by an assignment $I$. Define $S_i = \{t_j^{f_i} \mid I(s_{i,j}) = \text{true}\}$. By $\Phi_{\text{max}}^\text{e}$, all $t \in S_i$ have equal values under $I$, and they are strictly greater than any $t' \in T_i \setminus S_i$. Thus $\Phi_{\text{max}}(\mathcal{S})$ holds. By $\Phi_{\text{prop-up}}^\text{e}$, all $f_i(x+t)$ with $t \in S_i$ are equal to $v_i$, satisfying the substitution in $\Phi_{\text{prop-up}}(\mathcal{S})$. Finally, $\text{ClashUpEnc}$ ensures the clash condition. Hence $\Psi_{\text{up}}(B,\mathcal{S})$ holds.

    ($\Leftarrow$) Suppose $\Psi_{\text{up}}(B,\mathcal{S})$ holds for some $\mathcal{S}$. Set $s_{i,j}$ true iff $t_j^{f_i} \in S_i$. By $\Phi_{\text{max}}(\mathcal{S})$, all selected terms are equal and greater than non-selected ones, so $\Phi_{\text{max}}^\text{e}$ holds. Let $v_i$ be the common value for $f_i(x+t)$ with $t \in S_i$ (guaranteed by $\Phi_{\text{prop-up}}(\mathcal{S})$), then $\Phi_{\text{prop-up}}^\text{e}$ holds. The clash condition from $\Psi_{\text{up}}(B,\mathcal{S})$ ensures $\text{ClashUpEnc}$. Thus $\Psi_\text{up}^\text{e}(B)$ is satisfiable.
    
    The proof for $\Psi_\text{down}^\text{e}(B)$ is symmetric.
\end{proof}

\paragraph{Practical Considerations.}
The exponential disjunctions in \cref{alg:interval-check-param-withBigvee} 
(lines 4--5) can be replaced by the CNF encodings $\Psi_\text{up}^\text{e}$ and $\Psi_\text{down}^\text{e}$ as defined above, which are equi-satisfiable by Lemma~\ref{lem:encoding-correctness}. This yields a practical implementation while preserving all theoretical guarantees. Thus, the CNF encoding approach provides a practical bridge between the theoretical multi‑\req framework and implementable algorithm, while avoiding exponential formula size.

\subsection{Handling Disjunction by Enumeration}

This would be as in \cref{alg:interval-check-param} or \cref{alg:two-phase-precompute}.

\begin{algorithm}
\caption{Interval‑Based Satisfiability Check (parameterised multi-\req)}
\label{alg:interval-check-param}
\begin{algorithmic}[1]
\Require $\phi = F \land \forall x.\, Q$ in the fragment
\Ensure \textsc{Sat} or \textsc{Unsat}
\State $\mathcal{C} \gets \{(\mathcal{S},\mathcal{S}') \mid Q \text{ satisfies multi-\req for } (\mathcal{S},\mathcal{S}')\}$
\For{each $(\mathcal{S},\mathcal{S}') \in \mathcal{C}$}
    \State $b_{\min} \gets 0$, $b_{\max} \gets 0$ 
    \State $I \gets \smt\!\left(F \land Q[0]\right)$
    \While{$I \neq \bot$}
        \State Construct $\Psi_{\text{up}}([b_{\min},b_{\max}],\mathcal{S})$ and $\Psi_{\text{down}}([b_{\min},b_{\max}],\mathcal{S}')$ \Comment{\cref{def:interval-extension-formulas-param}}
        \If{$\smt\left(F \land \bigwedge_{x=b_{\min}}^{b_{\max}} Q[x] \land \Psi_{\text{up}} \land \Psi_{\text{down}}\right) \neq \bot$}
            \State \Return \textsc{Sat} 
        \EndIf
        \State $b_{\min} \gets b_{\min} - 1$, $b_{\max} \gets b_{\max} + 1$ \Comment{Expand interval symmetrically}
        \State $I \gets \smt\left(F \land \bigwedge_{x=b_{\min}}^{b_{\max}} Q[x]\right)$
    \EndWhile
\EndFor
\State \Return \textsc{Unsat}
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{Two‑Phase Interval Check with Subset Pre‑computation}
\label{alg:two-phase-precompute}
\begin{algorithmic}[1]
\Require Formula $\phi = F \land \forall x . Q$
\Ensure \textsc{Sat} or \textsc{Unsat}

\State \textbf{Phase 1: Pre‑compute useful subset pairs}
\State $\mathcal{C} \gets \emptyset$ \Comment{Set of candidate $(\mathcal{S}, \mathcal{S}')$ pairs}
\For{each $(\mathcal{S}, \mathcal{S}')$}
    \If{$\Phi_{\text{prop-up}}(\mathcal{S}) \land \Phi_{\text{prop-down}}(\mathcal{S}')$ is valid}
        \State $\mathcal{C} \gets \mathcal{C} \cup \{(\mathcal{S}, \mathcal{S}')\}$
    \EndIf
\EndFor

\State \textbf{Phase 2: Interval expansion for each candidate}
\For{each $(\mathcal{S}, \mathcal{S}') \in \mathcal{C}$}
    \State $b_{\min} \gets 0$, $b_{\max} \gets 0$
    \State $I \gets \smt\!\left(F \land Q[0]\right)$
    \While{$I \neq \bot$}
        \State Construct $\Psi_{\text{up}}([b_{\min},b_{\max}],\mathcal{S})$ and $\Psi_{\text{down}}([b_{\min},b_{\max}],\mathcal{S'})$ \Comment{Definition~\ref{def:interval-extension-formulas-param}}
        
        \If{$\smt\!\left(F \land \bigwedge_{x=b_{\min}}^{b_{\max}} Q[x] \land \Psi_{\text{up}} \land \Psi_{\text{down}}\right) \neq \bot$}
            \State \Return \textsc{Sat}
        \EndIf
        
        \State $b_{\min} \gets b_{\min} - 1$, $b_{\max} \gets b_{\max} + 1$
        \State $I \gets \smt\!\left(F \land \bigwedge_{x=b_{\min}}^{b_{\max}} Q[x]\right)$
    \EndWhile
\EndFor
\State \Return \textsc{Unsat}
\end{algorithmic}
\end{algorithm}



\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
