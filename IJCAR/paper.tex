\documentclass{llncs}
\usepackage[textwidth=3cm,tickmarkheight=3pt]{todonotes}
\usepackage[utf8]{inputenc}
\usepackage{amssymb, amsmath}
\usepackage{numprint}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\usepackage{color}
\definecolor{citeblue}{rgb}{0.1,0,.4}
\usepackage[pdftex%
,colorlinks=true%
,bookmarks=true%
,linkcolor=citeblue%
,citecolor=citeblue%
,urlcolor=blue%
,plainpages=false]{hyperref}
\hypersetup{colorlinks,citecolor=blue,linkcolor=blue,urlcolor=blue}
\AtBeginDocument{\hypersetup{pdfborder={0 0 1}}}
\usepackage[nameinlink,capitalize,noabbrev]{cleveref} % must come after hyperref
\usepackage{commath}
\usepackage[most]{tcolorbox}
\usepackage{enumitem}
\usepackage{orcidlink}
\usepackage{graphicx}
\usepackage{caption, subcaption}
\newcommand{\sygus}{SyGuS\xspace}
\newcommand{\qedhere}{$\blacksquare$}
\newcommand{\numvar}[1]{|#1|}
\newcommand{\domain}{\mathbb{D}}
\newcommand{\cmpsign}[1]{\lesseqgtr^{#1}}
\newcommand{\cmpsignstrict}[1]{\lessgtr^{#1}}
\newcommand{\coeffsign}[1]{\sigma(#1)}
\newcommand{\ivbound}[2]{\text{sel}(#1,#2)}


\renewcommand{\algorithmicrequire}{\textbf{Input:}}
\renewcommand{\algorithmicensure}{\textbf{Output:}}

%\newtheorem{definition}{Definition}
%\newtheorem{property}{Property}
%\newtheorem{example}{Example}

%\newtheorem{theorem}{Theorem}
%\newtheorem{lemma}[theorem]{Lemma}
%\newtheorem{corollary}[theorem]{Corollary}
%\theoremstyle{remark}
%\newtheorem{claim}{Claim}
\usepackage{etoolbox}
%\AtEndEnvironment{proof}{\setcounter{claim}{0}}

\npthousandsep{,}
\newcommand{\gmodel}{\mathcal{M}}
\newcommand{\smt}{\textsc{smt}}
\newcommand{\args}{\text{args}}
\usepackage{xspace}
\newcommand{\req}{\emph{ReqPivot}\xspace}
\newcommand{\subst}[3]{#1[#2\leftarrow #3]}
\newcommand{\repr}[1]{\hat{#1}}

\newcommand{\todoSR}[1]{\todo[color=blue!40]{#1}}
\newcommand{\mj}[1]{\todo[color=green!30]{#1 -mik}}
\newcommand{\marek}[1]{\todo[color=red!10]{#1 -MD}}
\newcommand{\todoSN}[1]{\todo[color=orange!50]{#1 -SN}}

\title{Certifying Satisfiability of\\Universally Quantified Integer Arithmetic with\\Uninterpreted Function Symbols%
}

% === TITLE SUGGESTIONS ===
%
% Formal/Academic:
% - Satisfiability Certificates for Quantified Integer Formulas via Inductive Propagation
% - Beyond Finite Models: Inductive Proofs for UFLIA Satisfiability
% - Cell Propagation: A Decision Procedure for Offset-Restricted UFLIA
% - Inductive Witnesses for Quantified Satisfiability over Integers
% - From Finite Base to Infinite Model: Certifying UFLIA Satisfiability
%
% Shorter/Punchier:
% - Satisfying the Unsatisfiable: Inductive Methods for UFLIA
% - When Models Are Too Big: Inductive UFLIA Satisfiability
% - Propagating Satisfiability in Quantified Integer Formulas
%
% Playful:
% - No Model? No Problem! Inductive Certificates for UFLIA
% - The SAT Side of UFLIA: Finding Models Without Building Them
% - Infinite Models, Finite Proofs: Taming Quantified Integer Constraints
% - Teaching SMT Solvers to Say Yes
% - Cell by Cell: An Inductive Journey to Satisfiability
% - Why Build a Model When You Can Prove One Exists?
% - The Optimist's Guide to UFLIA: Proving Satisfiability by Induction
%
% Wordplay:
% - Induction to the Rescue: Satisfiability Without Enumeration
% - Propagate, Don't Enumerate: Deciding Quantified Integer Formulas
%
% === END TITLE SUGGESTIONS ===

% \author{Stefan Ratschan \and Anggha Nugraha \and Mikoláš Janota \and Marek Dančo}
\author{Stefan Ratschan\inst{1}\orcidlink{0000-0003-1710-1513} \and
Anggha Nugraha\inst{1,2}\orcidlink{0000-0002-7139-4487} \and
Mikoláš Janota\inst{3}\orcidlink{0000-0003-3487-784X} \and 
Marek Dančo\inst{3}\orcidlink{0009-0008-3031-113X}}
%
\authorrunning{S. Ratschan et al.}
% First names are abbreviated in the running head.
% If there are more than two authors, 'et al.' is used.
%
\institute{Institute of Computer Science, The Czech Academy of Sciences,
Prague, Czech Republic \\
\email{stefan.ratschan@cs.cas.cz} \and 
Faculty of Information Technology, Czech Technical University in Prague,
Prague, Czech Republic \and 
Czech Institute of Informatics, Robotics and Cybernetics, Czech Technical University in Prague, Czech Republic}

\begin{document}
\maketitle

\begin{abstract}
The combination of integer arithmetic, uninterpreted function symbols, and universal quantification occurs in many applications of automated reasoning, for example, due to its ability to reason about arrays. However, the satisfiability of such formulas is, in general, undecidable. In practice, SMT solvers are often successful in the unsatisfiable case, using heuristics. However, in the satisfiable case, they rely on  explicit model construction, which fails for formulas whose smallest model is not small enough. We introduce an alternative approach that certifies satisfiability using induction arguments, and provide an algorithm that is able to prove satisfiability of formulas that are out of reach of current SMT solvers. 

%\keywords{First keyword  \and Second keyword \and Another keyword.}
\end{abstract}


\section{Introduction}

Current SMT solvers have mainly been designed to prove unsatisfiability. As a consequence,  they have limited capabilities to detect satisfiability of formulas not belonging to known decidable classes. However, the ability to detect satisfiability is important for identifying counter-examples, which is indispensable in many applications~\cite{clarke25}.

In this paper, we address this problem for formulas containing universal quantifiers, linear integer arithmetic, and uninterpreted function symbols. Such formulas belong to the SMTLIB logic UFLIA, which is undecidable~\cite{Downey:72,Horbach:17}. However, such formulas occur in important applications, for example, in program verification, where uninterpreted function symbols play an important role in reasoning about arrays\cite{bradley-manna07}. Current SMT solvers mainly rely on heuristics~\cite{Reynolds:17}\todoSR{Mikoláš, do you want to add some of your work?} to prove unsatisfiability of such formulas. To prove satisfiability, they explicitly construct a model~\cite{ge-cav09,reynolds2013finite}. This fails for formulas as simple as $f(0)=0\wedge \forall x \;.\; f(x+1)=f(x)+1$, which do not have a finite model, and is costly for formulas whose smallest model is finite, but large.

In this paper, we explore an alternative approach that avoids explicit model construction by proving satisfiability using inductive arguments, instead. More specifically, we
\begin{itemize}
\item introduce a notion of satisfiability certificate that represents inductive arguments for satisfiability of such formulas,
\item present an algorithm that proves satisfiability by synthesizing such a satisfiability certificate for a sub-class of UFLIA formulas,
\item prove the algorithm's soundness and completeness under the assumption that the input formula satisfies a certain semantic condition enabling inductive reasoning,
\item provide an SMT encoding for formulas solved by this algorithm, and 
\item demonstrate through computational experiments that our approach can prove satisfiability of formulas beyond the reach for current SMT solvers.
\end{itemize}

% \paragraph{How We Solve It.} Our approach is based on \emph{inductive cell propagation}. We view each quantifier instantiation as imposing constraints on \emph{cells}—terms $f(n_1,\dots,n_k)$ with integer arguments. The key insight is that if we can: 1) Find a finite interval $[b_{\min}, b_{\max}]$ where all instantiations are simultaneously satisfiable, and 2) Ensure that from this base, solutions can be \emph{propagated} outward in both directions without conflicts, then the entire universally quantified formula is satisfiable. This reduces the infinite satisfiability problem to checking two finite conditions: base satisfiability and a propagation property formalized as the \emph{multi-ReqPivot condition}.

% The key idea is to treat each quantifier instantiation as introducing infinitely many constraints on function calls, which we refer to as cells. A single cell may appear in multiple constraints, so we must ensure that it is assigned a consistent value throughout. To show satisfiability within our fragment, we impose an order on these constraints and construct a symbolic assignment to the cells such that, when processed in this order, no conflicting assignments arise.

% \paragraph{Contributions.} 
% This paper makes several contributions towards deciding satisfiability in our fragment. We formalize \emph{cell propagation certificates} (\cref{def:certificate}) that witness satisfiability through inductive extension of finite base assignments.  We introduce the \emph{\req condition} (\cref{def:reqpivot-param}), propagation conditions that allows multiple functions to serve as pivots simultaneously. Building on this, we present an interval‑based algorithm (\cref{alg:interval-check-param-withBigvee}) that searches for suitable base intervals and checks propagation conditions using satisfiability queries. We prove \emph{soundness} (\cref{cor:soundness-bigvee}) and \emph{relative completeness} (\cref{thm:completeness-bigvee}) for our algorithm. Finally\todoSN{Hopefully!}, we provide experimental evidence that our method handles problems beyond the reach of current SyGuS and MBQI approaches, often producing more interpretable models.

% \section{Related Work}\label{}
% Synthesis of recursive functions by Hozzov\'a et al.~\cite{hozzova-ijcar24}.
% Synthesis of strategies on LIA problems Murphy and Kincaid~\cite{kincaid-cav24}.
% Synthesis, single invocation Kun\v cak et
% al.~\cite{kuncak-pldi10,kuncak-sttt13}.

% Array decision procedures~\cite{bradley-vmcai06}: no arithmetic on universally quantified variables allowed.
% Habermehl et al.~\cite{habermehl-etaps08} allow difference bounded constraints on array offsets of the form $a[i+c]$. From the MBQI paper: ``For certain cases containing offsets on array indices, our procedure will result in an infinite set of instantiations, while a decision procedure of LIA\footnote{LIA does not refer to linear integer arithmetic, but to the logic allowed by Habermehl et al.}  will terminate. It leaves an open question for future research on how to reason about this type of formulas within an instantiation-based approach.''

% Alberti et al.~\cite{alberti2014decision}: only one universally quantified variable allowed.
% Elad et al.~\cite{elad2024infinite}: The fragment of FOL for which they prove decidability (OSC, Section~6) does not allow anything like integer arithmetic.

% \cite{reynolds2016model}: needs to user to ensure admissibility (Definition~2), the underlying finite model finding algorithm~\cite{reynolds2013finite} may introduce many case splits (``merge lemmas'') for satisfying cardinality constraints. \todoSR{I added a few words here}

% computer algebra algorithms for solving difference equations

% \subsection{What Can't the Previous Work Solve?}

% Here, I am considering the works~\cite{bradley-vmcai06,ge-cav09,habermehl-etaps08}.

% \paragraph{Infinitely Increasing But Bounded Integer Sequence}

% \[
% 	\forall{x}. \,f(x)<0 \,\land \,\forall{x}. \,f(x)<f(x+1)
% \]

% The syntax in~\cite{habermehl-etaps08} includes $\leq$ but does not include $<$. It does include negation though, but only if it
% results in the quantified variables being existential. This cannot be solved by~\cite{bradley-vmcai06} (see Theorem 4 in their paper).
% \textsc{Z3} cannot solve this on its own but with the addition of Lemma~\ref{eq:ind-needed-lemma} it can. Adding the lemma also helps Vampire but not \textsc{cvc5}.

% \paragraph{Two-Valued Constant Function}

% \[
% 	f(0) = 0 \,\land \,f(c) = 3 \,\land \,\forall{x}. \,f(x+1) = f(x)
% \]

% In the last meeting I hand-wavedly assumed this cannot be in the fragment of~\cite{habermehl-etaps08}.
% However, it is. They accept the literals $f(x) - f(x+1) \leq 0$ and $f(x+1) - f(x) \leq 0$, which in conjunction simplify
% to $f(x) = f(x+1)$. They can then universally quantify this to form an array property. The other equalities can
% be formed as value expressions $A \leq B \,\land \,B \leq A$. I can look more thoroughly at the paper
% to see how can they solve this.
% This cannot be solved by~\cite{bradley-vmcai06}, because the
% third conjunct contains $x+1$ as an argument of $f$ (Theorem 4 in their paper).
% \textsc{Z3} cannot solve this -- Compactness section in~\cite{ge-cav09}.

\section{Related Work}\todoSR{potentially relevant PC members: Reynolds, Barrett, Tinelli, Weidenbach, anybody else?}

Our work intersects several areas of automated reasoning: synthesis, decision procedures for arrays, and model-based quantifier instantiation.

\paragraph{Recursion.}
\cite{Farzan2021}
\cite{Kneuss2013}

\paragraph{Synthesis approaches.}
Syntax-Guided Synthesis (SyGuS)~\cite{cvc5} enumerates candidate functions from a grammar. Hence its performance depends crucially on the chosen grammar. Moreover, it synthesizes functions in an explicit representation, disallowing recursion\todoSR{right?}. Our method does beyond that, using inductive reasoning.
Kunčak et al.~\cite{kuncak-pldi10,kuncak-sttt13} introduces single-invocation synthesis. Hozzová et al.~\cite{hozzova-ijcar24} synthesize recursive programs from constraints.\todoSR{Do we want to keep these references? If yes, we need a better description. Do we want to add our CADE paper as a template based approach?}





% While powerful for template-matching problems, it fails on formulas requiring non-template solutions like periodic functions (Equation~\ref{eq:periodic}). 

% produce counterexamples for complex systems. Yet, counterexamples are important during modeling as they uncover  errors. For example, a user may wrongly assume that an input stream with increasing values will contain two equal consecutive values. Negating and skolemizing this assumption yields the simple UFLIA formula:
% \begin{equation}
% 	f(0)\neq f(1)\land\forall x:\mathbb{Z}.\,f(x)<f(x+1)
% \end{equation}

% While this formula has trivial counter-models (e.g. $f$ being the identity function), and such solutions can be found by synthesis approaches like \sygus, it is easy to get out of the reach of these tools because they are primarily based on templates and candidate-solution enumeration. The following modification is no longer solved by cvc5~\cite{cvc5} in its \sygus mode.

% \begin{equation}\label{eq:periodic}
% 	f(0)\neq f(1)\land\forall x:\mathbb{Z}.\,f(x)=f(x+2)
% \end{equation}

% These constraints allow only periodic functions whose neighboring values alternate. For such functions the \sygus grammar would have to guess an \textit{ite} term of the form $\mathit{ite}(x\,\mathit{mod}\,2 = 0\enspace a\enspace b)$, for integers $a \not = b$.
%Even if \sygus tools were improved, they could not yield a decision procedure for full UFLIA due to the inherent undecidability of integer arithmetic combines with uninterpreted functions. 


\paragraph{Decision procedures for arrays and quantified formulas.}
Bradley et al.~\cite{bradley-vmcai06} present a decision procedure for array properties but explicitly forbid arithmetic on the universally quantified variables. Habermehl et al.~\cite{habermehl-etaps08} allow constraints of the form $a[i+c]$ with difference bounds, but remain limited to offset-bounded indices. Alberti et al.~\cite{alberti2014decision} are restricted to flat formulas with one universally quantified variable. This excludes terms such as $a[i+1]$ that are the main focus of our paper. Elad et al.~\cite{elad2024infinite} prove decidability for a first‑order fragment without arithmetic, unable to express our constraints.

\paragraph{Model-based and instantiation methods.}
Reynolds et al.~\cite{reynolds2016model,reynolds2013finite} develop finite model finding techniques for quantified formulas. Their method requires users to ensure admissibility and may introduce many case splits (``merge lemmas'') to satisfy cardinality constraints. Ge and de Moura~\cite{ge-cav09} introduce the Model-Based Quantifier Instantiation (MBQI) but noting that ``For certain cases containing offsets on array indices, our procedure will result in an infinite set of instantiations, while a decision procedure of LIA\footnote{LIA refers to the logic of Habermehl et al.} will terminate. It leaves an open question for future research on how to reason about this type of formulas within an instantiation-based approach.'' Our work attempts to  address this open question.

\paragraph{Proof certificates and model representation.} move \cite{elad2024infinite} here? \cite{Ratschan:23} \cite{Barbosa:23}


\paragraph{Limitations illustrated.}\todoSN{In the previous version, there is a sentence: ``Here, I am considering the works~\cite{bradley-vmcai06,ge-cav09,habermehl-etaps08}." }
To see where existing methods fall short, consider:
\begin{itemize}
    \item \textbf{Infinitely increasing bounded sequence:} $\forall x.\, f(x) < 0 \land \forall x.\, f(x) < f(x+1)$. 
    Habermehl et al.'s fragment excludes strict inequalities. It does include negation, but only if it results in the quantified variables being existential. Bradley et al. forbid $x+1$ as an argument (Theorem 4 in~\cite{bradley-vmcai06}). \textsc{Z3} cannot solve this on its own\todoSN{In the previous version, there is ``but with the addition of Lemma~\ref{eq:ind-needed-lemma} it can. Adding the lemma also helps Vampire but not \textsc{cvc5}."}. 
    \item \textbf{Two‑valued constant function:} $f(0) = 0 \land f(c) = 3 \land \forall x.\, f(x+1) = f(x)$.
 In the last meeting I hand-wavedly assumed this cannot be in the fragment of~\cite{habermehl-etaps08}. However, it is. They accept the literals $f(x) - f(x+1) \leq 0$ and $f(x+1) - f(x) \leq 0$, which in conjunction simplify to $f(x) = f(x+1)$. They can then universally quantify this to form an array property. The other equalities can be formed as value expressions $A \leq B \,\land \,B \leq A$. I can look more thoroughly at the paper to see how can they solve this. This cannot be solved by~\cite{bradley-vmcai06}, because the third conjunct contains $x+1$ as an argument of $f$ (Theorem 4 in their paper).
\textsc{Z3} cannot solve this -- Compactness section in~\cite{ge-cav09}.
\end{itemize}

These examples demonstrate the need for a method that handles arithmetic offsets while providing finite certificates for satisfiability.

\section{Problem Statement}
\label{sec:problem-statement}

%\paragraph{Formula Class}
We introduce a method for certifying satisfiability of formulas of the form
\begin{equation}\label{eq:main-fragment}
    F \land \forall \bar{x}.\; Q%\bigl(f_1(x+t^{f_1}_1),\dots,f_1(x+t^{f_1}_{l_1}),\;\dots,\;f_r(x+t^{f_r}_1),\dots,f_r(x+t^{f_r}_{l_r})\bigr),
\end{equation}
where $F$  and $Q$ are quantifier‑free formulas in the SMTLIB theory UFLIA of uninterpreted function symbols and linear integer arithmetic, where $\forall \bar{x}$ stands for universal quantification of arbitrarily many variables, and where the arguments of all uninterpreted function symbols do not contain any uninterpreted function symbols with non-zero arity (i.e., the arguments may only contain uninterpreted constants).  Based on this method, we will design an algorithm for detecting satisfiability under the following additional assumptions:
\begin{itemize}
%    \item $f_1,\dots,f_r$ are distinct uninterpreted function symbols,
%    \item for each $f_i$, the \emph{offset terms} $t^{f_i}_1,\dots,t^{f_i}_{l_i}$ are pairwise distinct LIA ground terms, and
    \item All uninterpreted function symbols have maximal arity $1$.  
    \item The number of quantified variables is $1$.
    \item The coefficient of the quantified variable is the same for all argument terms of the same uninterpreted function symbol in the quantified part~$Q$.\todoSR{I removed the restriction on the sign of the coefficient}
    \end{itemize}
The algorithm is guaranteed to terminate under an additional semantic condition enabling induction (\cref{def:reqpivot-param}).

We illustrate the class of formulas our algorithm can handle using two examples. 
\begin{example}
  \label{ex:formula}
  \[f(0)=0 \wedge \forall x \,.\, f(-2x+3)=g(x)+f(-2x+c+1)-c,\]
  where $c$ is an uninterpreted constant, and the coefficient of the quantified variable~$x$ is $-2$ for all arguments of $f$, and $1$ for all arguments of $g$.
\end{example}

\begin{example}[Invalid]
  \[\forall x \,.\, f(2x+3) = f(x+1)\]
  This formula is \emph{not} in our fragment because $f$ appears with arguments having different coefficients ($2$ and $1$).
\end{example}

Note that certain formulas with several quantified variables can be easily transformed to this class by a change of variables. For example, the formula
\[f(0)=0 \wedge \forall y,z \,.\, f(2y-2z+3)=g(y-z)+f(2y-2z+c+1)-c,\]
can be reduced to Example~\ref{ex:formula} by the change of variables $x=y-z$.

We are not aware of any result showing the decidability of this class. However, we are also not aware of any result proving it to be undecidable. Indeed, our goal is not decidability classification, but an algorithm for showing satisfiability that allows straightforward implementation in SMT solvers, and that is efficient in practice.



% \paragraph{Core Problem}
% Given a formula $\phi$ of the form~\eqref{eq:main-fragment}, the problem we address is:
% \begin{quote}
%     \emph{Decide whether $\phi$ is satisfiable over the standard integers, and if so, construct a model (an interpretation of all uninterpreted function symbols) that satisfies $\phi$.}
% \end{quote}

% \paragraph{Why is this Hard?}\todoSN{Not sure about this part! I'm just trying to summarize it from what's written in the Intro and Related Work sections.}
% Although UFLIA is undecidable in general, formulas of the above form constitute a fragment that appears frequently in verification conditions (e.g.\ for programs with arrays or recursive functions). Yet, existing SMT techniques struggle:
% \begin{itemize}
%     \item \textbf{Finite instantiation} may not terminate because the universal quantifier ranges over the infinite domain $\mathbb{Z}$.
%     \item \textbf{Synthesis-based approaches} (SyGuS) rely on syntactic templates and fail when the required function does not match the template.
%     \item \textbf{Model-based quantifier instantiation} (MBQI) can sometimes find models but often produces large, uninterpretable assignments and scales poorly.
%     \item \textbf{Specialized array decision procedures} either forbid arithmetic on indices or are limited to difference‑bounded constraints.
% \end{itemize}
% The presence of both arithmetic constraints and uninterpreted functions, combined with the universal quantifier, makes this fragment challenging for current solvers.

% \paragraph{Scope and Limitations}
% We make the following additional assumptions about the structure of the formulas:
% \begin{enumerate}
%     \item Each uninterpreted function symbol appears with only finitely many distinct argument terms in $Q$.
%     \item We do not allow nested applications of uninterpreted functions (e.g., $f(g(x))$ is excluded).
%     \item We do not consider multiple universal quantifiers over different variables or existential quantification over functions.
% \end{enumerate}
% These restrictions enable the inductive propagation reasoning that underlies our solution, while still covering many practical verification conditions. The technical details of our solution—how we detect satisfiability, what propagation conditions we require, and how we construct models—are presented in the following sections.

% \paragraph{Expected Outcomes}
% For formulas within this fragment, we aim to provide:
% \begin{itemize}
%     \item A \emph{sound} decision procedure: if the procedure returns \textsc{Sat}, the formula is indeed satisfiable.
%     \item A \emph{relatively complete} procedure: for a large subclass (characterized by a propagation condition), the procedure will terminate and return the correct answer.
%     \item Constructive models: when the formula is satisfiable, the procedure should produce an explicit interpretation of the uninterpreted functions.
% \end{itemize}


    
% \paragraph{Core Problem}
% Given a formula $\phi$ of the form~\eqref{eq:main-fragment}, we want to decide its satisfiability over the standard integers. Because the quantifier ranges over the infinite set $\mathbb{Z}$, a na\"ive instantiation‑based approach may not terminate. Instead, we aim to reduce the problem into checking two conditions on a finite interval $B = [b_{\min}, b_{\max}]$:

% \begin{enumerate}
%     \item \textbf{Base satisfiability:} $F \land \bigwedge_{z \in B} Q[z]$ is satisfiable (where $Q[z]$ denotes $Q$ with $x$ replaced by the numeral $z$).
%     \item \textbf{Propagation:} From a model of the base interval, we can extend the assignment to all integers $z \notin B$ without creating any conflicts. This requires that for each function $f_i$, certain occurrences in $Q$ can be treated as ``pivots'' whose values can be chosen after fixing all other occurrences.
% \end{enumerate}

% The second condition is formalized as the \emph{\req condition} in \cref{sec:alg}. Intuitively, it ensures that when moving outward from $B$ (to larger or smaller integers), we always have at least one cell in each instantiation whose value can be adjusted to satisfy $Q$, given the values already assigned to cells that appear in earlier instantiations.

% \paragraph{Challenges}\todoSN{Stefan R, could you please check whether I formulate this paragraph (and the next one) correctly?}
% \begin{itemize}
%     \item \textbf{Detecting propagability:} How can we automatically check whether a formula $Q$ satisfies the required pivot condition?
%     \item \textbf{Finding a suitable base interval:} The interval $B$ must be large enough to avoid clashes between cells generated during propagation and cells that appear in the ground part $F$.
%     \item \textbf{Completeness:} Under what conditions does the existence of a finite base interval together with propagation guarantees imply satisfiability? Conversely, when can unsatisfiability be detected finitely?
% \end{itemize}

% \paragraph{Our Contributions}
% We address these challenges through the following steps:
% \begin{enumerate}
%     \item We introduce \emph{cell propagation certificates} (Definition~\ref{def:certificate}) as a formal witness for satisfiability in our fragment.
%     \item We define the \emph{\req condition} (Definition~\ref{def:reqpivot-param}) that characterizes when propagation is possible.
%     \item We prove that if a formula satisfies the \req condition and a suitable base interval exists, then the formula is satisfiable (Theorem~\ref{thm:interval-certificate-param}).
%     \item We present an algorithm (Algorithm~\ref{alg:interval-check-param-withBigvee}) that enumerates candidate intervals and checks both base satisfiability and propagation conditions using an $\smt$ solver.
%     \item We establish soundness and relative completeness theorems for our algorithm (Corollary~\ref{cor:soundness-bigvee} and Theorem~\ref{thm:completeness-bigvee}).
% \end{enumerate}


\section{Notation and Terminology}

As usual in an SMT context, we will work with a first-order language that is sorted. We also assume variables to only occur in positions where they are bounded by a quantifier. We already used the notation $\forall \bar{x}$ as an abbreviation for universal quantification over several variables. In this case, we will write $\numvar{x}$ for the number of those variables. For a formula $F$ and uninterpreted function symbol $f$, $args(F, f)$ will denote the set of argument terms of $f$ in $F$. We will write $\subst{s}{v}{t}$ for the result of substituting the term $t$ for $v$ in the term or formula~$s$. Here, $v$ may again represent several variables, in which case we require $t$ to represent a $\numvar{v}$-vector of terms, and assume substitution to be parallel. For an integer $z\in\mathbb{Z}$, we will denote the constant representing $z$ in a logical formula by $\repr{z}$.

We will sometimes work with the signs from the set $\{+,-\}$, where
for any two signs $s$ and $s'$, $ss'$ is $+$ iff $s=s'$, and $-$, otherwise. We will use such signs to switch between greater and less than relations in the way that for two integers~$z$ and $z'$, $z\cmpsignstrict{+} z'$ iff $z<z'$ and $z\cmpsignstrict{-} z'$ iff $z>z'$. For an interval $B=[b_{\min}, b_{\max}]$, we define $\ivbound{B}{-}= b_{\min}$, and $\ivbound{B}{+}= b_{\max}$.

We will use the classical mathematical notion of a well-order. A well-order on a set $S$ is a total ordering on $S$ such that every non-empty subset of $S$ has a least element. Any well-order allows well-founded induction: For a  proving that a property $P$ holds for all $x$, it suffices to prove that for every $x\in S$, if for all $y\prec x$, $P(y)$ then also $P(x)$.


We use the notion of certificate in the following sense~\cite{McConnell:11}: Given a property~$P(x)$ that is typically difficult to check, a certificate for this property is an object $\Pi$ for which we have a property $P'(x,\Pi)$ and a proof that $P'(x,\Pi)$ implies $P(x)$, and for which $P'(x,\Pi)$ is easier to check than $P(x)$. Here, we will not always insist on a precise meaning of the notion of being easy to check. However, the final goal is a certificate $\Pi$, for which $P'(x,\Pi)$ can be checked more efficiently than the original property $P(x)$, using an algorithm that is in some sense simpler then an algorithm for checking $P(x)$. As a consequence, such a certificate will enable an efficient independent check of the correctness of the result of an algorithm for checking~$P(x)$.

\section{Satisfiability Certificates}
\label{sec:certificate}\todoSR{The domain is now defined using a macro. It can be changed back to $\mathbb{Z}$ at any time.}

In this section, we will define objects that certifies that a formula in the form defined in~\cref{sec:problem-statement} is satisfiable. In the next section, we will then introduce an algorithm to compute such certificates.

Traditionally, satisfiability of a logical formula is certified by an interpretation that assigns a value to each non-logical symbol in such way that the formula is true. However, the set of integers is infinite. Due to this,  the interpretation of an uninterpreted function symbol with integer domain is a function that assigns values to the infinitely many integers that form this domain. This opens the question of how to represent such a function using a finite object that can be represented on computers.

Our approach will not assign values to the whole infinite domain of uninterpreted function symbols in one step, but to each individual element of this domain:
\begin{definition}[Cell]\label{def:cell}
	A \emph{cell} is a term of the form $f(n_1,\dots, n_k)$ where $f$ is an uninterpreted function symbol and $n_1,\dots, n_k$ are integers.
\end{definition}
Examples of cells are $c$, and $f(7)$. The term $f(c+7)$ is not a cell.

\begin{definition}[Cell Interpretation]
	A \emph{cell interpretation} is a partial function whose domain is the set of cells. A cell interpretation $I$ is \emph{compatible} with an interpretation $\mathcal{I}$ iff $I$ and $\mathcal{I}$ agree on all cells where $I$ is defined.
\end{definition}

Given a cell interpretation $I$, we denote by $\mathit{def}(I)$ the set of cells for which $I$ is defined. Given a term $t$ and a cell interpretation $I$  we define $I(t):=\mathcal{I}(t)$, if  $\mathcal{I}(t)$ is unique for every interpretation $\mathcal{I}$ compatible with $I$, and otherwise $I(t):=\bot$.
For example, for $I=\{ f(0) \mapsto 7 \}$, $I(f(0))=7$, but $I(f(1))=\bot$. Also note that $I(f(1)-f(1))=0\neq\bot$. In a similar way, for a formula $\phi$, we define that a cell interpretation~$I$ satisfies $\phi$ iff for every interpretation $\mathcal{I}$ compatible with $I$, $\mathcal{I}$ satisfies $\phi$, in which case we also write $I\models \phi$.

In order to allow a computer representation of cell interpretations, we will always work with cell interpretations that are only defined on finitely many cells. However, we will want that at least those cells are defined, that allow us to check satisfaction of parts of formulas without quantifiers, and that for all universally quantified parts and instantiations of the universal quantifier, allow us to determine the value of all arguments of uninterpreted function symbols.

\begin{definition}
	\label{def:pre-sat-cert}
	Given a formula $\phi$ of the form $F\wedge \forall \bar{x}\;.\; Q$, we call a cell interpretation $I$ such that
	\begin{itemize}
		\item $I\models F$, and
		\item for all $z\in\domain^{\numvar{\bar{x}}}$, for every uninterpreted function symbol~$f$ and its argument terms $t\in args(Q, f)$, $I(\subst{t}{\bar{x}}{\repr{z}})\neq\bot$
	\end{itemize}
	a \emph{pre-satisfiability certificate} of $\phi$. For any $z\in\domain^{\numvar{\bar{x}}}$, we denote by $\Gamma_{I,z}(\phi)$
	the resulting set of cells \[\{ f(I(\subst{t}{\bar{x}}{\repr{z}})) \mid t\in args(Q, f), f \emph{ is an uninterpreted function symbol}\}.\]
\end{definition}
For example, $I=\{ c\mapsto 5 \}$ is a pre-satisfiability certificate of $c\geq 5 \wedge \forall x \;.\; f(x+c+1)= f(x+c)+1$, and $\Gamma_{I,10}(\phi)=\{ f(15), f(16)\}$.

Given a pre-satisfiability certificate, we can now certify the advisability of formulas by propagating the values given by a pre-satisfiablity certificate in such a way that for each value of the universally quantified variables, the corresponding quantified sub-formula holds.
\begin{definition}
	\label{def:certificate}
	Given a formula $\phi$  of the form $F\wedge \forall \bar{x}\;.\; Q$, a \emph{satisfiability certificate for $\phi$} is
	\begin{itemize}
        \item a pre-satisfiability certificate $I$ of $\phi$,
		\item a well-order $\preceq$ on $\domain^{\numvar{\bar{x}}}$,%\footnote{A well-order total order for which every non-empty subset has a least element. This enables induction. If we want to allow sub-formulas to be at the same place in the order, we either need to combine them into equivalence classes, or relax anti-symmetry (i.e., work with a pre-wellorder).}
		\item for every $z\in\domain^{\numvar{\bar{x}}}$
                  \begin{itemize}
                  \item a set $X_z\subseteq \Gamma_{I,z}(\phi)$  (the \emph{propagated cells}) such that \[X_z\cap \mathit{def}(I)=\emptyset \text{ and } X_z\cap\bigcup_{z'\prec z} \Gamma_{I,z'}(\phi)=\emptyset,\] and
                    %that are neither assigned a value by $I$, nor occur in any $\Gamma_{I,z'}(\phi)$ for any $z'\prec z$
                  \item a certificate (the \emph{satisfiability propagator}) showing that for all values of cells in $\Gamma_{I,z}(\phi)\setminus \mathit{def}(I)\setminus X_z$ there exist values for the cells in $X_z$ such that for the cell interpretation $I_{X_z}$ assigning these values to $X_z$, $I\cup I_{X_z}\models \subst{Q}{\bar{x}}{\repr{z}}$.
                  \end{itemize}

	\end{itemize}
\end{definition}

\begin{example}\label{ex:certificate-example}
A satisfiability certificate for the formula \[f(3, a) \geq 4 + g(b) \wedge \forall x, y . f(x, y) < x + g(y) \wedge g(y) = g(y+b) + 2b\] is 
% \begin{itemize}
%     \item pre-satisfiability certificate $I = \{ a \mapsto 0, b \mapsto 1, f(3,0) \mapsto 4, g(1) \mapsto 0 \}$
%     \item order $\preceq$: $(3,0) \prec (3,1) \prec (3,2) \prec \cdots \prec (3,-1) \prec \cdots \prec \text{others}$
%     $\Gamma_{I,(x,y)} = 
%     \begin{cases}
%         \{g(0)\} & x=3,y=0,\\
%         \{f(x,1), g(2)\} & x=3, y=1,\\
%         \{f(x,y), g(y), g(y+1)\} & x\neq 3 \text{ or } y\neq 0,1.
%     \end{cases}$   
%     \item propagated cells $X_{(x,y)} = 
%         \begin{cases}
%           \{g(0)\} & y=0,\\
%           \{f(3,y), g(y+1)\} & x=3,y>0,\\
%           \{f(3,y), g(y)\} & x=3, y<0,\\
%           \{f(x,y) \} & x\neq 3.\\
%         \end{cases}$
%     \item propagators: $g(0)\mapsto5$; for $y>0$: $f(3,y)=y+g(y)-1$, $g(y+1)=g(y)-2$.
%     \end{itemize}
given by the pre-satisfiability certificate $I = \{ a \mapsto 0, b \mapsto 1, f(3,0) \mapsto 4, g(1) \mapsto 0 \}$ and the following table, where the first column indicates the order~$\preceq$:
    \[\small
    \begin{array}{|l|l|l|l|}\hline
      & X_{(x,y)} & propagators\\ \hline
        x=3, y=0  & \{g(0)\} & g(0)\mapsto 5\\
        x=3,y=1,2,\dots & \{f(3,y), g(y+1)\} & g(y+1)\mapsto g(y)-2, f(x,y)\mapsto y+g(y)-1\\
        x=3, y=-1,-2,\dots &  \{f(3,y), g(y)\} & g(y)\mapsto g(y+1)+2, f(x,y)\mapsto y+g(y+1)+1 \\
       x\neq 3, y \text{ arbitrary}  &   \{f(x,y) \} & f(x,y)\mapsto y+g(y)-1\\ \hline
    \end{array}
  \]
\end{example}

The notion of certificate defined here is abstract in the sense that it does not fix a concrete finite representation that allows for an independent check whether a given object is indeed a satisfiability certificate. For arriving at concrete independently checkable certificates, it suffices to fix a well-order and decide on a representation of propagated cells and satisfiability propagator that allows for such an independent check. For example, all these definitions could be written in the language of Presburger arithmetic, which allows the independent check to be done using a decision procedure for Presburger arithmetic. We will illustrate this in the next section for the special class of formulas described in \cref{sec:problem-statement}.

% For the sake of generality, the satisfiability propagator only shows existence of values for the propagated cells. At this point we do not require it to be constructive. Still, below we will work with algorithms computing actual values. In addition, the definition allows infinitely many different sets of propagated cells and satisfiability propagators. In practice, for allowing computer representation, we will only work with finitely many different ones.

Also note that for $z\in\domain^{\numvar{\bar{x}}}$ such that $\Gamma_{I,z}(\phi)\subseteq \mathit{def}(I)$, the definition requires the set of propagated cells $X_z$ to be empty. As a consequence, for such $z$, the satisfiability propagator only needs to certify that $I\models \subst{Q}{\bar{x}}{\repr{z}}$. In other words, the cell interpretation~$I$ serving as a pre-satisfiability certificate already plays the role of the satisfiability propagator. 

\begin{property}\label{prop:certThenSat}
	Every formula $\phi$  of the form $F\wedge \forall x\;.\; Q$ that has a satisfiability certificate is satisfiable.
\end{property}

\begin{proof}
	Assume a formula of the given form and assume that it  has a satisfiability certificate.
	The corresponding pre-satisfiability certificate $I$ satisfies the quantifier free part~$F$ of $\phi$.
    
    We start by showing that for every $z\in\domain^{\numvar{\bar{x}}}$ there is an extension $I'$ of $I$ such that $I'$ satisfies all quantifier instantiations occurring before $z$ wrt.\ the order $\preceq$, that is,  $I'\models\{ \subst{Q}{\bar{x}}{\repr{z}'} \mid z'\preceq z\}$. For this we use the principle of induction on well-orders: Let $z\in\domain^{\numvar{\bar{x}}}$, and let $\Phi$ be $\{ \subst{Q}{\bar{x}}{\repr{z}'} \mid z'\prec z\}$. We assume that there is an extension $I_{\Phi}$ of $I$ with $I_{\Phi}\models\Phi$ and prove that there is an extension $I'$ of $I$ with $I'\models\Phi\cup \{ \subst{Q}{\bar{x}}{\repr{z}}\}$. Since the formula has a satisfiability certificate, the propagated cells of $\subst{Q}{\bar{x}}{\repr{z}}$ do not occur in any element of $\Phi$. Let $I'$ be the extension of $I_{\Phi}$ that assigns to the propagated cells $X_z$ the values whose existence is  confirmed by the satisfiability propagator. Since these do not occur in $\Phi$, $I'$ and $I_{\Phi}$ coincide on cells occurring in $\Phi$. Hence $I'$ satisfies both $\Phi$ and $\subst{Q}{\bar{x}}{\repr{z}}$, and so it satisfies $\Phi\cup \{ \subst{Q}{\bar{x}}{\repr{z}}\}$.

	Now denote for every $z\in\domain^{\numvar{\bar{x}}}$ the cell interpretation  satisfying $\subst{Q}{\bar{x}}{\repr{z}}$ as constructed in the previous paragraph by $I_z$.
	% From the well-order $\prec$ we get a corresponding well-order on these cell interpretations.
	% Let $I_{\phi}$ be the cell interpretation that, for any cell $u$, assigns the value to $u$ that $I_{z}$ assigns to it for the smallest $z$ (wrt. $\prec$) that assigns a value to $u$. This smallest $z$ exists, since $\prec$ is a well-order. The cell interpretation $I_{\phi}$ satisfies $\phi$, and any classical interpretation compatible with the values assigned by $I_{\phi}$ satisfies $\phi$, as well.
    Observe that for every cell~$u$, and for all~$z, z'\in \domain^{\numvar{\bar{x}}}$ with $I_z(u)\neq \bot$ and $I_{z'}(u)\neq \bot$, $I_z(u)=I_{z'}(u)$.      Let $I_\phi$ be the assignment that, for any cell $u$, if there is a $z$ such that $I_z(u)\neq \bot$, then $I_\phi(u)=I_z(u)$, and otherwise $I_\phi(u)=0$. Certainly $I_\phi\models F$. Moreover, for every $z\in\domain$,  $I_\phi\models  \subst{Q}{\bar{x}}{\repr{z}}$, since $I_\phi$ coincides with $I_z$ for all elements, where it is defined. Hence  $I_\phi\models \phi$.
\qedhere\end{proof}

A satisfiability certificate only shows that a formula is satisfiable. It does not provide concrete values of the corresponding model. We now show how to compute such values from a given satisfiability certificate containing a pre-satisfiability certificate $I$. For this, we require the satisfiability propagators to be constructive. So, for $z\in\domain^{|x|}$ and for each $u\in X_z$ we assume a function $prop_{u,z}$ such that for
a cell interpretation $I'$ with $\mathit{def}(I')=\Gamma_{I,z}(\phi)\setminus \mathit{def}(I)\setminus X_z$, $I\cup I'\cup \{ u \mapsto prop_{u,z}(I\cup I') \mid u\in{X_z}\}\models\subst{Q}{\bar{x}}{\repr{z}}$.
 
% for any $\hat{v}_1,\dots,\hat{v}_r$, the cell interpretation
% \[\{ v_1\mapsto \hat{v}_1,\dots,v_r\mapsto \hat{v}_1, u_1\mapsto  prop_{u_1}(\hat{v}_1,\dots, \hat{v}_r),\dots, u_s\mapsto prop_{u_s}(\hat{v}_1,\dots,\hat{v}_r)\} \] satisfies $\psi$

% For any instantiation $\psi$ of a quantified sub-formula with propagated cells $u_1,\dots, u_s$ and non-propagated cells $v_1,\dots, v_r$, the satisfiability propagator defines  functions $prop_{u_1},\dots, prop_{u_s}$ such that for any $\hat{v}_1,\dots,\hat{v}_r$, the cell interpretation
% \[\{ v_1\mapsto \hat{v}_1,\dots,v_r\mapsto \hat{v}_1, u_1\mapsto  prop_{u_1}(\hat{v}_1,\dots, \hat{v}_r),\dots, u_s\mapsto prop_{u_s}(\hat{v}_1,\dots,\hat{v}_r)\} \] satisfies $\psi$. In many cases, these functions can be synthesized automatically from the corresponding quantifier elimination problem~\cite{kuncak-sttt13}.\marek{Is \cite{kuncak-sttt13} applicable in our case too?}


Now, observe that for any cell $u$ there is at most one $z\in\domain^{\numvar{z}}$ with $u\in X_z$ (if there would be more than one then, due to $\preceq$ being a well-order, there is a minimal one, let us say $z_{\min}$, and then, for any $z'\succ z$, the requirements on $X_{z'}$ exclude the possibility of $X_{z'}$ containing $u$, as well). So for any cell $u$, let $\mathit{inst}(u)$ either be the $z\in\domain^{\numvar{\bar{x}}}$ with $u\in X_z$ or $\bot$ if there is no such instantiation.

Then, for the assignment $I_\phi$ from the proof of Property~\ref{prop:certThenSat}, which satisfies a given formula~$\phi$, and a given cell~$u$, the value of $I_\phi(u)$ can be computed by the following recursive function $val(u)$:
\begin{tabbing}\hspace*{0.4cm}\=\hspace*{0.4cm}\=\kill
	\textbf{if} $I$ assigns a value $x$ to $u$ \textbf{then} \textbf{return} $x$\\
	\textbf{if} $\mathit{inst}(u)=\bot$ \textbf{then} \textbf{return} 0\\
	\textbf{return} $prop_{u,\mathit{inst}(u)}(I\cup \{ v\mapsto val(v) \mid v\in \Gamma_{I,\mathit{inst}(u)}(\phi)\setminus \mathit{def}(I)\setminus X_z\})$
\end{tabbing}

Here, the recursive calls go down the order $\prec$ in the following sense:
\begin{property}
	Let $u$ be a cell such that $\mathit{inst}(u)\neq\bot$. Then for any other cell~$v\in\Gamma_{I,\mathit{inst}(u)}(\phi)\setminus \mathit{def}(I)\setminus X_z$ with $\mathit{inst}(v)\neq\bot$, $\mathit{inst}(v)\prec \mathit{inst}(u)$.
\end{property}

\begin{proof}
  Assume a cell $u$ with $\mathit{inst}(u)\neq\bot$, a  cell~$v\in\Gamma_{I,\mathit{inst}(u)}(\phi)\setminus \mathit{def}(I)\setminus X_z$ with $\mathit{inst}(v)\neq\bot$, and assume that $\mathit{inst}(v)\succeq \mathit{inst}(u)$. Then both $v\in X_{\mathit{inst}(v)}$ and $v \in \Gamma_{I,\mathit{inst}(u)}(\phi)$, and hence $X_{\mathit{inst}(v)}\cap \Gamma_{I,\mathit{inst}(u)}(\phi)\neq\emptyset$. 
%  Then $u\in X_{\mathit{inst}(u)}\subseteq \Gamma_{I,\mathit{inst}(u)}$ and $v\in X_{\mathit{inst}(v)}$.
  This contradicts the requirement that $X_{inst(v)}\cap (\mathit{def}(I)\cup\bigcup_{z'\prec inst(v)} \Gamma_{I,z'}(\phi))=\emptyset$.
  \qedhere
\end{proof}

So each recursive call of the program $val$ either results in $\mathit{inst}(u)$ either decreasing or being $\bot$. In the latter case, the program terminates immediately, and the former case cannot happen infinitely often, since the used order is well-founded. So we have:
\begin{property}
The program $val$ terminates.
\end{property}

Note that, in general, it is not possible to compute $val(u)$ by computing the values of $X_z, z \in \domain^{\numvar{z}}$, with $z$ being initialized with the minimal $z$ wrt. $\prec$, and then using a loop that increases $z$ from one successor wrt. $\prec$ to the next. For example, if  $\prec$  orders all even numbers before all odd ones, then this loop would have to iterate over infinitely many even numbers before computing the value of an odd one.
     

The goal is now an algorithm that computes such satisfiability certificates and a converse of the property that shows for certain classes of satisfiable  formulas this algorithm succeeds.



\section{Algorithm}\label{sec:alg}

We will now proceed from the  general certification framework to concrete computation. Throughout this section we assume a formula $\phi$ of the form~$F \land \forall \bar{x}.\; Q$, but with the additional restrictions described in the problem statement (\cref{sec:problem-statement}). In particular, we will allow only one quantified variables~$x$. The restrictions also require all arguments of any uninterpreted function symbol $f$ in $Q$ to have the same coefficient, and we will denote the sign of this coefficient by $\coeffsign{f}$.

We will introduce an algorithm that checks satisfiability of $\phi$  by computing a satisfiability certificate of a certain form. 
% While our certificate framework (~\cref{def:certificate}) supports formulas with arbitrary numbers of universally quantified variables, the algorithm presented here focuses on the case of a single universally quantified variable. We also assume that the coefficient of this variable in argument terms is non-negative, and that all non-zero coefficients of this variables are the same for the same uninterpreted function symbol.
The computed certificate will explicitly certify satisfiability of the quantifier-free part $F$ and satisfiability over a finite interval $B = [b_{\min}, b_{\max}]$ of instantiations of the quantified part $Q$. For values outside $B$, it uses satisfiability propagators with an order that propagates upward from $b_{\max}+1$ and downward from $b_{\min}-1$.  We will show soundness of the algorithm and completeness relative to conditions that ensure that such propagation outward from a base interval $B$ is possible.

% We will now formalize the condition ensuring that  propagation outward from a base interval $B$ is possible. For this, let $\mathcal{F}$ be the set of uninterpreted function symbols in the quantified part~$Q$ of $\phi$, and let~$\mathcal{T}$ be the set of terms of the form $f(t)$ in $Q$. For upward propagation, we select a subset of these terms $\mathcal{S} \subseteq\mathcal{T}$ whose argument terms are \emph{maximal} (all equal and strictly greater than other argument terms of the same function symbol). The \emph{propagability condition} then guarantees that, no matter what values are assigned to the non‑maximal occurrences, we can find values $v_1,\dots,v_r$ such that assigning $v_i$ to all occurrences in $\mathcal{S}$ makes $Q$ true. Different functions may receive different values. The downward condition is symmetric, selecting \emph{minimal} terms.

We will now formalize the condition ensuring that  propagation outward from a base interval $B$ is possible. For this, let $\mathcal{F}$ be the set of uninterpreted function symbols in the quantified part $Q$ of $\phi$, and let $\mathcal{T}$ be the set of terms of the form $f(t)$ in $Q$. For a given propagation direction $s \in \{+, -\}$ (where $+$ means increasing $x$ and $-$ means decreasing $x$), we select a subset $\mathcal{S} \subseteq \mathcal{T}$ of terms that are \emph{extremal} in the sense that they are all equal and, depending on the sign of the coefficient and the propagation direction, stand in the appropriate strict order to other argument terms of the same function symbol. The \emph{propagability condition} $\Phi_{\text{prop}}(\mathcal{S})$ then guarantees that, no matter what values are assigned to the non‑extremal occurrences, we can find values $v_1,\dots,v_r$ such that assigning $v_i$ to all occurrences in $\mathcal{S}$ makes $Q$ true. Different function symbols may receive different values. The condition for propagation in the opposite direction is symmetric, using a different subset $\mathcal{S}' \subseteq \mathcal{T}$.

\begin{definition}[\req Condition]
\label{def:reqpivot-param}
For any choice of subsets $\mathcal{S}\subseteq\mathcal{T}$ and signs $s\in\{ -, +\}$, define:
\begin{itemize}
\item \textbf{Extremal condition $\Phi^s_{\text{ext}}(\mathcal{S})$:}
  \vspace*{-0.2cm}
  \[
        \subst{ \bigwedge_{f\in\mathcal{F}}\left(\bigwedge_{f(t),f(t') \in \mathcal{S}} t = t' \;\land\;
        \bigwedge_{f(t) \in \mathcal{S}, f(t') \in \mathcal{T}\setminus\mathcal{S}} t' \cmpsignstrict{\coeffsign{f}s} t
        \right)}{x}{0}.
    \]
    
    \item \textbf{Propagability condition $\Phi_{\text{prop}}(\mathcal{S})$:}
        \[\forall x \forall \bar{u} \exists \bar{v}.\ Q'(\mathcal{S})\]
        where $\bar{u}$ corresponds to the variables $u_{f(t)}$ with $f(t)\in\mathcal{T}\setminus\mathcal{S}$ and $\bar{v}$ to the variables $v_{f(t)}$ with $f(t)\in \mathcal{S}$, and $Q'$ is obtained from $Q$ by simultaneously replacing
        \begin{itemize}
            \item every $f(t)\in\mathcal{T}\setminus\mathcal{S}$ by $u_{f(t)}$, and
            \item every $f(t)\in\mathcal{S}$ by $v_{f(t)}$.
        \end{itemize}
\end{itemize}
We say that $Q$ satisfies the \emph{\req condition} for subsets $\mathcal{S}\subseteq\mathcal{T}$ and $\mathcal{S}'\subseteq\mathcal{T}$ iff $\Phi^+_{\text{ext}}(\mathcal{S})$, $\Phi_{\text{prop}}(\mathcal{S})$,
$\Phi^{-}_{\text{ext}}(\mathcal{S}')$, and $\Phi_{\text{prop}}(\mathcal{S}')$ are satisfiable. Moreover, $Q$ satisfies the \emph{\req condition} iff such a pair~$(\mathcal{S}, \mathcal{S}')$ exists.
\end{definition}

\begin{example}[\req\ Illustration]
\label{ex:req-illustration}
Consider
\[
\forall x.\;f(x+c+3)+f(x+4)+f(x+1)=g(x+2)+h(x),
\]
with ground constant $c$. All coefficients are $+1$, hence
$\coeffsign{f}=\coeffsign{g}=\coeffsign{h}=+$.
The set of terms is
\[
\mathcal{T} =\{f(x+c+3),\,f(x+4),\,f(x+1),\,g(x+2),\,h(x)\}.
\]
\smallskip
\noindent\textbf{Upward propagation ($s=+$).}
Let $\mathcal{S}=\{f(x+4),\,g(x+2)\}$.
For $f$, since $\coeffsign{f}s=+$ and $\cmpsignstrict{+}$ is $<$, the part of the extremal conditions under the parentheses reads
\[
x+c+3<x+4\;\land\;x+1<x+4,
\]
which, after substituting $0$ for $x$, yields $c<1$. For $g$ and $h$, $\mathcal{T}\setminus\mathcal{S}$ does not contain corresponding terms, so the condition is trivial.

Propagability becomes
\[
\begin{aligned}
    \forall x\;\forall u_{f(x+c+3)},\,u_{f(x+1)},\,u_{h(x)}\;\exists v_{f(x+4)},\,v_{g(x+2)}\;\text{such that} \\
    \qquad
    u_{f(x+c+3)}+v_{f(x+4)}+u_{f(x+1)} = v_{g(x+2)}+u_{h(x)}.
\end{aligned}
\]
This is satisfiable, e.g.\ by choosing $v_{g(x+2)}=0$ and $v_{f(x+4)}=u_{h(x)}-u_{f(x+c+3)}-u_{f(x+1)}$.

\smallskip
\noindent\textbf{Downward propagation ($s=-$).}
Let $\mathcal{S}'=\{f(x+1),\,h(x)\}$. Since $\coeffsign{f}s=-$ and $\cmpsignstrict{-}$ is $>$,  the part of the extremal conditions under the parentheses reads
\[
x+c+3>x+1\;\land\;x+4>x+1,
\]
which, after substituting $0$ for $x$, yields $c>-2$. The condition for $h$ is trivial.

Propagability becomes
\[
\begin{aligned}
    \forall x\;\forall u_{f(x+c+3)},\,u_{f(x+4)},\,u_{g(x+2)}\;\exists v_{f(x+1)},\,v_{h(x)}\;\text{such that} \\
    \qquad
    u_{f(x+c+3)}+u_{f(x+4)}+v_{f(x+1)}=u_{g(x+2)}+v_{h(x)},
\end{aligned}
\]
which is satisfiable, e.g. by choosing $v_{h(x)}=0$ and $v_{f(x+1)}=u_{g(x+2)}-u_{f(x+c+3)}-u_{f(x+4)}$.

\smallskip
\noindent\textbf{Conclusion.}
$Q$ satisfies the \req\ condition for $(\mathcal{S},\mathcal{S}')$
iff $c\in(-2,1)$.
\end{example}

Now, given a concrete interval $B = [b_{\min}, b_{\max}]$, we need additional ``clash conditions'' that prevent the cells generated during propagation from clashing with the ground part $F$.

\begin{definition}[Interval Extension Formulas]
\label{def:interval-extension-formulas-param}
For an interval $B\subseteq\mathbb{Z}$  a sign~$s\in\{-,+\}$, and a subset $\mathcal{S} \subseteq \mathcal{T}$, define
 $\Psi^{s}(B,\mathcal{S})$:=
    \[
    \Phi^{s}_{\text{ext}}(\mathcal{S})\;\land\; 
    \Phi_{\text{prop}}(\mathcal{S}) \;\land
    \bigwedge_{f(t) \in \mathcal{S}} \bigwedge_{\substack{a \in \args(F,f)}} a\cmpsignstrict{\coeffsign{f}s}  \subst{t}{x}{\ivbound{B}{s}} 
    \]
    where $\Phi^{s}_{\text{ext}}(\mathcal{S})$ and $\Phi_{\text{prop}}(\mathcal{S})$ are as defined in \cref{def:reqpivot-param}.
\end{definition}

% Thus, for any choice of subsets $\mathcal{S},\mathcal{S}'\subseteq\mathcal{T}$, $\Psi^s(B,\mathcal{S})$  asserts that $\mathcal{S}$ satisfies the conditions of \req \emph{and additionally} satisfies the clash condition for interval $B$. The additional clash condition ensures that for every ground argument $a$ of $f$ appearing in $F$, the propagated cell $f(\subst{t}{x}{\repr{z}})$ and $f(t)\in\mathcal{S}$ is different from the ground cell $f(a)$.

Thus, for any sign $s\in\{-,+\}$ and subset $\mathcal{S}\subseteq\mathcal{T}$, $\Psi^s(B,\mathcal{S})$ asserts that $\mathcal{S}$ satisfies the \req\ conditions for direction $s$ and \emph{additionally} satisfies the clash condition for interval $B$. This clash condition ensures that for every ground argument $a$ of $f$ appearing in $F$, the propagated cell $f(\subst{t}{x}{\ivbound{B}{s}})$ (with $f(t)\in\mathcal{S}$) is different from the ground cell $f(a)$.

\begin{theorem}[Interval Satisfiability]
\label{thm:interval-certificate-param}
Let $B$ be a non‑empty integer interval, and assume that
\[
  \Biggl(F \land \bigwedge_{x \in B} \subst{Q}{x}{\repr{x}}\Biggr) \;\land\;
  \Biggl(\bigvee_{\mathcal{S}\subseteq \mathcal{T}}\Psi^+(B,\mathcal{S})\Biggr)\;\land\;
  \Biggl(\bigvee_{\mathcal{S}'\subseteq \mathcal{T}}\Psi^-(B,\mathcal{S}')\Biggr)
\]
is satisfiable, then  $F \land \bigwedge_{x \in B} \subst{Q}{x}{\repr{x}}\wedge \forall x\;.\; x\not\in B \Rightarrow Q$ has a satisfiability certificate, and hence $\phi$ is satisfiable.
\end{theorem}

\begin{proof}
  Suppose the conjunction is satisfiable, let $I^*$ be an interpretation satisfying it, and let $\mathcal{S}$ be such that $I^*\models \Psi^+(B,\mathcal{S})$, and $\mathcal{S}'$ such that $I^*\models \Psi^-(B,\mathcal{S}')$. Assume that  $B = [b_{\min}, b_{\max}]$. We construct a certificate as in \cref{def:certificate}:

\begin{enumerate}
    \item \textbf{Pre‑satisfiability certificate:} Define the cell interpretation~$I$ as follows:
      \begin{itemize}
        \item For every uninterpreted constant $c$ in $\phi$, set $I(c)=I^*(c)$.
        \item For every $a\in args(F \land \bigwedge_{x \in B} \subst{Q}{x}{\repr{x}}, f)$,  where $f$ is an uninterpreted function symbol, $I(f(I^*(a)))=I^*(f)(I^{*}(a))$
    \end{itemize}
    By construction, $I$ is finite and satisfies $F \land \bigwedge_{x \in B} \subst{Q}{x}{\repr{x}}$ because $I^*$ satisfies that formula and $I$ agrees with $I^*$ on all relevant cells.
       
    \item \textbf{Well‑order $\preceq$ on $\mathbb{Z}$:}
    \[0, 1, -1, 2, -2, 3, -3, \dots, b_{\max}, b_{\min},b_{\max}+1, b_{\max}+2, \dots,b_{\min}-1, b_{\min}-2, \dots\]		
    
  \item \textbf{Propagated cells $X_z$ for $z \in \mathbb{Z}$:}
    \[
    X_z = 
    \begin{cases}
    \emptyset & \text{if } z \in B, \\[4pt]
    \bigl\{ f(I(\subst{t}{x}{\hat{z}})) \mid f(t)\in\mathcal{S} \bigr\} & \text{if } z > b_{\max}, \\[4pt]
    \bigl\{ f(I(\subst{t}{x}{\hat{z}})) \mid f(t)\in\mathcal{S}' \bigr\} & \text{if } z < b_{\min}.
    \end{cases}
    \]
    Note that the extremal conditions $\Phi^+_{\text{ext}}(\mathcal{S})$ and $\Phi^-_{\text{ext}}(\mathcal{S}')$ ensure that for $z\not\in B$, $f\in\mathcal{F}$, $|\{ n \mid f(n)\in X_z\}|\leq 1$.

    \item \textbf{Satisfiability propagators:}
    \begin{itemize}
    \item For $z \in B$: In this case, $\subst{(x\not\in B \Rightarrow Q)}{x}{\hat{z}}$ is a tautology and the propagator is trivial.
        \item For $z\not\in B$: the condition $\Phi_{\text{prop}}(\mathcal{S})$ provides, for any given values for all non‑propagated cells in $\Gamma_{I,z}(\phi)$ and each $f(t)\in\mathcal{S}$, values $v_{f(t)}$  such that assigning these values to each corresponding cells in $X_z$ satisfies~$\subst{Q}{x}{\repr{z}}$.
    \end{itemize}
\end{enumerate}
It remains to verify the disjointness conditions of \cref{def:certificate}:
\[X_z\cap \mathit{def}(I)=\emptyset \text{ and } X_z\cap\bigcup_{z'\prec z} \Gamma_{I,z'}(\phi)=\emptyset.\]
\begin{itemize}
    \item For $z \in B$, $X_z = \emptyset$, and hence both conditions hold trivially.    
    \item For $z > b_{\max}$, any element of $X_z$ has the form $f(I(\subst{t}{x}{\repr{z}}))$ with $f(t) \in \mathcal{S}$.
    \begin{itemize}
        \item To prove that this element of $X_z$ cannot be in $\mathit{def}(I)$, let $f'(t')$ be an arbitrary, but fixed element of $\mathit{def}(I)$. We prove that $f'(I(\subst{t'}{x}{\repr{z}}))\neq f(I(\subst{t}{x}{\repr{z}}))$. If $f$ is a different function symbol than $f'$ this is certainly the case, and hence it suffices to prove $f(I(\subst{t'}{x}{\repr{z}}))\neq f(I(\subst{t}{x}{\repr{z}})$, which makes it necessary to prove $I(\subst{t'}{x}{\repr{z}}))\neq I(\subst{t}{x}{\repr{z}})$. The $\mathit{def}(I)$ contains cells of two types:
        \begin{enumerate}
            \item Cells $f(I(a))$ for ground arguments $a \in args(F,f)$.
            \item Cells $f(I(\subst{t_0}{x}{z_0}))$ for $z_0 \in B$ and $f(t_0)$ occurring in $Q$.
        \end{enumerate}
        
        For type (1), the clash condition $a\cmpsignstrict{\coeffsign{f}+}\subst{t}{x}{\ivbound{B}{s}}$ in $\Psi^+(B,\mathcal{S})$ guarantees that for every ground argument $a \in \args(F,f)$:\todoSR{missing: $a\in \text{def}(I)$ but $a\not\in args(F,f)$}\todoSN{Done, type (2).}
        \[
        I\models a\cmpsign{\coeffsign{f}+}  \subst{t}{x}{\repr{b}_{\max}} \cmpsignstrict{\coeffsign{f}+} \subst{t}{x}{\repr{z}},
        \]
        where the strict inequality follows because $t$ is linear, and $z > b_{\max}$. Hence $I(a)\neq I(\subst{t}{x}{\repr{z}})$.
        
        For type (2), since $z_0 \leq b_{\max} < z$ and $t$ is extremal for $s=+$, we have:

        \[
        I\models \subst{t_0}{x}{\repr{z_0}}\cmpsign{\coeffsign{f}+}  \subst{t_0}{x}{\repr{b}_{\max}} \cmpsignstrict{\coeffsign{f}+} \subst{t}{x}{\repr{b}_{max}+1}\cmpsign{\coeffsign{f}+}\subst{t}{x}{\repr{z}},
        \]      
        and thus $I(\subst{t_0}{x}{\repr{z_0}}) \neq I(\subst{t}{x}{\repr{z}})$.
        
      \item To prove that this element of $X_z$ cannot appear in any $\Gamma_{I,z'}(\phi)$ with $z' \prec z$, let $f'$ be an uninterpreted function symbol and $t'\in args(Q,f)$  and prove that $f'(I(\subst{t'}{x}{\repr{z}'}))\neq f(I(\subst{t}{x}{\repr{z}}))$. Again it suffices to analyze the case where $f$ and $f'$ are the same function symbols, and to prove that
        $I(\subst{t'}{x}{\repr{z}'}))\neq I(\subst{t}{x}{\repr{z}})$. Observe that since $t'$ and $t$ are arguments of the same function symbol, the respective coefficients of $x$ in $t$ and $t'$ are the same. Also observe that $z'\prec z$ and $b_{\max}<z$ implies that $z'<z$. Due to this,
        \[
          I\models \subst{t'}{x}{\hat{z}'}\cmpsignstrict{\coeffsign{f}+} \subst{t'}{x}{\hat{z}}.
        \]
        Moreover, $\Phi^{+}_{\text{ext}}(\mathcal{S})$ ensures 
                \[
          I\models \subst{t'}{x}{\hat{z}}\cmpsignstrict{\coeffsign{f}+}\subst{t}{x}{\hat{z}}.
        \]
Hence $I(\subst{t'}{x}{\repr{z}'})\cmpsignstrict{\coeffsign{f}} I(\subst{t}{x}{\repr{z}}))$, which implies that the two sides of the inequality cannot be the same.
    %     \begin{itemize}
    %         \item If $z' \leq b_{\max}$: For any $t'$ with $f(t') \in \mathcal{T}$, 
    %         \[
    %         I\models\subst{t'}{x}{z'} \leq \subst{t'}{x}{\repr{b}_{\max}} < \subst{t}{x}{\repr{z}},
    %         \]
    %         since $t$ is maximal among terms of $f$ in $\mathcal{T}$ by $\Phi_{\text{max}}(\mathcal{S})$ and $z > b_{\max}$.
            
    %         \item If $b_{\max} < z' < z$: Then 
    %         \[
    %         I(\subst{t'}{x}{z'}) \leq \max_{f(t'') \in \mathcal{T} \text{ with same } f} I(\subst{t''}{x}{z'}) < I(\subst{t}{x}{\repr{z}})
    %         \]
    %         since $t$ is maximal and $z' < z$.
    %     \end{itemize}        
    \end{itemize}

  \item The case $z < b_{\min}$ is symmetric, using $\Psi^-(B,\mathcal{S}')$.
    Note that the fact that the upward propagation block of elements greater than $b_{\max}$ occurs before the downward propagation block of elements less than $b_{\min}$ in the order $\preceq$ does not create a problem, since  propagation is still restricted to cells not occurring before.
\end{itemize}
% Finally, we must ensure that the \textbf{satisfiability propagators} can be applied inductively along $\preceq$.  
% For $z > b_{\max}$, the propagator $\Phi_{\text{prop}}(\mathcal{S})$ requires values for all non‑propagated cells in $\Gamma_{I,z}(\phi)$.  
% Let $f(t') \in \mathcal{T}\setminus\mathcal{S}$ be such a non‑propagated term. Its corresponding cell is $f(I(\subst{t'}{x}{\repr{z}}))$.  
% By the last conjunct in $\Psi^+(B,\mathcal{S})$, we have $I \models \subst{t'}{x}{z} \geq b_{\min}$.  
% Thus $I(\subst{t'}{x}{\repr{z}})$ is either in $B$ (if $\leq b_{\max}$) or satisfies $I(\subst{t'}{x}{\repr{z}}) > b_{\max}$.  

% In the well‑order $\preceq$, all indices $w$ with $w > b_{\max}$ appear \emph{before} any $w < b_{\min}$.  
% Hence $f(I(\subst{t'}{x}{\repr{z}}))$ has already been assigned when processing $z$:
% \begin{itemize}
%     \item If $I(\subst{t'}{x}{\repr{z}}) \in B$, the cell is defined in the base assignment $I$.
%     \item If $I(\subst{t'}{x}{\repr{z}}) > b_{\max}$, it is a propagated cell from some earlier $z' < z$ (since $t'$ has the same coefficient of $x$ as $t$, and $I(\subst{t'}{x}{\repr{z}}) < I(\subst{t}{x}{\repr{z}})$ by maximality).
% \end{itemize}
% Therefore all non‑propagated cells needed for the propagator at $z$ are already defined, and the propagator can assign values to $X_z$ without circularity. A symmetric argument (without extra constraints) applies to $z < b_{\min}$, because those instantiations occur \emph{after} all $z > b_{\max}$ in $\preceq$, and hence may safely use cells assigned during upward propagation.

% Thus all certificate requirements are satisfied. By Property \ref{prop:certThenSat}, $\phi$ is satisfiable.
\qedhere\end{proof}

The formula in the premise of \cref{thm:interval-certificate-param} belongs to the language of Presburger arithmetic (i.e., SMTLIB LIA), and hence its satisfiability can be algorithmically checked. Due to this, an interval $[b_{\min},b_{\max}]$ such that this formula is satisfiable is an algorithmically checkable certificate for the satisfiability of $\phi$. In order to make the algorithmic check more efficient, one can also include the cell interpretation necessary for showing $F \land \bigwedge_{x \in B} \subst{Q}{x}{\repr{x}}$ to be satisfiable, and the sets $\mathcal{S}$ and $\mathcal{S}'$.

Algorithmic implementations of the satisfiability propagators whose existence is ensured by the proof of \cref{thm:interval-certificate-param} can often be obtained from the witness functions that are 
a side product of quantifier elimination on the
propagability conditions~$\Phi_{\text{prop}}(\mathcal{S})$ and~$\Phi_{\text{prop}}(\mathcal{S}')$. These propagators  can then be used in the recursive evaluation function $val$ defined in \cref{sec:certificate} to compute values of the function that a model assigns to an uninterpreted function symbol.

The theorem immediately yields an algorithm that checks satisfiability by searching for the interval~$[b_{\min},b_{\max}]$. This can be seen in \cref{alg:interval-check-param-withBigvee}. An extension of the algorithm that in the case of the return value \textsc{Sat} also returns a corresponding certificate, is straightforward.

\begin{algorithm}
\caption{Interval‑Based Satisfiability Check}
\label{alg:interval-check-param-withBigvee}
\begin{algorithmic}[1]
\Require $\phi = F \land \forall x.\, Q$ in the fragment
\Ensure \textsc{Sat} or \textsc{Unsat}
\State $b_{\min} \gets 0$, $b_{\max} \gets 0$ 
% \State $I \gets \smt\!\left(F \land Q[0]\right)$
%\While{$I \neq \bot$}
\While{$F \land \bigwedge_{x=b_{\min}}^{b_{\max}} Q[x]$ is satisfiable}
    \State $\text{up}\gets\bigvee_{\mathcal{S}\subseteq \mathcal{T}}\Psi^+([b_{\min},b_{\max}],\mathcal{S})$
    \State $\text{down}\gets\bigvee_{{\mathcal{S}'\subseteq \mathcal{T}}}\Psi^-([b_{\min},b_{\max}],\mathcal{S}')$ 
    \If{$\left(F \land \bigwedge_{x=b_{\min}}^{b_{\max}} Q[x]\right) \land \text{up} \land \text{down}$ is satisfiable}
        \State \Return \textsc{Sat} 
    \EndIf
    \State $b_{\min} \gets b_{\min} - 1$, $b_{\max} \gets b_{\max} + 1$ \Comment{Expand interval symmetrically}
    % \State $I \gets \smt\left(F \land \bigwedge_{x=b_{\min}}^{b_{\max}} Q[x]\right)$
\EndWhile
\State \Return \textsc{Unsat}
\end{algorithmic}
\end{algorithm}

% \begin{corollary}[Soundness]
% \label{cor:soundness-bigvee}
% If \cref{alg:interval-check-param-withBigvee} terminates, then it returns a correct result.

% \end{corollary}

% \begin{proof}
%   If the result is $\textsc{Unsat}$, then $F \land \bigwedge_{x=b_{\min}}^{b_{\max}} Q[x]$ is unsatisfiable. This formula is implied by the input formula, and hence the result is correct. 

%   If the result is $\textsc{Sat}$, then this happens during a certain iteration of the while loop. Then there exists:
% \begin{itemize}
%     \item An interval $B = [b_{\min}, b_{\max}]$,
%     \item An interpretation $I$ satisfying:
%     \[
%     I \models F \land \bigwedge_{x \in B} Q[x] \land \text{max}^+ \land \text{min}_{\text{down}},
%     \]
%     where $\text{max}^+$ and $\text{min}_{\text{down}}$ are the disjunctions defined in lines 3--4 of the algorithm.
% \end{itemize}

% Since $I \models \text{max}^+$, there exists some $\mathcal{S}\subseteq\mathcal{T}$ such that 
% $I \models \Psi^+(B,\mathcal{S})$. Similarly, $I \models \text{min}_{\text{down}}$ implies there exists 
% $\mathcal{S}'\subseteq\mathcal{T}$ such that $I \models \Psi_{\text{down}}(B,\mathcal{S}')$. Thus $I$ satisfies:
% \[
% F \land \bigwedge_{x \in B} Q[x] \land \Psi^+(B,\mathcal{S}) \land \Psi_{\text{down}}(B,\mathcal{S}').
% \]

% By \cref{thm:interval-certificate-param}, this implies that $\phi$ has a satisfiability certificate 
% for the pair $(\mathcal{S},\mathcal{S}')$, and consequently $\phi$ is satisfiable.
% \qedhere\end{proof}


The correctness of the result \textsc{Sat} of the algorithm is an immediate consequence of \cref{alg:interval-check-param-withBigvee}. The correctness of the result \textsc{Unsat} follows from the fact that the termination condition of the while loop is a logical consequence of the input formula. However, it might also happen that the algorithm runs forever. We can exclude this under certain conditions:

\begin{theorem}[Relative Completeness]
\label{thm:completeness-bigvee}
If the input formula~$\phi$ is satisfiable, and
 satisfies the \req condition  then \cref{alg:interval-check-param-withBigvee} terminates and returns \textsc{Sat}.
\end{theorem}

\begin{proof}
Assume $\phi$ is satisfiable and satisfies \req for $(\mathcal{S}^*,\mathcal{S}'^*)$. 
Let $\mathcal{M}$ be a model of $\phi$ and extract the corresponding cell interpretation $I^*$\todoSR{Why not work directly with $I$?}. For each function $f \in \mathcal{F}$, let $c_f$ be the common coefficient of $x$ in all its arguments. For each $f(t)\in\mathcal{F}$, define:
\[
v_{\max}^f = \max\{\, I^*(\subst{t}{x}{0}) \mid f(t) \in \mathcal{T}\,\}, \qquad
v_{\min}^f = \min\{\, I^*(\subst{t}{x}{0}) \mid f(t) \in \mathcal{T} \,\}.
\]
% where $t_0=\subst{t}{x}{0}$ for each $f(t)\in\mathcal{T}$.
The conditions $\Phi_{\text{max}}(\mathcal{S}^*)$ and $\Phi_{\text{min}}(\mathcal{S}'^*)$ ensure that:
\begin{itemize}
    \item For all $f(t) \in \mathcal{S}^*$: $I^*(\subst{t}{x}{0}) = v_{\max}^f$,
    \item For all $f(t) \in \mathcal{S}'^*$: $I^*(\subst{t}{x}{0}) = v_{\min}^f$.
\end{itemize}
Now choose\todoSR{what if $c_f$ is negative?}
\begin{minipage}{\linewidth-2cm}
\vspace*{-0.5cm}  
\begin{align*}
  b_{\max} &= \max\left\{\, \left\lceil \frac{I^*(a) - v_{\max}^f}{c_f} \right\rceil \;\middle|\; a \in \args(F,f), f \in \mathcal{F} \,\right\}\\
b_{\min} &= \min\left\{\, \left\lfloor \frac{I^*(a) - v_{\min}^f}{c_f} \right\rfloor \;\middle|\; a \in \args(F,f), f \in \mathcal{F} \,\right\},
\end{align*}
\end{minipage}

and set $B = [b_{\min}, b_{\max}]$. We verify that $I^*$ satisfies:
\begin{enumerate}
    \item \textbf{Base formula}: $I^* \models F \land \bigwedge_{x \in B} Q[x]$ (since $\mathcal{M} \models \phi$).
    
    \item \textbf{Upward disjunction $\text{max}_{\text{up}}$}: 
    For the specific $\mathcal{S}^*$, we have:
    \begin{itemize}
        \item $\Phi_{\text{max}}^+(\mathcal{S}^*)$ holds by definition,
        \item $\Phi_{\text{prop}}(\mathcal{S}^*)$ holds by the \req condition,
        \item For each $f(t)\in\mathcal{S}^*$ and $a \in \args(F,f)$:\\ Since $I^*(\subst{t}{x}{0})=v_{\max}^f$, we have:   % \[
        % I^*(t_g) \leq b_{\max} + v_{\max}^f = b_{\max} + I^*(t)
        % \]
        \[
        I^*(a) \cmpsign{\coeffsign{f}} c_f \cdot b_{\max} + v_{\max}^f = c_f \cdot b_{\max} + I^*(\subst{t}{x}{0}) = I^*(\subst{t}{x}{\hat{b}_{\max}})
        \]
        by construction of $b_{\max}$, which is exactly the clash condition.
    \end{itemize}
    Thus $I^* \models \Psi^+(B,\mathcal{S}^*)$, and consequently $I^* \models \text{max}_{\text{up}}$.
    
    \item \textbf{Downward disjunction $\text{min}_{\text{down}}$}: 
    Similarly, for $\mathcal{S}'^*$ we have:
    \begin{itemize}
        \item $\Phi_{\text{max}}^+(\mathcal{S}'^*)$ holds,
        \item $\Phi_{\text{prop}}(\mathcal{S}'^*)$ holds,
        \item For each $f(t)\in\mathcal{S}'^{*}$ and $a \in \args(F,f)$:
        % \[
        % I^*(t_g) \geq b_{\min} + v_{\min}^i = b_{\min} + I^*(t)
        % \]
        \[
        I^*(a)\cmpsign{-\coeffsign{f}}  c_f \cdot b_{\min} + v_{\min}^f = c_f \cdot b_{\min} + I^*(\subst{t}{x}{0}) = I^*(\subst{t}{x}{b_{\min}})
        \]
        by construction of $b_{\min}$.
    \end{itemize}
    Thus $I^* \models \Psi_{\text{down}}(B,\mathcal{S}'^*)$, and consequently $I^* \models \text{min}_{\text{down}}$.
\end{enumerate}

Let $N = \max(|b_{\min}|, |b_{\max}|)$. \cref{alg:interval-check-param-withBigvee} expands the interval symmetrically from $[0,0]$. When it reaches iteration $n = N$, the interval becomes $[-N, N]$, which contains $B$. At this iteration, line 5 will check the satisfiability of:
\[
F \land \bigwedge_{x=-N}^{N} Q[x] \land \text{max}^+ \land \text{min}_{\text{down}}
\]
where $\text{max}^+$ and $\text{min}_{\text{down}}$ are constructed for the interval $[-N, N]$. Since $[-N, N]$ contains $B$, and $I^*$ satisfies all three conditions as shown above, this formula is satisfiable (witnessed by $I^*$). Therefore, the algorithm returns \textsc{Sat}.
\qedhere\end{proof}

While proofs of unsatisfiability are not the main goal of this paper, \Cref{alg:interval-check-param-withBigvee} can also detect unsatisfiability, in some cases.

\begin{theorem}[Termination for Finitely Unsatisfiable Formulas]
\label{thm:finiteunsatThenUNSAT}
If there exists a finite set $Z\subseteq\mathbb{Z}$ such that $F \land \bigwedge_{z\in Z} Q[x \mapsto \repr{z}]$ is unsatisfiable, then \cref{alg:interval-check-param-withBigvee} will terminate and return \textsc{Unsat}.
\end{theorem}

However, there are formulas that are not satisfiable in a standard model\todoSR{Should we make a more general statement? (see the discussion in the MBQI paper)}, for which the algorithm does not terminate.
%This occurs when the unsatisfiability relies on reasoning that cannot be captured by finite instantiation alone.

\begin{example}[Formula Requiring Induction]
Consider the formula:
\[
f(0) = 0 \land f(c) \neq 0 \land \forall x.\, f(x) = f(x+1)
\]
This formula is unsatisfiable in standard integer arithmetic (applying induction in both directions yields $\forall n.\, f(n) = 0$, contradicting $f(c) \neq 0$). However, any finite set of instantiations is satisfiable by choosing $c$ to be a sufficiently large integer. Thus, \cref{alg:interval-check-param-withBigvee} will expand the interval indefinitely without detecting unsatisfiability.
\end{example}


\section{Propositional Encoding}

The algorithm presented so far relies on large disjunctions over all possible subset choices $\mathcal{S}\subseteq\mathcal{T}$ and $\mathcal{S}'\subseteq\mathcal{T}$. While theoretically elegant, these disjunctions lead to formulas with exponential size, making them computationally impractical. In this subsection, we present a compact CNF encoding that avoids this issue.

\paragraph{Encoding Idea.} Instead of enumerating all subset choices we introduce auxiliary Boolean variables that represent membership in the subsets $\mathcal{S}$ and $\mathcal{S}'$. For each term $f(t)\in\mathcal{T}$, we create:
\begin{itemize}
    \item $s_{f(t)}$: true iff $f(t) \in \mathcal{S}$ (for propagation with $s=+$)
    \item $s'_{f(t)}$: true iff $f(t) \in \mathcal{S}'$ (for propagation with $s=-$)
\end{itemize}

We then encode the extremal conditions $\Phi^s_{\text{ext}}$, the propagability condition $\Phi_{\text{prop}}$, and the clash conditions using these variables, yielding a compact representation of $\Psi^{s,\text{e}}(B)$ for each sign $s$.

\begin{definition}[CNF Encoding of Interval Extension Formulas]
\label{def:interval-extension-formulas-CNF}
For an interval $B = [b_{\min}, b_{\max}]$, define the encoded formulas:
\[\Psi^{s,\text{e}}(B) \;\equiv\; \Phi^{s,\text{e}}_{\text{ext}} \;\land\; \Phi_{\text{prop}}^{\text{e}} \;\land\; \text{ClashEnc}^s\]
%\Psi_{\text{down}}^\text{e}(B) &\equiv \Phi_\text{min}^\text{e} \land \Phi_\text{prop}^\text{e} \land 
where:
\begin{itemize}
    \item Extremal condition encoding $\Phi^{s,\text{e}}_{\text{ext}}$:
    \begin{align*}
        \subst{
        \bigwedge_{f \in \mathcal{F}}\ \bigwedge_{\substack{f(t),\, f(t') \in \mathcal{T}}}
        \Bigl( (s_{f(t)} \land s_{f(t')}) \Rightarrow t = t' \;\land\; 
        (s_{f(t)} \land \neg s_{f(t')}) \Rightarrow t' \;\cmpsignstrict{\coeffsign{f}s}\; t \Bigr)}{x}{0}
    \end{align*}
   
    \item Propagation encoding $\Phi_{\text{prop}}^{\text{e}}$:%
    \[
    \bigwedge_{\mathcal{T}_{\!-}\subseteq\mathcal{T}}
    \left(\bigwedge_{f(t)\in\mathcal{T}_{\!-}} \neg s_{f(t)} \;\wedge\; \bigwedge_{f(t)\in\mathcal{T}\setminus\mathcal{T}_{\!-}} s_{f(t)}\;\Rightarrow\; \forall x\, \forall \bar{u}\, \exists \bar{v}\; Q^{\mathcal{T}_{\!-}}\right),
    \]
    where $\bar{u}=(u_{f(t)})_{f(t)\in\mathcal{T}_{\!-}}$ and $\bar{v}=(v_{f(t)})_{f(t)\in\mathcal{T}\setminus\mathcal{T}_{\!-}}$, and $Q^{\mathcal{T}_{\!-}}$ is obtained from $Q$ by simultaneously replacing each $f(t)\in\mathcal{T}_{\!-}$ by $u_{f(t)}$ and each $f(t)\in\mathcal{T}\setminus\mathcal{T}_{\!-}$ by $v_{f(t)}$.

    % \[\bigwedge_{\substack{f(t)\in\mathcal{T} \\ \sigma_{f(t)}\in\{\neg,\cdot\}}} \left(\bigwedge_{f(t)\in\mathcal{T}} \sigma_{f(t)}s_{f(t)}\Rightarrow\forall x \forall \bar{u} \exists \bar{v}.\ Q'\right)\]

    % where $\bar{u}$ corresponds to the variables $u_{f(t)}$ where $\sigma_{f(t)}$ is $\neg$ and $\bar{v}$ to the variables $v_{f(t)}$ where $\sigma_{f(t)}$ is $\cdot$, and $Q'$ is obtained from $Q$ by simultaneously replacing
    % \begin{itemize}
    %     \item every $f(t)\in\mathcal{T}$ with $\sigma_{f(t)}=\neg$ by $u_{f(t)}$, and
    %     \item every $f(t)\in\mathcal{T}$ with $\sigma_{f(t)}=\cdot$ by $v_{f(t)}$, 
    % \end{itemize}
    % and $\cdot$ is a dummy symbol, and hence for any propositional variable $p$, $\cdot p$ is the same as $p$.
        
    \item Clash condition encoding $\text{ClashEnc}^s$:
      % \begin{align*}
\[  \bigwedge_{f(t)\in\mathcal {T}}\bigwedge_{a \in \args(F,f)} \left(s_{f(t)} \Rightarrow a\cmpsignstrict{\coeffsign{f}s}  \subst{t}{x}{\ivbound{B}{s}}\right)    \]
%\[    \text{ClashDownEnc} \equiv \bigwedge_{f(t)\in\mathcal
%        {T}}\bigwedge_{a \in \args(F,f_i)} \big(s'_{f(t)} \Rightarrow (a \geq \subst{t}{x}{b_{\min}})\big)\]
%    \end{align*}
\end{itemize}
\end{definition}

Note that if for some $f\in\mathcal{{F}}$ the ground parts of its argument terms (obtained by substituting $x=0$) are pairwise different, then at most one $s_{f(t)}$ can be true in any satisfying assignment of $\Psi^{s,\text{e}}(B)$. This follows from the extremal condition, which would otherwise require two distinct ground terms to be equal.

\begin{lemma}[Encoding Correctness]
\label{lem:encoding-correctness}
For any interval $B = [b_{\min}, b_{\max}]$,  and sign~$s\in\{+, -\}$, 
 $\Psi^{s,\text{e}}(B)$ is satisfiable iff there exists $\mathcal{S}\subseteq\mathcal{T}$ such that $\Psi^{s}(B,\mathcal{S})$ holds.
\end{lemma}

% \begin{proof}
%     ($\Rightarrow$) Suppose $\Psi_\text{up}^\text{e}(B)$ is satisfiable by an assignment $I$. Define $\mathcal{S} = \{f(t) \mid I(s_{f(t)}) = \text{true}\}$. By $\Phi_{\text{max}}^\text{e}$, for each function $f$, all $f(t) \in \mathcal{S}$ have equal ground parts under $I$, and they are strictly greater than those of any $f(t') \in \mathcal{T} \setminus \mathcal{S}$ with the same $f$. Since all terms have the same coefficient of $x$, this implies $\Phi_{\text{max}}(\mathcal{S})$ holds. By $\Phi_{\text{prop}}^\text{e}$, all $f(t) \in \mathcal{S}$ are equal to $v_{f(t)}$, satisfying the substitution in $\Phi_{\text{prop}}(\mathcal{S})$. Finally, $\text{ClashUpEnc}$ ensures the clash condition $a \leq \subst{t}{x}{b_{\max}}$ for all $f(t) \in \mathcal{S}$. Hence $\Psi_{\text{up}}(B,\mathcal{S})$ holds.

%     ($\Leftarrow$) Suppose $\Psi_{\text{up}}(B,\mathcal{S})$ holds for some $\mathcal{S} \subseteq \mathcal{T}$. Set $s_{f(t)}$ true iff $f(t) \in \mathcal{S}$. By $\Phi_{\text{max}}(\mathcal{S})$, for each function $f$, all selected terms have equal ground parts (after $x=0$ substitution) and these are greater than non-selected ones, so $\Phi_{\text{max}}^\text{e}$ holds. Let $v_{f(t)}$ be the common value for $f(t) \in \mathcal{S}$ (guaranteed by $\Phi_{\text{prop}}(\mathcal{S})$), then $\Phi_{\text{prop}}^\text{e}$ holds. The clash condition from $\Psi_{\text{up}}(B,\mathcal{S})$ ensures $\text{ClashUpEnc}$. Thus $\Psi_\text{up}^\text{e}(B)$ is satisfiable.
    
%     The proof for $\Psi_\text{down}^\text{e}(B)$ is symmetric.
% \qedhere\end{proof}

% \paragraph{Practical Considerations.}
% The exponential disjunctions in \cref{alg:interval-check-param-withBigvee} 
% (lines 3--4) can be replaced by the CNF encodings $\Psi_\text{up}^\text{e}$ and $\Psi_\text{down}^\text{e}$ as defined above, which are equi-satisfiable by \cref{lem:encoding-correctness}. This yields a practical implementation while preserving all theoretical guarantees. Thus, the CNF encoding approach provides a practical bridge between the theoretical \req framework and implementable algorithm, while avoiding exponential formula size.

\section{Experiments}

Two common reasons for verification conditions to fail are (1) a bug in the program, (2) underlying
assertions are not inductive. In the first case, the counter-model will typically be finite, since
program executions modify finite memory. In the second case, the counter-model may be infinite.
The workings of our method clearly solve the second case.
However, even in the first case our method may improve upon methods such as MBQI, due to two reasons.
First, the models produced by MBQI may be particularly difficult to read. Next, the run-time
of MBQI increases with the size of the model.

We have prepared a short test suite consisting of 28 small problems such as
\begin{align}\label{eq:exp1}
	f(4)=7 \;\land\; \forall x.\; (0 \le x \le 10^c \;\Rightarrow\; f(x+1)=f(x)+1),
\end{align}
where we tested how well the state of the art \textsc{smt} solvers \textsc{z3} and
\textsc{cvc5}\footnote{ran with the argument \texttt{--mbqi}}
scale with increasing positive $c$. On this example,
our algorithm has to check just that for all values of $f(x)$, there exists a value of $f(x+1)$
such that the equality holds. It suffices to consider the interval $[0,\, 4]$.

Another problem in our set is
\begin{align}\label{eq:exp2}
	F       & = (d > 1)\;\land\; f(0)=0 \;\land\; g(2) > f(d+1)             \notag \\
	Q(x)    & = (0 \le x \le 10^c \;\Rightarrow\; f(x-1)=f(x)+g(x)+g(x+d))  \notag \\
	\varphi & = F \;\land\; \forall x.\; Q(x)
\end{align}
Here, our algorithm terminates right after ensuring that \req holds for the interval $[0,\, 3]$.

We ran our experiments with a 30-minute time limit.
When setting $c = 1$, the state of the art \textsc{smt} solvers terminate on our
problems immediately. On problem~\eqref{eq:exp1} with $c = 3$, \textsc{cvc5} takes
64 seconds to return \textsc{sat}, and for $c \geq 4$, the solver times out. With
$c \geq 2$, \textsc{z3} returns \textsc{unknown} after 12 seconds. On problem~\eqref{eq:exp2},
\textsc{cvc5} times out with $c \geq 3$ and \textsc{z3} returns \textsc{unknown} starting
from $c = 2$. Figure~\ref{fig:scaling} further depicts how the two solvers perform on our problems
with increasing $c$.
Between $c=2$ and $c=5$, \textsc{cvc5} shows a sharp performance drop, decreasing from 28 solved instances at
$c=1$ to 5 at $c=4$, and remaining at that level at $c=5$. In contrast, z3 remains relatively stable
over this range, solving 6 to 7 instances.
We also tested the performance of the two solvers on unbounded problems, that is with the
bound $0 \le x \le 10^c$ removed. \textsc{z3} solved 5 of those problems while \textsc{cvc5}
solved 2.
The cactus plots in Figure~\ref{fig:cactus} show the number of problems solved by \textsc{cvc5}
within a time limit for $c \in \{2, 3\}$. We can observe most of the problems get solved
in the 10 to 100 seconds limit when setting $c = 3$. With $c \geq 4$, \textsc{cvc5} times out
on all but 5 problems, which get solved immediately.

\begin{figure}[ht]
	\centering
	\includegraphics[width=0.6\linewidth]{experiments/data/scaling_plot.png}
	\caption{Problems solved with increasing $c$. Asterisk coordinate denotes unbounded problems.}
	\label{fig:scaling}
\end{figure}

\begin{figure}[ht]
	\centering
	\includegraphics[width=1\linewidth]{experiments/data/cactus_plot.png}
	\caption{Runtime of \textsc{cvc5} for solved problems with $c \in \{2, 3\}$.}
	\label{fig:cactus}
\end{figure}

Note that our algorithm proves the satisfiability of these problems promptly. Only a few
LIA calls are needed to prove the \req condition. However, our algorithm struggles on
problems such as
\begin{align*}
	f(10000)>0 \;\land \;\forall x. \;f(x+1) = f(x)+1
\end{align*}
The clash condition requires $10000 \leq b_{\max} + 1$, therefore
forcing 10000 expansions of the interval in \cref{alg:interval-check-param-withBigvee}.
Improving the algorithm on cases similar to this one is a subject of future work.

\section{Conclusion}
\label{sec:conclusion}

We have presented a novel approach to certifying satisfiability for universally quantified integer arithmetic formulas with uninterpreted functions—a fragment of UFLIA that appears naturally in verification of arrays and recursive programs. Unlike traditional $\smt$ methods that construct explicit models, our technique replaces infinite models with finite inductive certificates based on propagation arguments.

At the foundation lies a general certificate framework that decouples the logical structure of satisfiability proofs from algorithmic details. A certificate consists of a finite base assignment, a well‑order, and propagators that extend the assignment stepwise along that order. This framework is sound for any well‑founded order and any number of quantified variables, providing a flexible basis for future extensions.

For the single‑variable fragment we instantiate the framework with a concrete, implementable algorithm. The algorithm searches for a base interval~$B$ and term subsets~$\mathcal{S},\mathcal{S}'$ satisfying the \req condition—a propagation property that ensures the assignment on~$B$ can be extended outward without conflict. By encoding the search as ordinary $\smt$ queries, and employing a compact CNF encoding to avoid exponential blow‑up, we obtain a procedure that is sound, relatively complete for formulas satisfying \req, and directly executable on existing $\smt$ solvers.

Our experiments...

The main limitations of the current algorithm—its restriction to one quantified variable and to uniform coefficients per function—point to natural directions for future work. Generalizing the propagation condition to handle multiple variables, non‑collinear coefficients, or nested function calls would significantly widen its applicability.

In summary, by shifting from explicit model construction to inductive propagation we offer a viable, certificate‑based alternative for deciding satisfiability in a practically relevant fragment of UFLIA. The approach bridges the gap between decidable special cases and purely heuristic methods, opening new avenues for verification tools that require both scalability and verifiable correctness.

\bibliographystyle{abbrv}
\bibliography{refs}

\appendix

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
