\documentclass{llncs}
\usepackage[textwidth=3cm,tickmarkheight=3pt]{todonotes}
\usepackage[utf8]{inputenc}
\usepackage{amssymb, amsmath}
\usepackage{numprint}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\usepackage{color}
\definecolor{citeblue}{rgb}{0.1,0,.4}
\usepackage[pdftex%
,colorlinks=true%
,bookmarks=true%
,linkcolor=citeblue%
,citecolor=citeblue%
,urlcolor=blue%
,plainpages=false]{hyperref}
\hypersetup{colorlinks,citecolor=blue,linkcolor=blue,urlcolor=blue}
\AtBeginDocument{\hypersetup{pdfborder={0 0 1}}}
\usepackage[nameinlink,capitalize,noabbrev]{cleveref} % must come after hyperref
\usepackage{commath}
\usepackage[most]{tcolorbox}
\usepackage{enumitem}
\usepackage{orcidlink}

\usepackage{accents} % for \ubar
\newcommand{\ubar}[1]{\underaccent{\bar}{#1}}
\newcommand{\sygus}{SyGuS\xspace}
\newcommand{\qedhere}{$\blacksquare$}

\renewcommand{\algorithmicrequire}{\textbf{Input:}}
\renewcommand{\algorithmicensure}{\textbf{Output:}}

%\newtheorem{definition}{Definition}
%\newtheorem{property}{Property}
%\newtheorem{example}{Example}

%\newtheorem{theorem}{Theorem}
%\newtheorem{lemma}[theorem]{Lemma}
%\newtheorem{corollary}[theorem]{Corollary}
%\theoremstyle{remark}
%\newtheorem{claim}{Claim}
\usepackage{etoolbox}
%\AtEndEnvironment{proof}{\setcounter{claim}{0}}

\npthousandsep{,}
\newcommand{\gmodel}{\mathcal{M}}
\newcommand{\smt}{\textsc{smt}}
\newcommand{\args}{\text{args}}
\usepackage{xspace}
\newcommand{\req}{\emph{ReqPivot}\xspace}
\newcommand{\subst}[3]{#1[#2\leftarrow #3]}
\newcommand{\repr}[1]{\hat{#1}}

\newcommand{\todoSR}[1]{\todo[color=blue!40]{#1}}
\newcommand{\mj}[1]{\todo[color=green!30]{#1 -mik}}
\newcommand{\marek}[1]{\todo[color=red!10]{#1 -MD}}
\newcommand{\todoSN}[1]{\todo[color=orange!50]{#1 -SN}}

\title{Proving Satisfiability of\\Universally Quantified Integer Constraints with\\ Uninterpreted Function Symbols%
   \todoSN{We will change this title. For the affiliation, I'm not sure what to put for Mikoláš and Marek.} \todoSN{Title options: ``Inductive Cell Propagation for Quantified UFLIA" or ``Deciding UFLIA with Offset Constraints through Inductive Propagation" or ``Cell Propagation Certificates: A Decision Procedure for Offset-Restricted UFLIA"}
    }

% \author{Stefan Ratschan \and Anggha Nugraha \and Mikoláš Janota \and Marek Dančo}
\author{Stefan Ratschan\inst{1}\orcidlink{0000-0003-1710-1513} \and
Anggha Nugraha\inst{1,2}\orcidlink{0000-0002-7139-4487} \and
Mikoláš Janota\orcidlink{0000-0003-3487-784X} \and 
Marek Dančo\orcidlink{0009-0008-3031-113X}}
%
\authorrunning{F. Author et al.}
% First names are abbreviated in the running head.
% If there are more than two authors, 'et al.' is used.
%
\institute{Institute of Computer Science, The Czech Academy of Sciences,
Prague, Czech Republic \\
\email{stefan.ratschan@cs.cas.cz} \and 
Faculty of Information Technology, Czech Technical University in Prague,
Prague, Czech Republic \and }

\begin{document}
\maketitle

\begin{abstract}
For abstract.
\keywords{First keyword  \and Second keyword \and Another keyword.}
\end{abstract}


\section{Introduction}

\marek{Mention these \cite{bradley-manna07,bradley-vmcai06,ge-cav09,habermehl-etaps08}}

Current SMT solvers have limited capabilities to produce counterexamples for complex systems. Yet, counterexamples are important during modeling as they uncover  errors. For example, a user may wrongly assume that an input stream with increasing values will contain two equal consecutive values. Negating and skolemizing this assumption yields the simple UFLIA formula:
\begin{equation}
	f(0)\neq f(1)\land\forall x:\mathbb{Z}.\,f(x)<f(x+1)
\end{equation}

While this formula has trivial counter-models (e.g. $f$ being the identity function), and such solutions can be found by synthesis approaches like \sygus, it is easy to get out of the reach of these tools because they are primarily based on templates and candidate-solution enumeration. The following modification is no longer solved by cvc5~\cite{cvc5} in its \sygus mode.

\begin{equation}\label{eq:periodic}
	f(0)\neq f(1)\land\forall x:\mathbb{Z}.\,f(x)=f(x+2)
\end{equation}

These constraints allow only periodic functions whose neighboring values alternate. For such functions the \sygus grammar would have to guess an \textit{ite} term of the form $\mathit{ite}(x\,\mathit{mod}\,2 = 0\enspace a\enspace b)$, for integers $a \not = b$. Even if \sygus tools were improved, they could not yield a decision procedure for full UFLIA due to the inherent undecidability of integer arithmetic combines with uninterpreted functions.

\paragraph{What We Solve.} We therefore isolate a relevant fragment of UFLIA where formulas like~\eqref{eq:periodic} become decidable. In this fragment, arguments of uninterpreted functions within quantified subformulas are restricted to terms of the form $x + t$, where $x$ is the universally quantified variable and $t$ is a ground term. Such formulas frequently arise in verification conditions for programs with arrays, recursive functions, or inductive data structures.

\paragraph{How We Solve It.} Our approach is based on \emph{inductive cell propagation}. We view each quantifier instantiation as imposing constraints on \emph{cells}—terms $f(n_1,\dots,n_k)$ with integer arguments. The key insight is that if we can: 1) Find a finite interval $[b_{\min}, b_{\max}]$ where all instantiations are simultaneously satisfiable, and 2) Ensure that from this base, solutions can be \emph{propagated} outward in both directions without conflicts, then the entire universally quantified formula is satisfiable. This reduces the infinite satisfiability problem to checking two finite conditions: base satisfiability and a propagation property formalized as the \emph{multi-ReqPivot condition}.

% The key idea is to treat each quantifier instantiation as introducing infinitely many constraints on function calls, which we refer to as cells. A single cell may appear in multiple constraints, so we must ensure that it is assigned a consistent value throughout. To show satisfiability within our fragment, we impose an order on these constraints and construct a symbolic assignment to the cells such that, when processed in this order, no conflicting assignments arise.

\paragraph{Contributions.} 
This paper makes several contributions towards deciding satisfiability in our fragment. We formalize \emph{cell propagation certificates} (\cref{def:certificate}) that witness satisfiability through inductive extension of finite base assignments.  We introduce the \emph{multi-\req condition} (\cref{def:multi-reqpivot-param}), propagation conditions that allows multiple functions to serve as pivots simultaneously. Building on this, we present an interval‑based algorithm (\cref{alg:interval-check-param-withBigvee}) that searches for suitable base intervals and checks propagation conditions using satisfiability queries. We prove \emph{soundness} (\cref{cor:soundness-bigvee}) and \emph{relative completeness} (\cref{thm:completeness-bigvee}) for our algorithm. Finally\todoSN{Hopefully!}, we provide experimental evidence that our method handles problems beyond the reach of current SyGuS and MBQI approaches, often producing more interpretable models.

% \section{Related Work}\label{}
% Synthesis of recursive functions by Hozzov\'a et al.~\cite{hozzova-ijcar24}.
% Synthesis of strategies on LIA problems Murphy and Kincaid~\cite{kincaid-cav24}.
% Synthesis, single invocation Kun\v cak et
% al.~\cite{kuncak-pldi10,kuncak-sttt13}.

% Array decision procedures~\cite{bradley-vmcai06}: no arithmetic on universally quantified variables allowed.
% Habermehl et al.~\cite{habermehl-etaps08} allow difference bounded constraints on array offsets of the form $a[i+c]$. From the MBQI paper: ``For certain cases containing offsets on array indices, our procedure will result in an infinite set of instantiations, while a decision procedure of LIA\footnote{LIA does not refer to linear integer arithmetic, but to the logic allowed by Habermehl et al.}  will terminate. It leaves an open question for future research on how to reason about this type of formulas within an instantiation-based approach.''

% Alberti et al.~\cite{alberti2014decision}: only one universally quantified variable allowed.
% Elad et al.~\cite{elad2024infinite}: The fragment of FOL for which they prove decidability (OSC, Section~6) does not allow anything like integer arithmetic.

% \cite{reynolds2016model}: needs to user to ensure admissibility (Definition~2), the underlying finite model finding algorithm~\cite{reynolds2013finite} may introduce many case splits (``merge lemmas'') for satisfying cardinality constraints. \todoSR{I added a few words here}

% computer algebra algorithms for solving difference equations

% \subsection{What Can't the Previous Work Solve?}

% Here, I am considering the works~\cite{bradley-vmcai06,ge-cav09,habermehl-etaps08}.

% \paragraph{Infinitely Increasing But Bounded Integer Sequence}

% \[
% 	\forall{x}. \,f(x)<0 \,\land \,\forall{x}. \,f(x)<f(x+1)
% \]

% The syntax in~\cite{habermehl-etaps08} includes $\leq$ but does not include $<$. It does include negation though, but only if it
% results in the quantified variables being existential. This cannot be solved by~\cite{bradley-vmcai06} (see Theorem 4 in their paper).
% \textsc{Z3} cannot solve this on its own but with the addition of Lemma~\ref{eq:ind-needed-lemma} it can. Adding the lemma also helps Vampire but not \textsc{cvc5}.

% \paragraph{Two-Valued Constant Function}

% \[
% 	f(0) = 0 \,\land \,f(c) = 3 \,\land \,\forall{x}. \,f(x+1) = f(x)
% \]

% In the last meeting I hand-wavedly assumed this cannot be in the fragment of~\cite{habermehl-etaps08}.
% However, it is. They accept the literals $f(x) - f(x+1) \leq 0$ and $f(x+1) - f(x) \leq 0$, which in conjunction simplify
% to $f(x) = f(x+1)$. They can then universally quantify this to form an array property. The other equalities can
% be formed as value expressions $A \leq B \,\land \,B \leq A$. I can look more thoroughly at the paper
% to see how can they solve this.
% This cannot be solved by~\cite{bradley-vmcai06}, because the
% third conjunct contains $x+1$ as an argument of $f$ (Theorem 4 in their paper).
% \textsc{Z3} cannot solve this -- Compactness section in~\cite{ge-cav09}.

\section{Related Work}\todoSR{potentially relevant PC members: Reynolds, Barrett, Tinelli, anybody else}

Our work intersects several areas of automated reasoning: synthesis, decision procedures for arrays, and model-based quantifier instantiation.

\paragraph{Synthesis approaches.}
Syntax-Guided Synthesis (SyGuS) \cite{cvc5} enumerates candidate functions from a grammar. While powerful for template-matching problems, it fails on formulas requiring non-template solutions like periodic functions (Equation~\ref{eq:periodic}). Kunčak et al. \cite{kuncak-pldi10,kuncak-sttt13} introduces single-invocation synthesis. Hozzová et al. \cite{hozzova-ijcar24} synthesize recursive programs from constraints.

\paragraph{Decision procedures for arrays and quantified formulas.}
Bradley et al. \cite{bradley-vmcai06} present a decision procedure for array properties but explicitly forbid arithmetic on the universally quantified variables. Habermehl et al. \cite{habermehl-etaps08} allow constraints of the form $a[i+c]$ with difference bounds, but remain limited to offset-bounded indices. Alberti et al. \cite{alberti2014decision} consider only one universally quantified variable. Elad et al. \cite{elad2024infinite} prove decidability for a first‑order fragment without arithmetic, unable to express our constraints.

\paragraph{Model-based and instantiation methods.}
Reynolds et al.~\cite{reynolds2016model,reynolds2013finite} develop finite model finding techniques for quantified formulas. Their method requires users to ensure admissibility and may introduce many case splits (``merge lemmas'') to satisfy cardinality constraints. Ge and de Moura \cite{ge-cav09} introduce the Model-Based Quantifier Instantiation (MBQI) but noting that ``For certain cases containing offsets on array indices, our procedure will result in an infinite set of instantiations, while a decision procedure of LIA\footnote{LIA refers to the logic of Habermehl et al.} will terminate. It leaves an open question for future research on how to reason about this type of formulas within an instantiation-based approach.'' Our work attempts to  address this open question.

\paragraph{Computer algebra.}\todoSN{No explanation in the previous version.}
Computer algebra algorithms for solving difference equations

\paragraph{Limitations illustrated.}\todoSN{In the previous version, there is a sentence: ``Here, I am considering the works~\cite{bradley-vmcai06,ge-cav09,habermehl-etaps08}." }
To see where existing methods fall short, consider:
\begin{itemize}
    \item \textbf{Infinitely increasing bounded sequence:} $\forall x.\, f(x) < 0 \land \forall x.\, f(x) < f(x+1)$. 
    Habermehl et al.'s fragment excludes strict inequalities. It does include negation, but only if it results in the quantified variables being existential. Bradley et al. forbid $x+1$ as an argument (Theorem 4 in \cite{bradley-vmcai06}). \textsc{Z3} cannot solve this on its own\todoSN{In the previous version, there is ``but with the addition of Lemma~\ref{eq:ind-needed-lemma} it can. Adding the lemma also helps Vampire but not \textsc{cvc5}."}. 
    \item \textbf{Two‑valued constant function:} $f(0) = 0 \land f(c) = 3 \land \forall x.\, f(x+1) = f(x)$.
    \todoSN{I didn't change anything here.} In the last meeting I hand-wavedly assumed this cannot be in the fragment of~\cite{habermehl-etaps08}. However, it is. They accept the literals $f(x) - f(x+1) \leq 0$ and $f(x+1) - f(x) \leq 0$, which in conjunction simplify to $f(x) = f(x+1)$. They can then universally quantify this to form an array property. The other equalities can be formed as value expressions $A \leq B \,\land \,B \leq A$. I can look more thoroughly at the paper to see how can they solve this. This cannot be solved by~\cite{bradley-vmcai06}, because the third conjunct contains $x+1$ as an argument of $f$ (Theorem 4 in their paper).
\textsc{Z3} cannot solve this -- Compactness section in~\cite{ge-cav09}.
\end{itemize}

These examples demonstrate the need for a method that handles arithmetic offsets while providing finite certificates for satisfiability.

\section{Problem Statement}
\label{sec:problem-statement}
\todoSN{Should we instead move this section to before Related Work? Also, is the current version too long?}

\paragraph{Formula Class}
We study formulas of the form
\begin{equation}\label{eq:main-fragment}
    F \land \forall x.\; Q%\bigl(f_1(x+t^{f_1}_1),\dots,f_1(x+t^{f_1}_{l_1}),\;\dots,\;f_r(x+t^{f_r}_1),\dots,f_r(x+t^{f_r}_{l_r})\bigr),
\end{equation}
where
\begin{itemize}
    \item $F$  and $Q$ are quantifier‑free formulas in the SMTLIB theory UFLIA of uninterpreted function symbols and linear integer arithmetic,
%    \item $f_1,\dots,f_r$ are distinct uninterpreted function symbols,
%    \item for each $f_i$, the \emph{offset terms} $t^{f_i}_1,\dots,t^{f_i}_{l_i}$ are pairwise distinct LIA ground terms, and
    \item all uninterpreted function symbols have maximal arity $1$\todoSR{Section~\ref{sec:certificate} does not require this. It would also be not too difficult to generalize that section to several quantified variables.}
    \item all arguments of uninterpreted function symbols in $Q$ are either of the form $x$ or of the form $x+t$ where $t$ is a ground term.
    \end{itemize}

    \begin{example}
      \[f(0)=0 \wedge \forall x \,.\, f(x+c)=f(x)+c+1,\]
      where $c$ is an uninterpreted constant.
    \end{example}

\paragraph{Core Problem}
Given a formula $\phi$ of the form~\eqref{eq:main-fragment}, the problem we address is:
\begin{quote}
    \emph{Decide whether $\phi$ is satisfiable over the standard integers, and if so, construct a model (an interpretation of all uninterpreted function symbols) that satisfies $\phi$.}
\end{quote}

\paragraph{Why is this Hard?}\todoSN{Not sure about this part! I'm just trying to summarize it from what's written in the Intro and Related Work sections.}
Although UFLIA is undecidable in general, formulas of the above form constitute a fragment that appears frequently in verification conditions (e.g. for programs with arrays or recursive functions). Yet, existing SMT techniques struggle:
\begin{itemize}
    \item \textbf{Finite instantiation} may not terminate because the universal quantifier ranges over the infinite domain $\mathbb{Z}$.
    \item \textbf{Synthesis-based approaches} (SyGuS) rely on syntactic templates and fail when the required function does not match the template.
    \item \textbf{Model-based quantifier instantiation (MBQI)} can sometimes find models but often produces large, uninterpretable assignments and scales poorly.
    \item \textbf{Specialized array decision procedures} either forbid arithmetic on indices or are limited to difference‑bounded constraints.
\end{itemize}
The presence of both arithmetic constraints and uninterpreted functions, combined with the universal quantifier, makes this fragment challenging for current solvers.

\paragraph{Scope and Limitations}
We make the following additional assumptions about the structure of the formulas:
\begin{enumerate}
    \item For each uninterpreted function $f$, the set of offset terms $\{t \mid f(x+t) \text{ occurs in } Q\}$ is finite and consists of ground terms.
    \item We do not allow nested applications of uninterpreted functions (e.g., $f(g(x))$ is excluded).
    \item We do not consider multiple universal quantifiers over different variables or existential quantification over functions.
\end{enumerate}
These restrictions enable the inductive reasoning that underlies our solution, while still covering many practical verification conditions. The technical details of our solution—how we detect satisfiability, what propagation conditions we require, and how we construct models—are presented in the following sections.

% \paragraph{Expected Outcomes}
% For formulas within this fragment, we aim to provide:
% \begin{itemize}
%     \item A \emph{sound} decision procedure: if the procedure returns \textsc{Sat}, the formula is indeed satisfiable.
%     \item A \emph{relatively complete} procedure: for a large subclass (characterized by a propagation condition), the procedure will terminate and return the correct answer.
%     \item Constructive models: when the formula is satisfiable, the procedure should produce an explicit interpretation of the uninterpreted functions.
% \end{itemize}


    
% \paragraph{Core Problem}
% Given a formula $\phi$ of the form~\eqref{eq:main-fragment}, we want to decide its satisfiability over the standard integers. Because the quantifier ranges over the infinite set $\mathbb{Z}$, a na\"ive instantiation‑based approach may not terminate. Instead, we aim to reduce the problem into checking two conditions on a finite interval $B = [b_{\min}, b_{\max}]$:

% \begin{enumerate}
%     \item \textbf{Base satisfiability:} $F \land \bigwedge_{z \in B} Q[z]$ is satisfiable (where $Q[z]$ denotes $Q$ with $x$ replaced by the numeral $z$).
%     \item \textbf{Propagation:} From a model of the base interval, we can extend the assignment to all integers $z \notin B$ without creating any conflicts. This requires that for each function $f_i$, certain occurrences in $Q$ can be treated as ``pivots'' whose values can be chosen after fixing all other occurrences.
% \end{enumerate}

% The second condition is formalized as the \emph{multi‑\req condition} in \cref{sec:alg}. Intuitively, it ensures that when moving outward from $B$ (to larger or smaller integers), we always have at least one cell in each instantiation whose value can be adjusted to satisfy $Q$, given the values already assigned to cells that appear in earlier instantiations.

% \paragraph{Challenges}\todoSN{Stefan R, could you please check whether I formulate this paragraph (and the next one) correctly?}
% \begin{itemize}
%     \item \textbf{Detecting propagability:} How can we automatically check whether a formula $Q$ satisfies the required pivot condition?
%     \item \textbf{Finding a suitable base interval:} The interval $B$ must be large enough to avoid clashes between cells generated during propagation and cells that appear in the ground part $F$.
%     \item \textbf{Completeness:} Under what conditions does the existence of a finite base interval together with propagation guarantees imply satisfiability? Conversely, when can unsatisfiability be detected finitely?
% \end{itemize}

% \paragraph{Our Contributions}
% We address these challenges through the following steps:
% \begin{enumerate}
%     \item We introduce \emph{cell propagation certificates} (Definition~\ref{def:certificate}) as a formal witness for satisfiability in our fragment.
%     \item We define the \emph{multi‑\req condition} (Definition~\ref{def:multi-reqpivot-param}) that characterizes when propagation is possible.
%     \item We prove that if a formula satisfies the multi‑\req condition and a suitable base interval exists, then the formula is satisfiable (Theorem~\ref{thm:interval-certificate-param}).
%     \item We present an algorithm (Algorithm~\ref{alg:interval-check-param-withBigvee}) that enumerates candidate intervals and checks both base satisfiability and propagation conditions using an $\smt$ solver.
%     \item We establish soundness and relative completeness theorems for our algorithm (Corollary~\ref{cor:soundness-bigvee} and Theorem~\ref{thm:completeness-bigvee}).
% \end{enumerate}


\section{Notation}\todoSR{We will see where to put this, in the end}

We will write $\subst{s}{v}{t}$ for the result of substituting the term $t$ for $v$ in the term~$s$. For an integer $z\in\mathbb{Z}$, we will denote the constant representing $z$ in a logical formula by $\repr{z}$\todoSR{Does there exist some standard notation for this?}.

For a formula $F$ and uninterpreted function symbol $f$, $args(F, f)$ will denote the set of argument terms of $f$ in $F$.

Include information on well-orders and induction on well-orders, here?

We use SMT terminology (which differs from classical logic by being typed, and defining notions such as satisfiability in a slightly different way).


\section{Satisfiability Certificates}
\label{sec:certificate}


\todoSR{I intend to add a running example and a figure}

In this section, we will define objects that certifies that a formula in the form defined in~\cref{sec:problem-statement} is satisfiable. In the next section, will then introduce an algorithm for compute such certificates.

Traditionally, satisfiability of a logical formula is certified by an interpretation that assigns a value to each non-logical symbol in such way that the formula is true. However, the set of integers is infinite. Due to this,  the interpretation of an uninterpreted function symbol with integer domain is a function that assigns values to the infinitely many integers that form this domain. This opens the question of how to represent such a function using a finite object that can be represented on computers.

Our approach will not assign values to the whole infinite domain of uninterpreted function symbols in one step, but to each individual element of this domain:
\begin{definition}[Cell]\label{def:cell}
	A \emph{cell} is a term of the form $f(n_1,\dots, n_k)$ where $f$ is an uninterpreted function symbol and $n_1,\dots, n_k$ are integers.
\end{definition}
Examples of cells are $c$, and $f(7)$. The term $f(c+7)$ is not a cell.

\begin{definition}[Cell Interpretation]
	A \emph{cell interpretation} is a partial function whose domain is the set of cells. A cell interpretation $I$ is \emph{compatible} with an interpretation $\mathcal{I}$ iff $I$ and $\mathcal{I}$ agree on all cells where $I$ is defined.
\end{definition}

Given a cell interpretation $I$, we denote by $\mathit{def}(I)$ the set of cells for which $I$ is defined. Given a term $t$ and a cell interpretation $I$  we define $I(t):=\mathcal{I}(t)$, if  $\mathcal{I}(t)$ is unique for every interpretation $\mathcal{I}$ compatible with $I$, and otherwise $I(t):=\bot$.
For example, for $I=\{ f(0) \mapsto 7 \}$, $I(f(0))=7$, but $I(f(1))=\bot$. Also note that $I(f(1)-f(1))=0\neq\bot$. In a similar way, for a formula $\phi$, we define that a cell interpretation~$I$ satisfies $\phi$ iff for every interpretation $\mathcal{I}$ compatible with $I$, $\mathcal{I}$ satisfies $\phi$, in which case we also write $I\models \phi$.

In order to allow a computer representation of cell interpretations, we will always work with cell interpretations that are only defined on finitely many cells. However, we will want that at least those cells are defined, that allow us to check satisfaction of parts of formulas without quantifiers, and that for all universally quantified parts and instantiations of the universal quantifier, allow us to determine the value of all arguments of uninterpreted function symbols.

\begin{definition}
	\label{def:pre-sat-cert}
	Given a formula $\phi$ of the form $F\wedge \forall x\;.\; Q$, we call a cell interpretation $I$ such that
        \begin{itemize}
        \item $I\models F$, and
        \item for all $z\in\mathbb{Z}$, for every uninterpreted function symbol~$f$ and its argument terms $t\in args(Q, f)$, $I(\subst{t}{x}{\repr{z}})\neq\bot$
        \end{itemize}
 a \emph{pre-satisfiability certificate} of $\phi$. For any $z\in\mathbb{Z}$, we denote by $\Gamma_{I,z}(\phi)$ the resulting set of cells \[\{ f(I(\subst{t}{x}{\repr{z}})) \mid t\in args(Q, f), f \emph{ is an uninterpreted function symbol}\}.\]
\end{definition}
For example, $I=\{ c\mapsto 5 \}$ is a pre-satisfiability certificate of $c\geq 5 \wedge \forall x \;.\; f(x+c+1)= f(x+c)+1$, and $\Gamma_{I,10}(\phi)=\{ f(15), f(16)\}$.

Given a pre-satisfiability certificate, we can now certify the advisability of formulas by propagating the values given by a pre-satisfiablity certificate in such a way that for each value of the universally quantified variables, the corresponding quantified sub-formula holds.
\begin{definition}
	\label{def:certificate}
	Given a formula $\phi$  of the form $F\wedge \forall x\;.\; Q$, a \emph{satisfiability certificate}\todoSR{I changed the name back to emphasize the \emph{what} over the \emph{how}} is
	\begin{itemize}
        \item a pre-satisfiability certificate $I$ of $\phi$,
		\item a well-order $\preceq$ on $\mathbb{Z}$,%\footnote{A well-order total order for which every non-empty subset has a least element. This enables induction. If we want to allow sub-formulas to be at the same place in the order, we either need to combine them into equivalence classes, or relax anti-symmetry (i.e., work with a pre-wellorder).}
		\item for every $z\in\mathbb{Z}$
                  \begin{itemize}
                  \item a set $X_z\subseteq \Gamma_{I,z}(\phi)$  (the \emph{propagated cells}) such that \[X_z\cap (\mathit{def}(I)\cup\bigcup_{z'\prec z} \Gamma_{I,z'}(\phi))=\emptyset,\] and
                    %that are neither assigned a value by $I$, nor occur in any $\Gamma_{I,z'}(\phi)$ for any $z'\prec z$
                  \item a certificate (the \emph{satisfiability propagator}) showing that for all values of cells in $\Gamma_{I,z}(\phi)\setminus \mathit{def}(I)\setminus X_z$ there exist values for the cells in $X_z$ such that for the cell interpretation $I_{X_z}$ assigning these values to $X_z$, $I\cup I_{X_z}\models \subst{Q}{x}{\repr{z}}$.
                  \end{itemize}

	\end{itemize}
\end{definition}

For the sake of generality, the satisfiability propagator only shows existence of values for the propagated cells. At this point we do not require it to be constructive. Still, below we will work with algorithms computing actual values. In addition, the definition allows infinitely many different sets of propagated cells and satisfiability propagators. In practice, for allowing computer representation, we will only work with finitely many different ones.

Also note that for $z\in\mathbb{Z}$ such that $\Gamma_{I,z}(\phi)\subseteq \mathit{def}(I)$, the definition requires the set of propagated cells $X_z$ to be empty. As a consequence, for such $z$, the satisfiability propagator only needs to certify that $I\models \subst{Q}{x}{\repr{z}}$. In other words, the cell interpretation~$I$ serving as a pre-satisfiability certificate already plays the role of the satisfiability propagator. 

\begin{property}\label{prop:certThenSat}
	Every formula formula $\phi$  of the form $F\wedge \forall x\;.\; Q$ that has a satisfiability certificate is satisfiable.
\end{property}

\begin{proof}
	Assume a formula of the given form and assume that it  has a satisfiability certificate.
	The corresponding pre-satisfiability certificate $I$ satisfies the quantifier free part~$F$ of $\phi$.

We start by showing
 that for every $z\in\mathbb{Z}$ there is an extension $I'$ of $I$ such that $I'$ satisfies all quantifier instantiations occurring before $z$ wrt. the order $\preceq$, that is,  $I'\models\{ \subst{Q}{x}{\repr{z}'} \mid z'\preceq z\}$. For this we use the principle of induction on well-orders: Let $z\in\mathbb{Z}$, and let $\Phi$ be $\{ \subst{Q}{x}{\repr{z}'} \mid z'\prec z\}$. We assume that there is an extension $I_{\Phi}$ of $I$ with $I_{\Phi}\models\Phi$, and prove that there is an extension $I'$ of $I$ with $I'\models\Phi\cup \{ \subst{Q}{x}{\repr{z}}\}$. Since the formula has a satisfiability certificate, the propagated cells of $\subst{Q}{x}{\repr{z}}$ do not occur in any element of $\Phi$. Let $I'$ be the extension of $I_{\Phi}$ that assigns to the propagated cells $X_z$ the values whose existence is  confirmed by the satisfiability propagator. Since these do not occur in $\Phi$, $I'$ and $I_{\Phi}$ coincide on cells occurring in $\Phi$. Hence $I'$ satisfies both $\Phi$ and $\subst{Q}{x}{\repr{z}}$, and so it satisfies $\Phi\cup \{ \subst{Q}{x}{\repr{z}}\}$.

	Now denote for every $z\in\mathbb{Z}$ the cell interpretation  satisfying $\subst{Q}{x}{\repr{z}}$ as constructed in the previous paragraph by $I_z$.
	% From the well-order $\prec$ we get a corresponding well-order on these cell interpretations.
	% Let $I_{\phi}$ be the cell interpretation that, for any cell $u$, assigns the value to $u$ that $I_{z}$ assigns to it for the smallest $z$ (wrt. $\prec$) that assigns a value to $u$. This smallest $z$ exists, since $\prec$ is a well-order. The cell interpretation $I_{\phi}$ satisfies $\phi$, and any classical interpretation compatible with the values assigned by $I_{\phi}$ satisfies $\phi$, as well.
Observe that for every cell~$u$, and for all~$z, z'\in \mathbb{Z}$ with $I_z(u)\neq \bot$ and $I_{z'}(u)\neq \bot$, $I_z(u)=I_{z'}(u)$.      Let $I_\phi$ be the assignment that, for any cell $u$, if there is a $z$ such that $I_z(u)\neq \bot$, then $I_\phi(u)=I_z(u)$, and otherwise $I_\phi(u)=0$. Certainly $I_\phi\models F$. Moreover, for every $z\in\mathbb{Z}$,  $I_\phi\models  \subst{Q}{x}{\repr{z}}$, since $I_\phi$ coincides with $I_z$ for all elements, where it is defined. Hence  $I_\phi\models \phi$.
\qedhere\end{proof}

A satisfiability certificate only shows that a formula is satisfiable. It does not provide concrete values of the corresponding model. We now show how to compute such values from a given satisfiability certificate containing a pre-satisfiability certificate $I$. For this, we require the satisfiability propagators to be constructive. So, for $z\in\mathbb{Z}$ and for each $u\in X_z$ we assume a function $prop_{u,z}$ such that for
a cell interpretation $I'$ with $\mathit{def}(I')=\Gamma_{I,z}(\phi)\setminus \mathit{def}(I)\setminus X_z$, $I\cup I'\cup \{ u \mapsto prop_{u,z}(I\cup I') \mid u\in{X_z}\}\models\subst{Q}{x}{\repr{z}}$.
 
% for any $\hat{v}_1,\dots,\hat{v}_r$, the cell interpretation
% \[\{ v_1\mapsto \hat{v}_1,\dots,v_r\mapsto \hat{v}_1, u_1\mapsto  prop_{u_1}(\hat{v}_1,\dots, \hat{v}_r),\dots, u_s\mapsto prop_{u_s}(\hat{v}_1,\dots,\hat{v}_r)\} \] satisfies $\psi$

% For any instantiation $\psi$ of a quantified sub-formula with propagated cells $u_1,\dots, u_s$ and non-propagated cells $v_1,\dots, v_r$, the satisfiability propagator defines  functions $prop_{u_1},\dots, prop_{u_s}$ such that for any $\hat{v}_1,\dots,\hat{v}_r$, the cell interpretation
% \[\{ v_1\mapsto \hat{v}_1,\dots,v_r\mapsto \hat{v}_1, u_1\mapsto  prop_{u_1}(\hat{v}_1,\dots, \hat{v}_r),\dots, u_s\mapsto prop_{u_s}(\hat{v}_1,\dots,\hat{v}_r)\} \] satisfies $\psi$. In many cases, these functions can be synthesized automatically from the corresponding quantifier elimination problem~\cite{kuncak-sttt13}.\marek{Is \cite{kuncak-sttt13} applicable in our case too?}


Now, observe that for any cell $u$ there is at most one $z\in\mathbb{Z}$ with $u\in X_z$ (if there would be more than one then, due to $\preceq$ being a well-order, there is a minimal one, let us say $z_{\min}$, and then, for any $z'\succ z$, the requirements on $X_{z'}$ exclude the possibility of $X_{z'}$ containing $u$, as well). So for any cell $u$, let $\mathit{inst}(u)$ either be the $z\in\mathbb{Z}$ with $u\in X_z$ or $\bot$ if there is no such instantiation.

Then, for the assignment $I_\phi$ from the proof of Property~\ref{prop:certThenSat}, which satisfies a given formula~$\phi$, and a given cell~$u$, the value of $I_\phi(u)$ can be computed by the following recursive function $val(u)$:
\begin{tabbing}\hspace*{0.4cm}\=\hspace*{0.4cm}\=\kill
	\textbf{if} $I$ assigns a value $x$ to $u$ \textbf{then} \textbf{return} $x$\\
	\textbf{if} $\mathit{inst}(u)=\bot$ \textbf{then} \textbf{return} 0\\
	\textbf{return} $prop_{u,\mathit{inst}(u)}(I\cup \{ v\mapsto val(v) \mid v\in \Gamma_{I,\mathit{inst}(u)}(\phi)\setminus \mathit{def}(I)\setminus X_z\})$
\end{tabbing}

Here, the recursive calls go down the order $\prec$ in the following sense:
\begin{property}
	Let $u$ be a cell such that $\mathit{inst}(u)\neq\bot$. Then for any $v\in\Gamma_{I,\mathit{inst}(u)}(\phi)\setminus \mathit{def}(I)\setminus X_z$ with $\mathit{inst}(v)\neq\bot$, $\mathit{inst}(v)\prec \mathit{inst}(u)$.
\end{property}

So each recursive call of the program $val$ either results in $\mathit{inst}(u)$ either decreasing or being $\bot$. In the latter case, the program terminates immediately, and the former case cannot happen infinitely often, since the used order is well-founded. So we have:
\begin{property}
The program $val$ terminates.
\end{property}

Note that, in general, it is not possible to compute $val(u)$ by computing the values of $X_z, z \in \mathbb{Z}$, with $z$ being initialized with the minimal $z$ wrt. $\prec$, and then using a loop that increases $z$ from one successor wrt. $\prec$ to the next. For example, if  $\prec$  orders all even numbers before all odd ones, then this loop would have to iterate over infinitely many even numbers before computing the value of an odd one.
     

The goal is now an algorithm that computes such satisfiability certificates and a converse of the property that shows for certain classes of satisfiable  formulas this algorithm succeeds.

\section{Algorithm}\label{sec:alg}

% Class of formulas:
% \[ F\wedge \forall x\;.\; Q(f_1(x+t^{f_1}_1),\dots,f_1(x+t^{f_1}_{l_1}),\dots,f_r(x+t^{f_r}_1),\dots,f_r(x+t^{f_r}_{l_r})),\]
% where $F$ is quantifier free, for every $i\in \{1,\dots,r\}$, and the  $t^{f_i}_{1},\dots,t^{f_i}_{l_i}$ are pairwise different LIA ground terms

In this section, we will introduce an algorithm that will check satisfiability of an input formula by computing a satisfiability certificate of a certain form. This certificate will explicitly certify satisfiability of the quantifier free part $F$, and of a finite interval $B = [b_{\min}, b_{\max}]$ of instantiations of the quantified part $Q$. It will certify satisfiability of the quantified part outside of the interval $B$ using the satisfiability propagator and an order that goes upward from $b_{\max}+1$, and downward from $b_{\max}-1$. We will show soundness of the algorithm and completeness relative to conditions that ensure that such propagation outward from a base interval $B$ is possible.
\todoSR{I wrote this to better connect this section to the previous one}

Throughout this section we assume that $\phi$ is a formula of the form   $F \land \forall x.\; Q$, as defined in Section~\ref{sec:problem-statement}, with $f_1, \dots, f_r$ being the uninterpreted function symbols appearing in $Q$, with the arguments of $f_i$ being of the form $x+t^{f_i}_1, \dots, x+t^{f_i}_{l_i}$. We denote the set of \emph{offsets} $t^{f_i}_1, \dots, x+t^{f_i}_{l_i}$ by $T_i$.



% The core idea of the algorithm is to search for the interval $B = [b_{\min}, b_{\max}]$ from which a model can be inductively extended to all integers. This requires two components:
% \begin{enumerate}
%     \item A method to check whether a given interval $B$ can serve as a suitable base (satisfying both ground constraints and all instantiations within $B$).
%     \item A propagation condition ensuring that from such a base, we can consistently assign values to cells outside $B$ without conflicts.
% \end{enumerate}



% Our algorithm relies on the ability to propagate solutions outward from a base interval. We first formalize the propagation condition as the \emph{multi-\req condition}, then show how to combine it with interval expansion to obtain a complete decision procedure. 

We will now formalize the condition ensuring propagation outward from a base interval $B$ is possible.
 For upward propagation, we select for each function $f_i$ a subset $S_i$ of its offsets that are maximal (all equal and strictly greater than other offsets of $f_i$). The propagability condition then guarantees that, no matter what values are assigned to the non‑maximal occurrences, we can find values $v_1,\dots,v_r$ such that assigning $v_i$ to all occurrences $f_i(x+t)$ with $t\in S_i$ makes $Q$ true. Different functions may receive different values.  The downward condition is symmetric.

\begin{definition}[Multi-\req Condition]
\label{def:multi-reqpivot-param}

For any choice of subsets $\mathcal{S} = (S_1,\dots,S_r)$ with $S_i \subseteq T_i$, define:
\begin{itemize}
    \item \textbf{Maximality condition $\Phi_{\text{max}}(\mathcal{S})$:}
        \[
        \bigwedge_{i=1}^{r} \left(
        \bigwedge_{t,t' \in S_i} t = t' \;\land\;
        \bigwedge_{t \in S_i, t' \in T_i \setminus S_i} t > t'
        \right).
        \]
    \item \textbf{Upward propagability condition $\Phi_{\text{prop-up}}(\mathcal{S})$:}\\
        \[\forall x \forall \bar{u}_1 \dots \forall \bar{u}_r \exists v_1\dots \exists v_r.\ Q'(\mathcal{S})\] where  $Q'(\mathcal{S})$ is the formula obtained from $Q$ by simultaneously replacing for all $i\in\{1,\dots,r\}$,
        \begin{itemize}
            \item every $f_i(x+t)$ such that $t \in S_i$ by $v_i$,
            \item every $f_i(x+t)$ such that $t \in T_i \setminus S_i$ by the corresponding $u_i^t \in \bar{u}_i$, where $\bar{u}_i = \{u_i^t \mid t \in T_i \setminus S_i\}$.
        \end{itemize}
\end{itemize}

Symmetrically, for downward propagation with subsets $\mathcal{S}' = (S'_1,\dots,S'_r)$, define $\Phi_{\text{min}}(\mathcal{S}')$ (with $<$ instead of $>$) and $\Phi_{\text{prop-down}}(\mathcal{S}')$.

We say that $Q$ satisfies the \emph{multi-\req condition for $(\mathcal{S}, \mathcal{S}')$} if
\begin{itemize}
    \item $\Phi_{\text{max}}(\mathcal{S})$ and $\Phi_{\text{prop-up}}(\mathcal{S})$ hold,
    \item $\Phi_{\text{min}}(\mathcal{S}')$ and $\Phi_{\text{prop-down}}(\mathcal{S}')$ hold.
\end{itemize}

We say $Q$ satisfies the \emph{multi-\req condition} if there exists \emph{some} pair~$(\mathcal{S}, \mathcal{S}')$ such that $Q$ satisfies the multi-\req condition for $(\mathcal{S}, \mathcal{S}')$.
\end{definition}


\begin{example}[Multi-\req Illustration]
Consider the formula:
\[
\forall x.\ f(x+c+3) + f(x+4) + f(x+1) = g(x+2) + h(x)
\]
where $c$ is a ground constant. The offset terms for each function are:
\begin{align*}
T_f &= \{c+3,\ 4,\ 1\}, \quad T_g = \{2\}, \quad T_h = \{0\}.
\end{align*}
We have three offsets for $f$: a ground term $c+3$, and two numerals $4$ and $1$.

\medskip\noindent\textbf{Upward propagation:}
% Consider two possible choices:

% \begin{enumerate}
%     \item \textbf{Choice 1: Take only the numerically maximal offset}
Consider the choice $\mathcal{S} = (S_f, S_g, S_h) = (\{4\}, \{2\}, \emptyset)$.
    \begin{enumerate}
        \item \textbf{Maximality $\Phi_{\text{max}}(\mathcal{S})$:}
        \begin{itemize}
        \item For $f$: $S_f = \{4\}$, $T_f \setminus S_f = \{c+3, 1\}$
            \item For $g$: $S_g = \{2\}$, $T_g \setminus S_g = \emptyset$
            \item For $h$: $S_h = \emptyset$
            \end{itemize}
This results in $\Phi_{\text{max}}(\mathcal{S})\equiv 4 = 4 \land 4 > c+3 \land 4 > 1 \land\ 2=2$, which is true 
provided $c < 1$.

        \item \textbf{Propagability $\Phi_{\text{prop-up}}(\mathcal{S})$:}
        We introduce
        \begin{itemize}
            \item $v_f$ for $f(x+4)$,
            \item $v_g$ for $g(x+2)$,
            \item $u_f^{c+3}$ for $f(x+c+3)$ and $u_f^1$ for $f(x+1)$,
            \item $u_h^0$ for $h(x)$,
        \end{itemize}

         and get the propagability condition 
        \[
        \forall x \forall u_f^{c+3} \forall u_f^1 \forall u_h^0 \exists v_f \exists v_g.\ 
        u_f^{c+3} + v_f + u_f^1 = v_g + u_h^0.
        \]
        This is true: for any $u_f^{c+3}, u_f^1, u_h^0$, choose $v_g = 0$ and $v_f = u_h^0 - u_f^{c+3} - u_f^1$.
    \end{enumerate}
    
%     \item \textbf{Choice 2: Take the general term if it's maximal}
%     Alternatively, if $c+3 \geq 4$ (i.e., $c \geq 1$), we could choose:
%     \[
%     S_f = \{c+3\}, \quad S_g = \{2\}, \quad S_h = \emptyset.
%     \]
%     Then $\Phi_{\text{max}}$ requires $c+3 > 4$ and $c+3 > 1$, i.e., $c > 1$.
% \end{enumerate}

\medskip\noindent\textbf{Downward propagation:}
Consider the choice %Choice for downward: Take the numerically minimal offset}
$\mathcal{S}' = (S'_f, S'_g, S'_h) = (\{1\}, \emptyset, \{0\})$.
\begin{enumerate}
    \item \textbf{Minimality $\Phi_{\text{min}}(\mathcal{S}')$:}
    \begin{itemize}
        \item For $f$: $S'_f = \{1\}$, $T_f \setminus S'_f = \{c+3, 4\}$
        \item For $h$: $S'_h = \{0\}$, $T_h \setminus S'_h = \emptyset$
        \item For $g$: $S'_g = \emptyset$
        \end{itemize}
This results in $\Phi_{\text{min}(\mathcal{S}')}\equiv 1 = 1\land 1 < c+3 \land 1 < 4 \ \land\  0=0$, which is true provided
 $c > -2$.

    \item \textbf{Propagability $\Phi_{\text{prop-down}}(\mathcal{S}')$:}
    We introduce
    \begin{itemize}
        \item $v'_f$ for $f(x+1)$,
        \item $v'_h$ for $h(x)$,
        \item $u_f^{c+3}$ for $f(x+c+3)$ and $u_f^4$ for $f(x+4)$,
        \item $u_g^2$ for $g(x+2)$,
    \end{itemize}
    and get the propagability condition
    \[
    \forall x \forall u_f^{c+3} \forall u_f^4 \forall u_g^2 \exists v'_f \exists v'_h.\ 
    u_f^{c+3} + u_f^4 + v'_f = u_g^2 + v'_h
    \]
    This is true: choose $v'_h = 0$ and $v'_f = u_g^2 - u_f^{c+3} - u_f^4$.
\end{enumerate}

\noindent\textbf{Putting it together:}
$Q$ satisfies multi-\req for the pair $(\mathcal{S},\mathcal{S}')$ if we can find $c$ satisfying both:
\begin{itemize}
    \item For upward: $c < 1$
    \item For downward: $c > -2$
\end{itemize}
Thus any $c \in (-2, 1)$ works. This demonstrates that for such $c$, the specific choices $\mathcal{S} = (\{4\},\{2\},\emptyset)$ and $\mathcal{S}' = (\{1\},\emptyset,\{0\})$ witness the multi‑\req condition.
\end{example}

Now, given a concrete interval $B = [b_{\min}, b_{\max}]$, we need additional ``clash conditions'' that prevent the cells generated during propagation from clashing with the ground part $F$.

\begin{definition}[Interval Extension Formulas]
\label{def:interval-extension-formulas-param}
For an interval $B = [b_{\min}, b_{\max}]$ and subsets $\mathcal{S} = (S_1,\dots,S_r)$, $\mathcal{S}' = (S'_1,\dots,S'_r)$, define:\todoSR{potential improvement (to be left for later): conjunction over only one element of $S_i$ (the maximality condition forces them to be equal)}

\begin{enumerate}
    \item \textbf{Upward extension formula $\Psi_{\text{up}}(B,\mathcal{S})$}:
    \[
    \Phi_{\text{max}}(\mathcal{S})\;\land\; 
    \Phi_{\text{prop-up}}(\mathcal{S}) \;\land
    \bigwedge_{i=1}^{r} \bigwedge_{\substack{t_g \in \args(F,f_i) \\ t \in S_i}} t_g \leq b_{\max}+t
    \]
    where $\Phi_{\text{max}}(\mathcal{S})$ and $\Phi_{\text{prop-up}}(\mathcal{S})$ are as defined in \cref{def:multi-reqpivot-param}.\todoSR{The similarity of the names $t_g$ and $t$ seems to suggest that both are offsets, but $t_g$ is not.}
    
    \item \textbf{Downward extension formula $\Psi_{\text{down}}(B,\mathcal{S}')$}:
    \[
    \Phi_{\text{min}}(\mathcal{S}') \;\land\; 
    \Phi_{\text{prop-down}}(\mathcal{S}') \;\land
    \bigwedge_{i=1}^{r} \bigwedge_{\substack{t_g \in \args(F,f_i) \\ t \in S_i'}} t_g \geq b_{\min}+t
    \]
    where $\Phi_{\text{min}}(\mathcal{S}')$ and $\Phi_{\text{prop-down}}(\mathcal{S}')$ are as defined in \cref{def:multi-reqpivot-param}.
\end{enumerate}
\end{definition}

Thus, for any choice of subsets $\mathcal{S} = (S_1,\dots,S_r)$, $\Psi_{\text{up}}(\mathcal{S}, B)$ (resp.\ $\Psi_{\text{down}}(\mathcal{S}', B)$) asserts that $\mathcal{S}$ satisfies the upward (resp.\ $\mathcal{S}'$ satisfies the downward) conditions of multi‑\req \emph{and additionally} satisfies the clash condition for interval $B$. The clash condition ensures that no cell $f_i(z+t)$ with $z > b_{\max}$ (resp. $z < b_{\min}$) and $t \in S_i$ already appears in the ground part $F$.

\begin{theorem}[Interval Satisfiability]
\label{thm:interval-certificate-param}
Let $B = [b_{\min}, b_{\max}]$ be a non‑empty integer interval, and let $\mathcal{S} = (S_1,\dots,S_r)$, $\mathcal{S}' = (S'_1,\dots,S'_r)$ be subsets of offset terms. If 
\[
\Bigl(F \land \bigwedge_{x \in B} Q[x]\Bigr) \;\land\; \Psi_{\text{up}}(B,\mathcal{S}) \;\land\; \Psi_{\text{down}}(B,\mathcal{S}')
\]
is satisfiable, then $\phi$ has a satisfiability certificate, and hence is satisfiable.
\end{theorem}

\begin{proof}
Suppose the conjunction is satisfiable, and let $I$ be an interpretation satisfying it. We construct a certificate as in \cref{def:certificate}:

\begin{enumerate}
      \item \textbf{Pre‑satisfiability assignment:} $I$ 
    \item \textbf{Well‑order $\preceq$ on $\mathbb{Z}$:}
    \[0, 1, -1, 2, -2, 3, -3, \dots, b_{\max}, b_{\min},b_{\max}+1, b_{\max}+2, \dots,b_{\min}-1, b_{\min}-2, \dots\]		
    
    \item \textbf{Propagated cells $X_z$ for $z \in \mathbb{Z}$:}
    \[
    X_z = 
    \begin{cases}
    \emptyset & \text{if } z \in B, \\[4pt]
    \bigl\{ f_i(z+t) \mid i=1,\dots,r,\; t \in S_i \bigr\} & \text{if } z > b_{\max}, \\[4pt]
    \bigl\{ f_i(z+t) \mid i=1,\dots,r,\; t \in S_i' \bigr\} & \text{if } z < b_{\min}.
    \end{cases}
    \]
    
    \item \textbf{Satisfiability propagators:}
    \begin{itemize}
        \item For $z \in B$: $I$ itself satisfies $Q[z]$.
        \item For $z > b_{\max}$: the condition $\Phi_{\text{prop-up}}(\mathcal{S})$ provides a function that, given values for all non‑propagated cells in $\Gamma_{I,z}(\phi)$, returns values $v_1,\dots,v_r$ to assign to every $f_i(z+t)$ with $t \in S_i$, thereby satisfying $Q[z]$.
        \item For $z < b_{\min}$: the condition $\Phi_{\text{prop-down}}(\mathcal{S}')$ yields a propagator for the cells $f_i(z+t)$ with $t \in S_i'$.
    \end{itemize}
\end{enumerate}

It remains to verify the disjointness condition of \cref{def:certificate}:
\[
X_z \cap (\mathit{def}(I) \cup \bigcup_{z' \prec z} \Gamma_{I,z'}(\phi)) = \emptyset.
\]

\begin{itemize}
    \item For $z \in B$, $X_z = \emptyset$ holds trivially.
    \item For $z > b_{\max}$, consider any $f_i(z+t)$ with $t \in S_i$.
    \begin{itemize}
        \item It cannot belong to $\mathit{def}(I)$ because the clash condition $t_g \leq b_{\max} + t$ in $\Psi_{\text{up}}(B,\mathcal{S})$ guarantees $I(t_g) \leq b_{\max} + I(t) < z + I(t)$ for every $t_g \in \args(F,f_i)$.
        \item It cannot appear in any $\Gamma_{I,z'}(\phi)$ with $z' \prec z$ because either:
        \begin{enumerate}
            \item $z' \leq b_{\max}$: then $z'+I(t') \leq b_{\max} + I(t') < z + I(t)$ for all $t' \in T_i$,
            \item $b_{\max} < z' < z$: then $z'+I(t') \leq z'+ \max_{t'' \in T_i} I(t'') < z + I(t)$ since $I(t)$ is maximal among $\{I(t'') \mid t'' \in T_i\}$ by $\Phi_{\text{max}}(\mathcal{S})$.
        \end{enumerate}
    \end{itemize}

    \item The case $z < b_{\min}$ is symmetric, using $\Phi_{\text{min}}(\mathcal{S}')$ and the downward clash condition.
\end{itemize}

Thus all certificate requirements are satisfied. By Property \ref{prop:certThenSat}, $\phi$ is satisfiable.
\qedhere\end{proof}

\cref{thm:interval-certificate-param} immediately yields an algorithm that searches for an interval $B$ satisfying the three conditions. This can be seen in \cref{alg:interval-check-param-withBigvee}. 

\begin{algorithm}
\caption{Interval‑Based Satisfiability Check}
\label{alg:interval-check-param-withBigvee}
\begin{algorithmic}[1]
\Require $\phi = F \land \forall x.\, Q$ in the fragment
\Ensure \textsc{Sat} or \textsc{Unsat}
\State $b_{\min} \gets 0$, $b_{\max} \gets 0$ 
% \State $I \gets \smt\!\left(F \land Q[0]\right)$
%\While{$I \neq \bot$}
\While{$F \land \bigwedge_{x=b_{\min}}^{b_{\max}} Q[x]$ is satisfiable}
    \State $\text{max}_\text{up}\gets\bigvee_{S_1\subseteq T_1,\dots,S_r\subseteq T_r}\Psi_{\text{up}}([b_{\min},b_{\max}],(S_1,\dots,S_r))$
    \State $\text{min}_\text{down}\gets\bigvee_{S_1'\subseteq T_1,\dots,S_r'\subseteq T_r}\Psi_{\text{down}}([b_{\min},b_{\max}],(S_1',\dots,S_r'))$ 
    \If{$F \land \bigwedge_{x=b_{\min}}^{b_{\max}} Q[x] \land \text{max}_{\text{up}} \land \text{min}_{\text{down}}$ is satisfiable}
        \State \Return \textsc{Sat} 
    \EndIf
    \State $b_{\min} \gets b_{\min} - 1$, $b_{\max} \gets b_{\max} + 1$ \Comment{Expand interval symmetrically}
    % \State $I \gets \smt\left(F \land \bigwedge_{x=b_{\min}}^{b_{\max}} Q[x]\right)$
\EndWhile
\State \Return \textsc{Unsat}
\end{algorithmic}
\end{algorithm}

\begin{corollary}[Soundness]
\label{cor:soundness-bigvee}
 If \cref{alg:interval-check-param-withBigvee} returns \textsc{Sat}, then $\phi$ is satisfiable.
\end{corollary}

\begin{proof}
Assume \cref{alg:interval-check-param-withBigvee} returns \textsc{Sat} at some iteration. Then there exists:
\begin{itemize}
    \item An interval $B = [b_{\min}, b_{\max}]$,
    \item An interpretation $I$ satisfying:
    \[
    I \models F \land \bigwedge_{x \in B} Q[x] \land \text{max}_{\text{up}} \land \text{min}_{\text{down}},
    \]
    where $\text{max}_{\text{up}}$ and $\text{min}_{\text{down}}$ are the disjunctions defined in lines 4--5 of the algorithm.
\end{itemize}

Since $I \models \text{max}_{\text{up}}$, there exists some $\mathcal{S} = (S_1,\dots,S_r)$ such that 
$I \models \Psi_{\text{up}}(B,\mathcal{S})$. Similarly, $I \models \text{min}_{\text{down}}$ implies there exists 
$\mathcal{S}' = (S'_1,\dots,S'_r)$ such that $I \models \Psi_{\text{down}}(B,\mathcal{S}')$. Thus $I$ satisfies:
\[
F \land \bigwedge_{x \in B} Q[x] \land \Psi_{\text{up}}(B,\mathcal{S}) \land \Psi_{\text{down}}(B,\mathcal{S}').
\]

By \cref{thm:interval-certificate-param}, this implies that $\phi$ has a satisfiability certificate 
for the pair $(\mathcal{S},\mathcal{S}')$, and consequently $\phi$ is satisfiable.
\qedhere\end{proof}

The proof of~\cref{thm:interval-certificate-param} also shows how the return value \textsc{Sat} results in a corresponding satisfiability certificate, and extending the algorithm to also return such a certificate is an easy exercise.\todoSR{I will add some information on the relationship between satisfiability propagators and quantifier elimination}

\begin{theorem}[Relative Completeness]
\label{thm:completeness-bigvee}
If the input formula~$\phi$
\begin{enumerate}
    \item is satisfiable, and
    \item satisfies the multi‑\req condition for some pair $(\mathcal{S}^*,\mathcal{S}'^*)$ 
          as defined in \cref{def:multi-reqpivot-param},
\end{enumerate}
then \cref{alg:interval-check-param-withBigvee} terminates and returns \textsc{Sat}.
\end{theorem}

\begin{proof}
Assume $\phi$ is satisfiable and satisfies multi‑\req for $(\mathcal{S}^*,\mathcal{S}'^*)$. 
Let $\mathcal{M}$ be a model of $\phi$ and extract the corresponding cell interpretation $I^*$.

For each $i$, define:
\[
v_{\max}^i = \max\{\, I^*(t) \mid t \in T_i \,\}, \qquad
v_{\min}^i = \min\{\, I^*(t) \mid t \in T_i \,\}.
\]

The conditions $\Phi_{\text{max}}(\mathcal{S}^*)$ and $\Phi_{\text{min}}(\mathcal{S}'^*)$ ensure that:
\begin{itemize}
    \item For all $t \in S_i^*$: $I^*(t) = v_{\max}^i$,
    \item For all $t \in S_i'^*$: $I^*(t) = v_{\min}^i$.
\end{itemize}

Now choose
\[
b_{\max} = \max\{\, I^*(t_g) - v_{\max}^i \mid t_g \in \args(F,f_i),\; i=1,\dots,r \,\},
\]
\[
b_{\min} = \min\{\, I^*(t_g) - v_{\min}^i \mid t_g \in \args(F,f_i),\; i=1,\dots,r \,\}.
\]

Set $B = [b_{\min}, b_{\max}]$. We verify that $I^*$ satisfies:

\begin{enumerate}
    \item \textbf{Base formula}: $I^* \models F \land \bigwedge_{x \in B} Q[x]$ (since $\mathcal{M} \models \phi$).
    
    \item \textbf{Upward disjunction $\text{max}_{\text{up}}$}: 
    For the specific $\mathcal{S}^*$, we have:
    \begin{itemize}
        \item $\Phi_{\text{max}}(\mathcal{S}^*)$ holds by definition,
        \item $\Phi_{\text{prop-up}}(\mathcal{S}^*)$ holds by the multi-\req condition,
        \item For each $i$ and $t_g \in \args(F,f_i)$ with $t \in S_i^*$:
        \[
        I^*(t_g) \leq b_{\max} + v_{\max}^i = b_{\max} + I^*(t)
        \]
        by construction of $b_{\max}$.
    \end{itemize}
    Thus $I^* \models \Psi_{\text{up}}(B,\mathcal{S}^*)$, and consequently $I^* \models \text{max}_{\text{up}}$.
    
    \item \textbf{Downward disjunction $\text{min}_{\text{down}}$}: 
    Similarly, for $\mathcal{S}'^*$ we have:
    \begin{itemize}
        \item $\Phi_{\text{min}}(\mathcal{S}'^*)$ holds,
        \item $\Phi_{\text{prop-down}}(\mathcal{S}'^*)$ holds,
        \item For each $i$ and $t_g \in \args(F,f_i)$ with $t \in S_i'^*$:
        \[
        I^*(t_g) \geq b_{\min} + v_{\min}^i = b_{\min} + I^*(t)
        \]
        by construction of $b_{\min}$.
    \end{itemize}
    Thus $I^* \models \Psi_{\text{down}}(B,\mathcal{S}'^*)$, and consequently $I^* \models \text{min}_{\text{down}}$.
\end{enumerate}

Let $N = \max(|b_{\min}|, |b_{\max}|)$. \cref{alg:interval-check-param-withBigvee} expands the interval symmetrically from $[0,0]$. When it reaches iteration $n = N$, the interval becomes $[-N, N]$, which contains $B$. At this iteration, line 5 will check the satisfiability of:
\[
F \land \bigwedge_{x=-N}^{N} Q[x] \land \text{max}_{\text{up}} \land \text{min}_{\text{down}}
\]
where $\text{max}_{\text{up}}$ and $\text{min}_{\text{down}}$ are constructed for the interval $[-N, N]$. Since $[-N, N]$ contains $B$, and $I^*$ satisfies all three conditions as shown above, this formula is satisfiable (witnessed by $I^*$). Therefore, the algorithm returns \textsc{Sat}.
\qedhere\end{proof}

\section{Handling Disjunction Using Auxiliary Propositional Variables}

The algorithm presented so far relies on large disjunctions over all possible subset choices $\mathcal{S} = (S_1,\dots,S_r)$ and $\mathcal{S}' = (S'_1,\dots,S'_r)$. While theoretically elegant, these disjunctions lead to formulas with exponential size, making them computationally impractical. In this subsection, we present a compact CNF encoding that avoids this issue.

\paragraph{Encoding Idea.} Instead of enumerating all subset choices, we introduce auxiliary Boolean variables that represent membership in the subsets $S_i$ and $S'_i$. For each offset term $t_j^{f_i} \in T_i$, we create:
\begin{itemize}
    \item $s_{i,j}$: true iff $t_j^{f_i} \in S_i$ (for upward propagation)
    \item $s'_{i,j}$: true iff $t_j^{f_i} \in S'_i$ (for downward propagation)
\end{itemize}

We then encode the conditions $\Phi_{\text{max}}$, $\Phi_{\text{min}}$, $\Psi_\text{up}$, $\Psi_\text{down}$, and the clash conditions using these variables.

\begin{definition}[CNF Encoding of Interval Extension Formulas]
\label{def:interval-extension-formulas-CNF}
For an interval $B = [b_{\min}, b_{\max}]$, define the encoded formulas:
\begin{align*}
\Psi_{\text{up}}^\text{e}(B) &\equiv \Phi_\text{max}^\text{e} \land \Phi_\text{prop-up}^\text{e} \land \text{ClashUpEnc} \\
\Psi_{\text{down}}^\text{e}(B) &\equiv \Phi_\text{min}^\text{e} \land \Phi_\text{prop-down}^\text{e} \land \text{ClashDownEnc}
\end{align*}
where:
\begin{itemize}
    \item Maximality encoding:
    \begin{align*}
    \Phi_\text{max}^\text{e} \equiv \bigwedge_{i=1}^r \Big[& 
        \bigwedge_{j<k} \big(s_{i,j} \land s_{i,k} \Rightarrow (t_j^{f_i} = t_k^{f_i})\big) \ \land \\
        & \bigwedge_{j,k} \big(s_{i,j} \land \neg s_{i,k} \Rightarrow (t_j^{f_i} > t_k^{f_i})\big) \Big]
    \end{align*}
    
    \item Minimality encoding: $\Phi_\text{min}^\text{e}$ defined analogously with $s'_{i,j}$ and $<$ instead of $>$.
    
    \item Upward propagation encoding: Given Boolean variables $\{s_{i,j}\}$ representing the choice $\mathcal{S} = (S_1,\dots,S_r)$ where $S_i = \{t_j^{f_i} \mid s_{i,j} \text{ is true}\}$, we define:
    \begin{align*}
        \Phi_{\text{prop-up}}^\text{e}(\{s_{i,j}\}) &\equiv \forall x \forall \bar{u}_1 \dots \forall \bar{u}_r \exists v_1 \dots \exists v_r.\ Q' 
    \end{align*}
    where each $\bar{u}_i$, $i\in \{1,\dots,r\}$ stands for those variables $u_{i,j}$ for which $\neg s_{i,j}$, $j\in \{1,\dots, l_i\}$.
    The formula $Q'$ is obtained from $Q$ by simultaneously substituting:
    \begin{itemize}
        \item $f_i(x+t_j^{f_i})$ by $v_i$ whenever $s_{i,j}$ is true,
        \item $f_i(x+t_j^{f_i})$ by $u_{i,j}$ whenever $s_{i,j}$ is false.
    \end{itemize}

    \item Downward propagation encoding: Symmetrically, for downward propagation with variables $\{s'_{i,j}\}$ representing $\mathcal{S}'$, define $\Phi_{\text{prop-down}}^\text{e}(\{s'_{i,j}\})$.
    
    \item Clash condition encoding:
    \begin{align*}
        \text{ClashUpEnc} &\equiv \bigwedge_{i=1}^r \bigwedge_{t_g \in \args(F,f_i)} \bigwedge_{j=1}^{l_i}\big(s_{i,j} \Rightarrow (t_g \leq b_{\max} + t_j^{f_i})\big) \\
        \text{ClashDownEnc} &\equiv \bigwedge_{i=1}^r \bigwedge_{t_g \in \args(F,f_i)} \bigwedge_{j=1}^{l_i}\big(s'_{i,j} \Rightarrow (t_g \geq b_{\min} + t_j^{f_i})\big)
    \end{align*}
\end{itemize}
\end{definition}

Note that if for some $i\in \{1,\dots, r\}$ all offset terms of $f_i$ are pairwise different numerals, then at most one $s_{i,j}$ can be true in any satisfying assignment of $\Psi_{\text{up}}^\text{e}(B)$ or $\Psi_{\text{down}}^\text{e}(B)$. This is because the maximality condition $\bigwedge_{t,t' \in S_i} t = t'$ would require two different numerals to be equal, which is impossible. Similarly for minimality condition.

\begin{lemma}[Encoding Correctness]
\label{lem:encoding-correctness}
For any interval $B = [b_{\min}, b_{\max}]$:
\begin{enumerate}
    \item $\Psi_\text{up}^\text{e}(B)$ is satisfiable iff there exists $\mathcal{S} = (S_1,\dots,S_r)$ such that $\Psi_{\text{up}}(B,\mathcal{S})$ holds.
    \item $\Psi_\text{down}^\text{e}(B)$ is satisfiable iff there exists $\mathcal{S}' = (S'_1,\dots,S'_r)$ such that $\Psi_{\text{down}}(B,\mathcal{S}')$ holds.
\end{enumerate}
\end{lemma}
\begin{proof}
    ($\Rightarrow$) Suppose $\Psi_\text{up}^\text{e}(B)$ is satisfiable by an assignment $I$. Define $S_i = \{t_j^{f_i} \mid I(s_{i,j}) = \text{true}\}$. By $\Phi_{\text{max}}^\text{e}$, all $t \in S_i$ have equal values under $I$, and they are strictly greater than any $t' \in T_i \setminus S_i$. Thus $\Phi_{\text{max}}(\mathcal{S})$ holds. By $\Phi_{\text{prop-up}}^\text{e}$, all $f_i(x+t)$ with $t \in S_i$ are equal to $v_i$, satisfying the substitution in $\Phi_{\text{prop-up}}(\mathcal{S})$. Finally, $\text{ClashUpEnc}$ ensures the clash condition. Hence $\Psi_{\text{up}}(B,\mathcal{S})$ holds.

    ($\Leftarrow$) Suppose $\Psi_{\text{up}}(B,\mathcal{S})$ holds for some $\mathcal{S}$. Set $s_{i,j}$ true iff $t_j^{f_i} \in S_i$. By $\Phi_{\text{max}}(\mathcal{S})$, all selected terms are equal and greater than non-selected ones, so $\Phi_{\text{max}}^\text{e}$ holds. Let $v_i$ be the common value for $f_i(x+t)$ with $t \in S_i$ (guaranteed by $\Phi_{\text{prop-up}}(\mathcal{S})$), then $\Phi_{\text{prop-up}}^\text{e}$ holds. The clash condition from $\Psi_{\text{up}}(B,\mathcal{S})$ ensures $\text{ClashUpEnc}$. Thus $\Psi_\text{up}^\text{e}(B)$ is satisfiable.
    
    The proof for $\Psi_\text{down}^\text{e}(B)$ is symmetric.
\qedhere\end{proof}

\paragraph{Practical Considerations.}
The exponential disjunctions in \cref{alg:interval-check-param-withBigvee} 
(lines 4--5) can be replaced by the CNF encodings $\Psi_\text{up}^\text{e}$ and $\Psi_\text{down}^\text{e}$ as defined above, which are equi-satisfiable by Lemma~\ref{lem:encoding-correctness}. This yields a practical implementation while preserving all theoretical guarantees. Thus, the CNF encoding approach provides a practical bridge between the theoretical multi‑\req framework and implementable algorithm, while avoiding exponential formula size.

\section{Experiments}

There are two basic reasons why verification conditions may fail to hold: (1) a bug, (2) underlying assertions not being inductive. In the first case, the counter-model will typically be finite, since program executions only modify finite memory. In the second case, the counter-model may be infinite. However, even in the first case our method may improve upon methods such as MBQI, due to two reasons:
        \begin{itemize}
        \item the models produced by MBQI are very difficult to read
        \item run-time of MBQI increases with the size of the model
        \end{itemize}

        For example, on my brand-new notebook, CVC5 with MBQI needs roughly 15sec to show the formula
        \[ f(0)=0 \wedge \forall x \;.\; x<0\vee x>1000\vee f(x+1)=f(x)+1 \]
        to be satisfiable, and then produces an unreadable model of size 25K. After changing the upper bound to 10000, CVC5 does not terminate in 10 minutes, so apparently, the growth is super-linear.


\section{Conclusion}

\bibliographystyle{abbrv}
\bibliography{refs}



\appendix

\section{Discussion on Completeness}\label{sec:completeness}
% The completeness of algorithms that operate on integers in SMT is tricky because
% integers themselves are not recursively axiomatizable.
% % Hence, it is meaningful to discuss completeness with respect to some set
% % of axioms.
% Further, nonlinear integer arithmetic is undecidable already without
% quantifiers. So for the following discussion we assume that ground problems are
% always decided on line~\ref{ln:check} of \cref{alg:sr}.

% % \cref{alg:sr} terminates if the given formula satisfies \req and is satisfiable in integers.
% % Unsatisfible formulas are more nuanced. Consider the following formula,
% % which requires $f$ to be bounded by 0 but to be strictly increasing.
% % \begin{equation}\label{eq:completeness}
% %     \forall{x}. \,f(x)<0 \,\land \,\forall{x}. \,f(x)<f(x+1)
% % \end{equation}
% % The formula is unsatisfiable as long as we have access to induction.%
% % \footnote{%
% % By induction show that $\forall n\in\mathbb{N}.\,f(n)\geq n+f(0)$.
% % From~\eqref{eq:completeness}, $f(0)<0$, substituting $-f(0)$ for $n$ gives the
% % contradiction $f(-f(0))\geq 0$.
% % }
% %%%%%%%%%%%
% \cref{alg:sr} terminates if the given formula satisfies \req and is satisfiable in integers.
% Unsatisfiable formulas are more nuanced. Consider the following formula,
% which requires $f$ to be constantly $0$, yet different from $0$ at some point.
% \begin{equation}\label{eq:completeness}
% 	f(0)=0\land f(c)\neq 0\land\forall x.\,f(x)=f(x+1)
% \end{equation}
% The formula is unsatisfiable as long as we have access to induction.%
% \footnote{Apply induction in both directions to obtain $\forall n.\,f(n)=0$.}
% %%%%%%%%%%%
% Formula~\eqref{eq:completeness} satisfies \req but
% \cref{alg:sr} does not terminate since the interval~$I$ will grow
% indefinitely. This is due to the fact that instantiating~\eqref{eq:completeness}
% finitely many times always yields a satisfiable ground formula by setting the
% value of $c$ to an arbitrary large integer.
% Further, the formula has a model, which does not admit induction.
% Consider all polynomials on $\mathbb{Z}$, which gives the ring $\mathbb{Z}[X]$,
% where two polynomials are ordered lexicographically---giving a total order.
% Then, the function $f(p)$ can be defined as $0$ for all constant polynomials and
% $1$ everywhere else and then set $c$ to  an arbitrary non-constant polynomial,
% such as $x$.
% % Further, the formula has a model, which does not admit induction.
% % Consider all polynomials on $\mathbb{Z}$, which gives the ring $\mathbb{Z}[X]$,
% % where two polynomials are ordered lexicographically---giving a total order.
% % Then, the function $f(p)$ can be defined as $-x + \text{``constant term of }p\text{''}$.
% % Such function is always below the $0$ polynomial, and it is increasing.

% \cref{alg:sr} terminates if the given formula is unsatisfiable in
% arithmetic without induction.\mj{We need to make more
% 	specific what this means. Is it clear that it hols?}

% \todoSN{So I think we need to remove the above sentence because of the counter example $f(c)=f(c+1)\land\forall x.f(x)<f(x+1)$? If we need to say something about \textsc{Unsat} formulas, perhaps like this one below?}
% ~\cref{alg:sr} terminates with \textsc{Unsat} for formulas whose unsatisfiability can be detected through finite instantiation alone. Formally:
% \begin{theorem}
%     \label{thm:finiteunsatThenUNSAT}
%     Let $\phi$ be a formula of the form described in \cref{thm:satisfiableThenSAT} that is unsatisfiable in the standard model of integer arithmetic. If there exists a finite set of instantiations $\{x = k_1, \dots, x = k_n\}$ such that $F\land\bigwedge_{i=1}^n Q[x\mapsto k_i]$ is unsatisfiable, then Algorithm~\ref{alg:sr} will terminate and return \textsc{Unsat}.
% \end{theorem}
% \begin{proof}
%     If such a finite set exists, let $M = \max\{|k_1|, \dots, |k_n|\}$. Algorithm~\ref{alg:sr} expands the interval $I$ symmetrically from $[0,0]$ to $[-m,m]$ at each iteration. When $m\geq M$, the interval $[-m,m]$ contains all $k_i$, making the formula $F \land \bigwedge_{x=-m}^{m} Q$ unsatisfiable. At this iteration, the $\smt$ call on line~9 returns $\bot$, causing the algorithm to exit the while-loop and return \textsc{Unsat}.
% \end{proof}

% In general, \cref{alg:sr} is complete in the following senses:
% \begin{itemize}
%     \item For \textsc{Sat}: It terminates on all satisfiable formulas within the fragment that satisfy \req (\cref{thm:satisfiableThenSAT}).
%     \item For \textsc{Unsat}: It terminates on formulas whose unsatisfiability is detectable through finite instantiation (\cref{thm:finiteunsatThenUNSAT}).
%     \item For formulas whose unsatisfiability relies on instantiations at offsets not captured by the expanding interval $I$, the algorithm may not terminate. This includes both inductive cases like Formula \eqref{eq:completeness} and non‑inductive cases like $f(c)=f(c+1)\land\forall x.f(x)<f(x+1)$ whose unsatisfiability does not require induction over all integers.
%     \end{itemize}

Our algorithm provides strong guarantees for satisfiable formulas within our fragment, but termination on unsatisfiable formulas requires careful consideration due to the interplay between finite instantiation and induction over integers.

\paragraph{Termination for Satisfiable Formulas.}
For satisfiable formulas satisfying the multi-\req condition, \cref{alg:interval-check-param-withBigvee} is guaranteed to terminate and return \textsc{Sat}. This follows directly from \cref{thm:completeness-bigvee}, which shows that for any formula satisfying the multi-\req condition, we can construct a finite base interval $B$ that triggers termination.

\paragraph{Termination for Finitely Unsatisfiable Formulas.}
For unsatisfiable formulas, we have the following termination guarantee:

\begin{theorem}[Termination for Finitely Unsatisfiable Formulas]
\label{thm:finiteunsatThenUNSAT}
Let $\phi$ be a formula of the form $F \land \forall x.\, Q$ as defined in \cref{sec:problem-statement}. If $\phi$ is unsatisfiable in the standard model of integer arithmetic and there exists a finite set of instantiations $\{x = k_1, \dots, x = k_n\}$ such that $F \land \bigwedge_{i=1}^n Q[x \mapsto k_i]$ is unsatisfiable, then \cref{alg:interval-check-param-withBigvee} will terminate and return \textsc{Unsat}.
\end{theorem}

\begin{proof}
If such a finite set exists, let $M = \max\{|k_1|, \dots, |k_n|\}$. \cref{alg:interval-check-param-withBigvee} expands the interval symmetrically from $[0,0]$ to $[-m,m]$ at each iteration. When $m \geq M$, the interval $[-m,m]$ contains all $k_i$, making the formula $F \land \bigwedge_{x=-m}^{m} Q$ unsatisfiable. At this iteration, the $\smt$ call on line 2 returns $\bot$, causing the algorithm to exit the while-loop and return \textsc{Unsat}.
\qedhere\end{proof}

\paragraph{Limitations and Non-Terminating Cases.}
There are unsatisfiable formulas for which our algorithm may not terminate. This occurs when the unsatisfiability relies on reasoning that cannot be captured by finite instantiation alone.

\begin{example}[Formula Requiring Induction]
Consider the formula:
\[
f(0) = 0 \land f(c) \neq 0 \land \forall x.\, f(x) = f(x+1)
\]
This formula is unsatisfiable in standard integer arithmetic (applying induction in both directions yields $\forall n.\, f(n) = 0$, contradicting $f(c) \neq 0$). However, any finite set of instantiations is satisfiable by choosing $c$ to be a sufficiently large integer. Thus, \cref{alg:interval-check-param-withBigvee} will expand the interval indefinitely without detecting unsatisfiability.
\end{example}

\begin{example}[Non-Inductive Unsatisfiability]
Consider:
\[
f(c) = f(c+1) \land \forall x.\, f(x) < f(x+1)
\]
This formula is unsatisfiable (the quantifier forces $f(c) < f(c+1)$, contradicting the ground equality), but its unsatisfiability does not require induction over all integers. Depending on the value of $c$, finite instantiation may or may not detect the contradiction.
\end{example}

\paragraph{Summary.}
In summary, our algorithm:
\begin{itemize}
    \item Terminates with \textsc{Sat} for all satisfiable formulas within the fragment that satisfy the multi-\req condition (\cref{thm:completeness-bigvee}).
    \item Terminates with \textsc{Unsat} for formulas whose unsatisfiability can be detected through finite instantiation alone (\cref{thm:finiteunsatThenUNSAT}).
    \item May not terminate for formulas whose unsatisfiability requires induction over all integers or instantiations at unbounded offsets.
\end{itemize}

\section{Handling Disjunction by Enumeration}

This would be as in \cref{alg:interval-check-param} or \cref{alg:two-phase-precompute}.

\begin{algorithm}
\caption{Interval‑Based Satisfiability Check (parameterised multi-\req)}
\label{alg:interval-check-param}
\begin{algorithmic}[1]
\Require $\phi = F \land \forall x.\, Q$ in the fragment
\Ensure \textsc{Sat} or \textsc{Unsat}
\State $\mathcal{C} \gets \{(\mathcal{S},\mathcal{S}') \mid Q \text{ satisfies multi-\req for } (\mathcal{S},\mathcal{S}')\}$
\For{each $(\mathcal{S},\mathcal{S}') \in \mathcal{C}$}
    \State $b_{\min} \gets 0$, $b_{\max} \gets 0$ 
    \State $I \gets \smt\!\left(F \land Q[0]\right)$
    \While{$I \neq \bot$}
        \State Construct $\Psi_{\text{up}}([b_{\min},b_{\max}],\mathcal{S})$ and $\Psi_{\text{down}}([b_{\min},b_{\max}],\mathcal{S}')$ \Comment{\cref{def:interval-extension-formulas-param}}
        \If{$\smt\left(F \land \bigwedge_{x=b_{\min}}^{b_{\max}} Q[x] \land \Psi_{\text{up}} \land \Psi_{\text{down}}\right) \neq \bot$}
            \State \Return \textsc{Sat} 
        \EndIf
        \State $b_{\min} \gets b_{\min} - 1$, $b_{\max} \gets b_{\max} + 1$ \Comment{Expand interval symmetrically}
        \State $I \gets \smt\left(F \land \bigwedge_{x=b_{\min}}^{b_{\max}} Q[x]\right)$
    \EndWhile
\EndFor
\State \Return \textsc{Unsat}
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{Two‑Phase Interval Check with Subset Pre‑computation}
\label{alg:two-phase-precompute}
\begin{algorithmic}[1]
\Require Formula $\phi = F \land \forall x . Q$
\Ensure \textsc{Sat} or \textsc{Unsat}

\State \textbf{Phase 1: Pre‑compute useful subset pairs}
\State $\mathcal{C} \gets \emptyset$ \Comment{Set of candidate $(\mathcal{S}, \mathcal{S}')$ pairs}
\For{each $(\mathcal{S}, \mathcal{S}')$}
    \If{$\Phi_{\text{prop-up}}(\mathcal{S}) \land \Phi_{\text{prop-down}}(\mathcal{S}')$ is valid}
        \State $\mathcal{C} \gets \mathcal{C} \cup \{(\mathcal{S}, \mathcal{S}')\}$
    \EndIf
\EndFor

\State \textbf{Phase 2: Interval expansion for each candidate}
\For{each $(\mathcal{S}, \mathcal{S}') \in \mathcal{C}$}
    \State $b_{\min} \gets 0$, $b_{\max} \gets 0$
    \State $I \gets \smt\!\left(F \land Q[0]\right)$
    \While{$I \neq \bot$}
        \State Construct $\Psi_{\text{up}}([b_{\min},b_{\max}],\mathcal{S})$ and $\Psi_{\text{down}}([b_{\min},b_{\max}],\mathcal{S'})$ \Comment{Definition~\ref{def:interval-extension-formulas-param}}
        
        \If{$\smt\!\left(F \land \bigwedge_{x=b_{\min}}^{b_{\max}} Q[x] \land \Psi_{\text{up}} \land \Psi_{\text{down}}\right) \neq \bot$}
            \State \Return \textsc{Sat}
        \EndIf
        
        \State $b_{\min} \gets b_{\min} - 1$, $b_{\max} \gets b_{\max} + 1$
        \State $I \gets \smt\!\left(F \land \bigwedge_{x=b_{\min}}^{b_{\max}} Q[x]\right)$
    \EndWhile
\EndFor
\State \Return \textsc{Unsat}
\end{algorithmic}
\end{algorithm}



\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
