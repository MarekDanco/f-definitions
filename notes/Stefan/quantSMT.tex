\documentclass[a4paper,11pt]{article}

\usepackage{amssymb, amsthm, amsmath}
\newtheorem{definition}{Definition}
\newtheorem{property}{Property}
\newtheorem{example}{Example}

\begin{document}


\section{Constructing Certificates}

Very rough idea:
\begin{enumerate}
    \item solve quantifier-free part
    \item check solution against instantiations of quantified part with all entities already assigned, if not satisfied, learn a clause and backtrack to solving
    \item order all other instantiations and construct the necessary certificates
\end{enumerate}

  \[ F\wedge \forall x\;.\; Q(f(x+k),f(x+l))\]
  where $F$ is quantifier free, $k<l$, and $Q$ is such that
  \begin{itemize}
  \item  for every $u$ there is a $v$ such that $Q(u,v)$, and
  \item for every $v$ there is a $u$ such that $Q(u,v)$.
  \end{itemize}
  In particular, this holds for $Q(f(x+k), f(x+l))$ being $f(x+k)=f(x+l)$. In the following, $args(F, f)$ will denote the set of argument terms of $f$ in $F$.

  An algorithm now can construct a satisfiability certificate from an integer interval $I$ and an entity assignment\footnote{This is someting like a variable assignment, but unlike a variable assignment, it \emph{separately} assigns values to the different entities belonging to the same uninterpreted function symbol } $\alpha$ s.t.
  \begin{itemize}
  \item   $\alpha\models F\wedge \bigwedge_{x\in I} Q(f(x), f(x+1))$ 
  \item there is no $t\in args(F, f)$, $\max I<x$  s.t. $x+l=\alpha(t)$ (no existential variable of upward induction clashes with an argument of $f$ in $F$)
  \item there is no $t\in args(F, f)$, $x<\min I$  s.t. $x+k=\alpha(t)$ (no existential variable of downward induction clashes with an argument of $f$ in $F$)
  \end{itemize}

  The corresponding certificate is:
  \begin{itemize}
  \item order on constraints:
    \begin{enumerate}
    \item $F$, $Q(f(x+k),f(x+l))$ for $x\in I$
    \item $Q(f(x+k),f(x+l))$ for $x=\max I+1, \max I+2, \dots$
    \item $Q(f(x+k),f(x+l))$ for $x=\min I-1, \min I-2, \dots$      
    \end{enumerate}
  \item existential entities:
    \begin{enumerate}
    \item $\{ x+k \mid x \in I \}\cup \{ x+l \mid x \in I \}$
    \item $\max I + l+1, \max I+l+2, \dots$
    \item $\min I + k -1, \min I+k-2, \dots$
    \end{enumerate}
  \end{itemize}
  
  Notation: for a formula $F$, $smt(F)$ is a model of $F$, if it exists (i.e., $F$ is satisfiable), and $\bot$, otherwise

  For coming up with an algorithm, let us first simplify the two conditions above. Pushing negation over quantifiers, we get:
  \begin{itemize}
  \item  for all $t\in args(F, f)$, for all $x$ with $\max I<x$, $\alpha(t)<x+l$ 
  \item for all $t\in args(F, f)$, for all $x$ with $x<\min I$, $x+k<\alpha(t)$
  \end{itemize}
And eliminating the inner universal quantifier, we get
    \begin{itemize}
  \item  for all $t\in args(F, f)$, $\alpha(t)<\max I + 1 +l$ 
  \item for all $t\in args(F, f)$, $\min I-1+k<\alpha(t)$
  \end{itemize}
  which simplifies to
 \[ \text{for all } t\in args(F, f), \min I+k\leq\alpha(t)\leq\max I +l.\] 
Using this condition, we get a first (inefficient) algorithm for constructing a certificate:
  \begin{tabbing}\hspace*{0.4cm}\=\hspace*{0.4cm}\=\kill\\
    $\underline{I}\leftarrow 0$\\
    $\overline{I}\leftarrow 0$\\
    $\alpha\leftarrow smt(F\wedge \bigwedge_{\underline{I}\leq x\leq \overline{I}} Q(f(x+k),f(x+l)))$\\

   \textbf{while} $\alpha\neq\bot$ \textbf{do}\+\\
    \textbf{if} $smt(F\wedge \bigwedge_{\underline{I}\leq x\leq \overline{I}} Q(f(x+k),f(x+l)))\wedge\bigwedge_{t\in args(F,f)} \underline{I}+k\leq\alpha(t)\leq\overline{I} +l)\neq\bot$ \textbf{then}\+\\
      \textbf{return} \texttt{sat}\-\\      
        $\underline{I}\leftarrow \underline{I}-1$\\
        $\overline{I}\leftarrow \overline{I}+1$\\
        $\alpha\leftarrow smt(F\wedge \bigwedge_{\underline{I}\leq x\leq \overline{I}} Q(f(x+k),f(x+l)))$\-\\
  \textbf{return} \texttt{unsat}
  \end{tabbing}
Potential improvements:
\begin{itemize}
\item Initialize $\underline{I}$, $\overline{I}$ more intelligently, based on constant terms in $args(F, f)$.
\item Incorporate Stefan's observation that the index set of the universal quantifier can be decomposed into equivalence classes, where only some of them may need to be analyzed
\item Weaken the totality requirements. In particular, for the starting values $\underline{I}=\overline{I}\leftarrow 0$, they only need to start from zero, in one case going up, in the other case going down. It might also be useful to check the requirements lazily during the algorithm.
\end{itemize}
Potential generalization:
  \[ F\wedge \forall x\;.\; Q(f(x+k),g(x+l))\]
  where
  \begin{itemize}
  \item   $F$ is quantifier free and does not contain any entity $g(i), i\in\mathbb{Z}$, and
    
  \item $Q$ is such that for every $u$ there is a $v$ such that $Q(u,v)$
  \end{itemize}






% *** example:

% attempt 1:
% - solve part without quantifiers: a=0, b=0, g(b)=g(0)=0, f(3,a)=f(3,0)=4, then f(3,0)>= 4+g(0)
% - this violates  (\forall ğ‘¥, ğ‘¦. ğ‘“ (ğ‘¥, ğ‘¦) < ğ‘¥ + ğ‘”(ğ‘¦)) since for x=3, y=0 this is f(3,0)<3+g(0), since not f(3,0)=4<3=3+g(0)
% - backtrack, learn f(3,0)<3+g(0), which excludes attempt 1 (clause learning might learn something more general, e.g., including a and b)
% attempt 2:
% - solve (ğ‘“ (3, ğ‘) â‰¥ 4 + ğ‘”(ğ‘)), f(3,0)<3+g(0) resulting in  a=0, b=1, g(b)=g(1)=0, f(3,a)=f(3,0)=4, g(a)=g(0)=2
% - now try to satisfy \forall ğ‘¥. ğ‘”(ğ‘¥) = ğ‘”(ğ‘¥ + 2):
%     for x in { 0, 1 }, this is satisfied by the assignment already constructed
%     for all x>=2, set g(x)=g(x-2)
%     for all x<0, set g(x)=g(x+2)
% - now try to satisfy (\forall ğ‘¥, ğ‘¦. ğ‘“ (ğ‘¥, ğ‘¦) < ğ‘¥ + ğ‘”(ğ‘¦)):
%     for x=3,y=0 this is satisfied by the assignment already constructed: f(3,0)=4<5=3+2=3+g(0) that is 4<3+2
%     for all other x,y: set f(x,y)=x+g(y)-1


\section*{Satisfiability Certificates: Generalization Attempt}
  
% \begin{definition}
% An \emph{entity term} is a term of the form $f(t_1,\dots, t_k)$ where the $t_1,\dots, t_k$ are terms and all arguments to uninterpreted function symbols in any of $t_1,\dots, t_k$ are integers.
% \end{definition}

% For example, $f(c+7)$ and $f(f(0)+7)$ are entities, but $f(f(c+7))$ is not, since $c+7$ is not an integer. In general, due to the restriction to integer arguments, an entity term may not be part of another entity terms. 

  The following definition defines a notion that is similar to an interpretation but assigns  values to individual entities instead of uninterpreted function symbols.
  
  \begin{definition}    
    An \emph{entity interpretation} is a function from  a set of entities to integers. 
  \end{definition}

For an entity interpretation $I$, we denote the set of entities forming its domain by $\mu(I)$.

  In a similar way as usual interpretations, entity interpretations can give semantics to terms and formulas. However, for entity interpretations it may happen that they do not assign values to enough entities for this semantics to be unique.   
  For example, for the entity interpretation $I=\{ f(0)\mapsto 0 \}$, $I\models f(0)\geq 0$, but $I\models f(1) \geq 0$ is unknown since $I$ does not assign a values to the entity~$f(1)$.


Our satisfiability proofs will have a certain form. For defining this, we will use the fact that a given prewellordering induces a wellordering of its equivalence classes wrt. the relation of the $x$ and $x'$ with both $x\leq x'$ and $x'\leq x$.

\begin{definition}
  A \emph{satisfiability certificate} of a formula $\phi$ is 
    \begin{itemize}
    \item a prewellordering $\prec$ of all integer instantiations of sub-formulas of $\phi$ such that all of its equivalence classes (which we will call \emph{instantiation blocks}) are finite, and
    \item for each instantiation block $\beta$ a function $\pi_\beta$
      (the \emph{satisfiability propagator}) on entity interpretations such that for every entity interpretation $I$ with $I\models \bigwedge_{\beta'\prec \beta} \beta'$, $\mu(I)\subseteq  \mu(\pi_\beta(I))$ and  $\pi_\beta(I)\models \bigwedge_{\beta'\preceq \beta}\beta$.
    \end{itemize}
\footnote{Ideally, satisfiability propagators should be constructive. That is, they should take the form of an algorithm that computes these values. In many cases, they can even be synthesized automatically from the quantifier elimination problem~\cite{kuncak-sttt13}.  But at some point, we might allow satisfiability propagators of a different form, for example,
    to represent real-algebraic number solutions in the case of the reals}.
  \end{definition}

  
  \begin{property}
    Every formula that has a satisfiability certificate is satisfiable.
  \end{property}
    


  

\end{document}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
