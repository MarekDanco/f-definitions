\documentclass{article}
\usepackage[textwidth=3cm,tickmarkheight=3pt]{todonotes}
\usepackage[utf8]{inputenc}
\usepackage{amssymb, amsthm, amsmath}
\usepackage{numprint}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\usepackage{color}
\definecolor{citeblue}{rgb}{0.1,0,.4}
\usepackage[pdftex%
,colorlinks=true%
,bookmarks=true%
,linkcolor=citeblue%
,citecolor=citeblue%
,urlcolor=blue%
,plainpages=false]{hyperref}
\hypersetup{colorlinks,citecolor=blue,linkcolor=blue,urlcolor=blue}
\AtBeginDocument{\hypersetup{pdfborder={0 0 1}}}
\usepackage[nameinlink,capitalize,noabbrev]{cleveref} % must come after hyperref
\usepackage{commath}
\usepackage[most]{tcolorbox}
\usepackage{enumitem}

\usepackage{accents} % for \ubar
\newcommand{\ubar}[1]{\underaccent{\bar}{#1}}
\newcommand{\sygus}{SyGuS\xspace}

\renewcommand{\algorithmicrequire}{\textbf{Input:}}
\renewcommand{\algorithmicensure}{\textbf{Output:}}

\newtheorem{definition}{Definition}
\newtheorem{property}{Property}
\newtheorem{example}{Example}

\newtheorem{theorem}{Theorem}
\newtheorem{corollary}{Corollary}
\theoremstyle{remark}
\newtheorem{claim}{Claim}
\usepackage{etoolbox}
\AtEndEnvironment{proof}{\setcounter{claim}{0}}

\npthousandsep{,}
\newcommand{\gmodel}{\mathcal{M}}
\newcommand{\smt}{\textsc{smt}}
\newcommand{\args}{\text{args}}
\usepackage{xspace}
\newcommand{\req}{\emph{ReqPivot}\xspace}
\newcommand{\subst}[3]{#1[#2\leftarrow #3]}
\newcommand{\repr}[1]{\hat{#1}}

\newcommand{\todoSR}[1]{\todo[color=blue!40]{#1}}
\newcommand{\mj}[1]{\todo[color=green!30]{#1 -mik}}
\newcommand{\marek}[1]{\todo[color=red!10]{#1 -MD}}
\newcommand{\todoSN}[1]{\todo[color=orange!50]{#1 -SN}}

\title{%
    Inductive Function Definitions
}
\author{Stefan Ratschan \and Stefan Nugraha \and Mikoláš Janota \and Marek Dančo}
\date{}

\begin{document}
\maketitle
\section{Introduction}

\marek{Mention these \cite{bradley-manna07, bradley-vmcai06, ge-cav09, habermehl-etaps08}}

Current as SMT solvers have limited capabilities to produce counterexamples
for complex systems. Yet, counterexamples are important during modeling as
they uncover  errors. For example, the user may wrongly assume that an input
stream with increasing values will contain  two neighboring values that are
equal.  Negating and skolemizing yields the following simple SMT formula.
\begin{equation}
	f(0)\neq f(1)\land\forall x:\mathbb{Z}.\,f(x)<f(x+1)
\end{equation}

The formula has trivial counter-models, e.g. $f$ being the
identity function. Such solution can be found by synthesis approaches, such as
\sygus.  But it is  easy to get out of the reach of these tools because they
are primarily based on templates and candidate-solution enumeration. The
following modification is no longer solved by cvc5~\cite{cvc5} in its \sygus mode.
\begin{equation}\label{eq:periodic}
	f(0)\neq f(1)\land\forall x:\mathbb{Z}.\,f(x)=f(x+2)
\end{equation}
These constraints allow only periodic functions whose neighboring values alternate.
For such functions the \sygus grammar would have to guess an \textit{ite} term of the form
$\mathit{ite}(x\,\mathit{mod}\,2 = 0\enspace a\enspace b)$, for integers $a \not = b$.
Even if \sygus tools were improved, they could not yield a decision procedure for UFLIA,
due to the inherent undecidability of arithmetic.

We instead isolate a fragment of UFLIA where formulas like~\eqref{eq:periodic}
can be decided using SMT techniques. Succinctly, we show that if the arguments of non-constant
uninterpreted function symbols are restricted to terms of the form $x + k$, where $x$ is
universally quantified and $k$ is a numeral, then the formula’s satisfiability
becomes decidable via an inductive argument.

We treat each quantifier as introducing infinitely many constraints on function calls,
which we refer to as entities. A single entity may appear in multiple constraints, so we must
ensure that it is assigned a consistent value throughout. To show satisfiability within
our fragment, we impose an order on these constraints and construct a symbolic assignment
to the entities such that, when processed in this order, no conflicting assignments arise.

\section{Notation}\todoSR{We will see where to put this, in the end}

We will write $\subst{s}{v}{t}$ for the result of substituting the term $t$ for $v$ in the term~$s$. For an integer $z\in\mathbb{Z}$, we will denote the constant representing $z$ in a logical formula by $\repr{z}$\todoSR{Does there exist some standard notation for this?}.

For a formula $F$ and uninterpreted function symbol $f$, $args(F, f)$ will denote the set of argument terms of $f$ in $F$.

Include information on well-orders and induction on well-orders, here?


\section{Definitions}
\todoSR{I intend to add a running example and a figure}
We will view quantifier-free formulas as formulas with a universal quantifier that ranges over an empty tuple of variables. Hence, quantifier-free formulas have precisely one instantiation.

\begin{definition}[entity]\label{def:entity}
	An \emph{entity} is a term of the form $f(c_1,\dots, c_k)$ where $f$ is an uninterpreted function symbol and $c_1,\dots, c_k$ are integers.\todoSR{Mikoláš used the term ``cell'', which might more succinct and descriptive.}
	\mj{Potentially change notation from $c_i$ to $n_i$ to distinguish numerals
		and constants.}
\end{definition}
Examples of entities are $c$, and $f(7)$. The term $f(c+7)$ is not an entity.

% For now, we restrict ourselves to the case where the arguments of uninterpreted function symbols may not include further uninterpreted function symbols (e.g., $\forall x\;.\; f(x+1)=f(x)+1$ is OK, but $\forall x\;.\; f(x+c)=f(x)+1$ not). As a consequence, in each instantiation, all arguments to uninterpreted function symbols evaluate to constants, and hence the instantiation constrains a fixed finite set of entities, which we call the \emph{entities of the instantiation}.

\begin{definition}[entity interpretation]
	An \emph{entity interpretation} is a partial function whose domain is the set of entities. An entity interpretation $I$ is \emph{compatible} with an interpretation $\mathcal{I}$ iff $I$ and $\mathcal{I}$ agree on all entities where $I$ is defined.
\end{definition}

Given an entity interpretation $I$, we denote by $\mathit{def}(I)$ the set of entities for which $I$ is defined. Given a term $t$ and an entity interpretation $I$  we define $I(t):=\mathcal{I}(t)$, if  $\mathcal{I}(t)$ is unique for every interpretation $\mathcal{I}$ compatible with $I$, and otherwise $I(t):=\bot$.\todoSR{This is not completely formal, we could also use a more formal, but less readable version.}
For example, for $I=\{ f(0) \mapsto 7 \}$, $I(f(0))=7$, but $I(f(1))=\bot$. Also note that $I(f(1)-f(1))=0\neq\bot$\todoSR{I went for a semantic definition here, since it works very generally without taking much space to define.}. In a similar way, for a formula $\phi$, we define that an entity interpretation~$I$ satisfies $\phi$ iff for every interpretation $\mathcal{I}$ compatible with $I$, $\mathcal{I}$ satisfies $\phi$, in which case we also write $I\models \phi$.

% \begin{definition}
% 	We say that an entity interpretation $I$ \emph{interprets the arguments} of a quantifier-free formula $\phi$ iff for all argument terms $t$ of uninterpreted function symbols in $\phi$, $I(t)\neq\bot$. For an entity interpretation $I$ that interprets the arguments of a formula~$\phi$, we say that an entity $f(c_1,\dots, c_k)$ is an \emph{$I$-interpreted entity in $\phi$} iff $\phi$ has a sub-term of the form $f(t_1,\dots, t_k)$, and $I(t_1)=c_1$, $\dots$, $I(t_k)=c_k$.
% \end{definition}
% For example, the interpretation $I=\{ a\mapsto 5 \}$ interprets the arguments of the formula $f(a)\geq 0$, and the entity $f(5)$ is an $I$-interpreted entity in $f(a)\geq 0$.

\begin{definition}
	\label{def:pre-sat-cert}
	Given a formula $\phi$ of the form $F\wedge \forall x\;.\; Q$, we call an entity interpretation $I$ such that
        \begin{itemize}
        \item $I\models F$, and
        \item for all $z\in\mathbb{Z}$, for every uninterpreted function symbol~$f$ and its argument terms $t\in args(Q, f)$, $I(\subst{t}{x}{\repr{z}})\neq\bot$
        \end{itemize}
 a \emph{pre-satisfiability certificate} of $\phi$. For any $z\in\mathbb{Z}$, we denote by $\Gamma_{I,z}(\phi)$ the resulting set of entities \[\{ I(\subst{t}{x}{\repr{z}}) \mid t\in args(Q, f), f \emph{ is an uninterpreted function symbol}\}.\]
\end{definition}

For example, $I=\{ c\mapsto 5 \}$ is a pre-satisfiability certificate of $c\geq 5 \wedge \forall x \;.\; f(x+c+1)= f(x+c)+1$, and $\Gamma_{I,10}(\phi)=\{ f(15), f(16)\}$.

\begin{definition}
	\label{def:certificate}
	Given a formula $\phi$  of the form $F\wedge \forall x\;.\; Q$, a \emph{satisfiability certificate} is
	\begin{itemize}
		\item a well-order $\preceq$ on $\mathbb{Z}$,%\footnote{A well-order total order for which every non-empty subset has a least element. This enables induction. If we want to allow sub-formulas to be at the same place in the order, we either need to combine them into equivalence classes, or relax anti-symmetry (i.e., work with a pre-wellorder).}
		\item a pre-satisfiability certificate $I$ of $\phi$,
		\item for every $z\in\mathbb{Z}$
                  \begin{itemize}
                  \item a set $X_z\subseteq \Gamma_{I,z}(\phi)$  (the \emph{existential entities})\todoSR{alternative term ``propagated entities''} such that \[X_z\cap (\mathit{def}(I)\cup\bigcup_{z'\prec z} \Gamma_{I,z'}(\phi))=\emptyset,\] and
                    %that are neither assigned a value by $I$, nor occur in any $\Gamma_{I,z'}(\phi)$ for any $z'\prec z$
                  \item a certificate (the \emph{satisfiability propagator}) showing that for all values of entities in $\Gamma_{I,z}(\phi)\setminus \mathit{def}(I)\setminus X_z$ there exist values for the entities in $X_z$ such that for the entity assignment $I_{X_z}$ assigning these values to $X_z$, $I\cup I_{X_z}\models \subst{Q}{x}{\repr{z}}$.
                  \end{itemize}

	\end{itemize}
\end{definition}

For the sake of generality, at this point we do not require the satisfiability propagator to be constructive. Below, we will then work with algorithms computing the values only required to exist, here.

% \addtocounter{definition}{-1}
% \begin{definition}[Simplified]
% 	Given a formula $\phi$, a \emph{satisfiability certificate} is
% 	\begin{itemize}
% 		\item a pre-satisfiability certificate $I$
% 		\item a total order $\preceq$ on instantiations of the quantified part of $\phi$,
% 		\item for each instantiation $\psi$ of the quantified part of $\phi$ a set of corresponding
% 		      \emph{existential} entities -- entities occurring in $\psi$ but not occurring in the ground part of $\phi$
% 		      or in any instantiation $\psi'$, where $\psi' \prec \psi$,
% 		\item for each instantiation $\psi$ of the quantified part of $\phi$ a corresponding
% 		      \emph{satisfiability propagator} -- a certificate showing that for all values of entities that are not existential and
% 		      do not occur in the ground part, there exist values of existential entities that satisfy $\psi$.
% 	\end{itemize}
% \end{definition}


Also note that for $z\in\mathbb{Z}$ such that $\Gamma_{I,z}\subseteq \mathit{def}(I)$, the set of existential variables $X_z$ must be empty, and the satisfiability propagator only needs to certify that $I\models \subst{Q}{x}{\repr{z}}$. In other words, the entity interpretation~$I$ serving as a pre-satisfiability certificate already plays the role of the satisfiability propagator. 

\begin{property}\label{prop:certThenSat}
	Every formula formula $\phi$  of the form $F\wedge \forall x\;.\; Q$ that has a satisfiability certificate is satisfiable.
\end{property}

\begin{proof}
	Assume a formula of the given form and assume that it  has a satisfiability certificate.
	The corresponding pre-satisfiability certificate $I$ satisfies the quantifier free part~$F$ of $\phi$.

We start by showing
 that for every $z\in\mathbb{Z}$ there is an extension $I'$ of $I$ such that $I'\models\{ \subst{Q}{x}{\repr{z}'} \mid z'\preceq z\}$. For this we use the principle of induction on well-orders: Let $z\in\mathbb{Z}$, and let $\Phi$ be $\{ \subst{Q}{x}{\repr{z}'} \mid z'\prec z\}$. We assume that there is an extension $I_{\Phi}$ of $I$ with $I_{\Phi}\models\Phi$, and prove that there is an extension $I'$ of $I$ with $I'\models\Phi\cup \{ \subst{Q}{x}{\repr{z}}\}$. Since the formula has a satisfiability certificate, the existential entities of $\subst{Q}{x}{\repr{z}}$ do not occur in any element of $\Phi$. Let $I'$ be the extension of $I_{\Phi}$ that assigns to the existential entities $X_z$ the values whose existence is  confirmed by the satisfiability propagator. Since these do not occur in $\Phi$, $I'$ and $I_{\Phi}$ coincide on entities occurring in $\Phi$. Hence $I'$ satisfies both $\Phi$ and $\subst{Q}{x}{\repr{z}}$, and so it satisfies $\Phi\cup \{ \subst{Q}{x}{\repr{z}}\}$.

	Now denote for every $z\in\mathbb{Z}$ the entity interpretation  satisfying $\subst{Q}{x}{\repr{z}}$ as constructed in the previous paragraph by $I_z$.
	% From the well-order $\prec$ we get a corresponding well-order on these entity interpretations.
	% Let $I_{\phi}$ be the entity interpretation that, for any entity $u$, assigns the value to $u$ that $I_{z}$ assigns to it for the smallest $z$ (wrt. $\prec$) that assigns a value to $u$. This smallest $z$ exists, since $\prec$ is a well-order. The entity interpretation $I_{\phi}$ satisfies $\phi$, and any classical interpretation compatible with the values assigned by $I_{\phi}$ satisfies $\phi$, as well.
Observe that for every entity $u$, and $z, z'\in \mathbb{Z}$ with $I_z(u)\neq \bot$ and $I_{z'}(u)\neq \bot$, $I_z(u)=I_{z'}(u)$.      Let $I_\phi$ be the interpretation that, for any entity $u$, if there is a $z$ such that $I_z(u)\neq \bot$, then $I_\phi(u)=I_z(u)$, and otherwise $I_\phi(u)=0$. Certainly $I_\phi\models F$. Moreover, for every $z\in\mathbb{Z}$,  $I_\phi\models  \subst{Q}{x}{\repr{z}}$, since $I_\phi$ coincides with $I_z$ for all elements, where it is defined. Hence  $I_\phi\models \phi$.
\end{proof}

A satisfiability certificate only shows that a formula is satisfiable. It does not provide concrete values of the corresponding model. We now show how to compute such values from a given satisfiability certificate containing a pre-satisfiability certificate $I$. For this, we require the satisfiability propagators to be constructive. So, for $z\in\mathbb{Z}$ and for each $u\in X_z$ we assume a function $prop_{u,z}$ such that for
an entity interpretation $I'$ with $\mathit{def}(I')=\Gamma_{I,z}(\phi)\setminus \mathit{def}(I)\setminus X_z$, $I\cup I'\cup \{ u \mapsto prop_{u,z}(I\cup I') \mid u\in{X_z}\}\models\subst{Q}{x}{\repr{z}}$.
 
% for any $\hat{v}_1,\dots,\hat{v}_r$, the entity interpretation
% \[\{ v_1\mapsto \hat{v}_1,\dots,v_r\mapsto \hat{v}_1, u_1\mapsto  prop_{u_1}(\hat{v}_1,\dots, \hat{v}_r),\dots, u_s\mapsto prop_{u_s}(\hat{v}_1,\dots,\hat{v}_r)\} \] satisfies $\psi$

% For any instantiation $\psi$ of a quantified sub-formula with existential entities $u_1,\dots, u_s$ and non-existential entities $v_1,\dots, v_r$, the satisfiability propagator defines  functions $prop_{u_1},\dots, prop_{u_s}$ such that for any $\hat{v}_1,\dots,\hat{v}_r$, the entity interpretation
% \[\{ v_1\mapsto \hat{v}_1,\dots,v_r\mapsto \hat{v}_1, u_1\mapsto  prop_{u_1}(\hat{v}_1,\dots, \hat{v}_r),\dots, u_s\mapsto prop_{u_s}(\hat{v}_1,\dots,\hat{v}_r)\} \] satisfies $\psi$. In many cases, these functions can be synthesized automatically from the corresponding quantifier elimination problem~\cite{kuncak-sttt13}.\marek{Is \cite{kuncak-sttt13} applicable in our case too?}


Now, observe that for any entity $u$ there is at most one $z\in\mathbb{Z}$ with $u\in X_z$ (if there would be more than one then, due to $\preceq$ being a well-order, there is a minimal one, let us say $z_{\min}$, and then, for any $z'\succ z$, the requirements on $X_{z'}$ exclude the possibility of $X_{z'}$ containing $u$, as well). So for any entity $u$, let $\mathit{inst}(u)$ either be the $z\in\mathbb{Z}$ with $u\in X_z$ or $\bot$ if there is no such instantiation.

Then, for the interpretation $I_\phi$ from the proof of Property~\ref{prop:certThenSat}, which satisfies a given formula~$\phi$, and a given entity~$u$, the value of $I_\phi(u)$ can be computed by the following recursive function $val(u)$:
\begin{tabbing}\hspace*{0.4cm}\=\hspace*{0.4cm}\=\kill
	\textbf{if} $I$ assigns a value $x$ to $u$ \textbf{then} \textbf{return} $x$\\
	\textbf{if} $\mathit{inst}(u)=\bot$ \textbf{then} \textbf{return} 0\\
	\textbf{return} $prop_{u,\mathit{inst}(u)}(I\cup \{ v\mapsto val(v) \mid v\in \Gamma_{I,\mathit{inst}(u)}(\phi)\setminus \mathit{def}(I)\setminus X_z\})$
\end{tabbing}

Here, the recursive calls go down the order $\prec$ in the following sense:
\begin{property}
	Let $u$ be an entity such that $\mathit{inst}(u)\neq\bot$. Then for any $v\in\Gamma_{I,\mathit{inst}(u)}(\phi)\setminus \mathit{def}(I)\setminus X_z$ with $\mathit{inst}(v)\neq\bot$, $\mathit{inst}(v)\prec \mathit{inst}(u)$.
\end{property}

So each recursive call of the program $val$ either results in $\mathit{inst}(u)$ either decreasing or being $\bot$. In the latter case, the program terminates immediately, and the former case cannot happen infinitely often, since the used order is well-founded. So we have:
\begin{property}
The program $val$ terminates.
\end{property}

Note that, in general, it is not possible to compute $val(u)$ by computing the values of $X_z, z \in \mathbb{Z}$, with $z$ being initialized with the minimal $z$ wrt. $\prec$, and then using a loop that increases $z$ from one successor wrt. $\prec$ to the next. For example, if  $\prec$  orders all even numbers before all odd ones, then this loop would have to iterate over infinitely many even numbers before computing the value of an odd one.
     

The goal is now an algorithm that computes such satisfiability certificates and a converse of the property that shows for certain classes of satisfiable  formulas this algorithm succeeds.

\section{Algorithm}\label{sec:alg}

Class of formulas:
\[ F\wedge \forall x\;.\; Q(f_1(x+t^{f_1}_1),\dots,f_1(x+t^{f_1}_{l_1}),\dots,f_r(x+t^{f_r}_1),\dots,f_r(x+t^{f_r}_{l_r})),\]
where $F$ is quantifier free, for every $i\in \{1,\dots,r\}$, and the  $t^{f_i}_{1},\dots,t^{f_i}_{l_i}$ are pairwise different LIA ground terms.~\todoSR{We are about to extend the algorithm to this case. Is ``LIA ground term'' correct terminology?}


This does not yet address:
\begin{itemize}
	\item uninterpreted function symbols of higher arity
	\item more interesting argument terms containing uninterpreted constants or function symbols
	\item several quantified variables
	\item several quantified sub-formulas
\end{itemize}
The first item looks like a straightforward extension of the below (choose one argument to base everything on), just introducing messy notation. So we might leave it out for now. The others are interesting extensions we should think about.

% We will satisfy the universal quantifier by an inductive argument going both up and down. For making this argument work, we require that for one of the $f_1,\dots,f_r$, let us say for $f_{i^*}$, for both its highest argument $f_{i^*}(x+c^{f_{i^*}}_{l_{i^*}})$ and lowest argument $f_{i^*}(x+c^{f_{i^*}}_1)$ we can always find values satisfying $Q$. More formally, there must be an $i^*\in \{1,\dots, r\}$ such that
% % \mj{Just to be clear, the requirement above does not apply to $f(x)<f(x+1)\land f(x+1)<f(x+3)$?}
% % \todoSR{Correct. It applies to both parts individually, but not to the conjunction. This is  restrictive, of course, but allowed for an easy generalization to the case of several occurrences of the same function symbol with different arguments.}
% \begin{itemize}
%     \item for all values of entities\mj{I still think that the terminology is wrong. Entity is $f(1)$, not $f(x+1)$ by \cref{def:entity}.} in $Q$ except for $f_{i^*}(x+c^{f_{i^*}}_{l_{i^*}})$ there is a value for $f_{i^*}(x+c^{f_{i^*}}_{l_{i^*}})$ satisfying $Q$, and
%     \item for all values of entities in $Q$ except for $f_{i^*}(x+c^{f_{i^*}}_1)$ there is a value for $f_{i^*}(x+c^{f_{i^*}}_1)$ satisfying $Q$.
% \end{itemize}

% In the following, we will call this condition \req. We will assume that we have corresponding satisfiability propagators (see Definition~\ref{def:certificate})
% available.

We will satisfy the universal quantifier by an inductive argument going both up and down. For making this argument works, we require the \req condition described as follows.

\paragraph{ReqPivot Condition.}\todoSR{I added Section~\ref{sec:req} for our internal discussion about this condition}
Let $f_1, \dots, f_r$ be the functions appearing in $Q$.
We say that $Q$ satisfies the \req condition if there exists an index $i^* \in \{1,\dots,r\}$ such that:
\begin{itemize}
	\item for all values of entities\mj{I still think that the terminology is wrong. Entity is $f(1)$, not $f(x+1)$ by \cref{def:entity}.} in $Q$ except for $f_{i^*}(x+c^{f_{i^*}}_{l_{i^*}})$ there is a value for $f_{i^*}(x+c^{f_{i^*}}_{l_{i^*}})$ satisfying $Q$, and
	\item for all values of entities in $Q$ except for $f_{i^*}(x+c^{f_{i^*}}_1)$ there is a value for $f_{i^*}(x+c^{f_{i^*}}_1)$ satisfying $Q$.
\end{itemize}
We will assume that we have corresponding satisfiability propagators (see Definition~\ref{def:certificate}) available.

For increasing $x$, this will propagate values to the entity $f_{i^*}(x+c^{f_{i^*}}_{l_{i^*}})$ which, since the offset $c^{f_{i^*}}_{l_{i^*}}$ is the biggest for $f_{i^*}$ has not been propagated a value to, before. Analogically, for decreasing $x$, it will propagate values to the entity with the smallest offset. Note that there might be weaker requirements (with fewer entities universally quantified) that also might do the job, but this needs more investigation.



\begin{property}
	\label{prop:cert}
	Let $I$\todoSR{We also use $I$ for pre-satisfiability certificates.} be a non-empty integer interval and $\alpha$ be an entity interpretation  s.t.
	\begin{enumerate}[label=(\roman*)]
		\item $\alpha\models F\wedge \bigwedge_{x\in I} Q$
		\item there is no $t\in args(F, f)$, $\max I<x$  s.t.\ $x+c^{f_{i^*}}_{l_{i^*}}=\alpha(t)$ (no entity propagated to by upward induction clashes with an argument of $f$ in $F$)
		\item there is no $t\in args(F, f)$, $x<\min I$  s.t.\ $x+c^{f_{i^{*}}}_1=\alpha(t)$ (no entity propagated to by downward induction clashes with an argument of $f$ in $F$)
	\end{enumerate}
	Then the following forms a satisfiability certificate for $F\wedge \forall x \:.\: Q$:
	\begin{itemize}
		\item order: $0,1,-1,2,-2\dots, I, -I,\max I+1, \max I+2, \dots, \min I-1, \min I-2,\dots$
		\item pre-satisfiability certificate: $\alpha$
		\item corresponding sets of existential entities:
		      \begin{itemize}
			      \item $\emptyset$, for $x\in I$,

			      \item $\{f_{i^*}(x+c^{f_{i^*}}_{l_{i^*}})\}$, for $x>\max I$, and
			      \item $\{f_{i^*}(x+c^{f_{i^{*}}}_1)\}$, for $x<\min I$
		      \end{itemize}
		\item propagators:
		      \begin{itemize}
			      \item resulting from $\alpha$, for $x\in I$,
			      \item from first part of \req, for $x>\max I$, and
			      \item from second part of \req, for $x<\min I$.
		      \end{itemize}
	\end{itemize}
\end{property}

\begin{proof} \todoSR{I still need to check some details, e.g., the case $r<2$.}
	We verify that for each instantiation $\psi$ in the order, the existential entities are neither assigned a value by $\alpha$, nor occur in any $\Gamma_I(\psi')$ for an instantiation $\psi'\prec\psi$. %Let $\Delta = c^{f_{i^*}}_{l_{i^*}} - c^{f_{i^*}}_1 \geq 0$ be the minimum size of $I$.
	\begin{description}
		\item[Case $x \in I$:] The set of existential entities is empty, so the condition holds vacuously.

		\item[Case $x > \max I$:] The existential entity~$f_{i^*}(x+c^{f_{i^*}}_{l_{i^*}})$ is neither allowed to be assigned a value by $\alpha$, nor allowed to occur in any instantiation $x'$ with $\max I<x'<x$. The former is ensured by hypothesis (\textit{ii}), the latter by the fact that $x+c^{f_{i^*}}_{l_{i^*}}$ is the highest argument of $f_{i^*}$.

		\item[Case $x < \min I$:] The existential entity~$f_{i^*}(x+c^{f_{i^{*}}}_1)$, is neither allowed to be assigned a value by $\alpha$, nor allowed to occur in any instantiation~$x'$ with $\max I<x'$, nor in any $x'$ with $x<x'<\min I$. The first condition is ensured by hypothesis (\textit{iii}). The second condition follows from the fact that $x < \min I \leq \max I < x'$; hence, $x+c^{f_{i^*}}_1<x'+c^{f_{i^*}}_1$. The third condition follows from the fact that $x+c^{f_{i^{*}}}_1$ is the lowest argument of $f_{i^*}$.
		      % the second condition \todoSR{This is the ``glueing together'' mentioned by Mikoláš below.} is followed from the lowest argument $(\max I+1) + c^{f_{i^*}}_1 \geq (\min I+\Delta) + c^{f_{i^*}}_1 + 1=\min I+c^{f_{i^*}}_{l_{i^*}}+1>(\min I-1)+c^{f_{i^*}}_{l_{i^*}}\geq x+c^{f_{i^{*}}}_1$,
	\end{description}
	In all cases, the existential entity is neither assigned by $\alpha$ nor appears in any earlier instantiation. The \req condition ensures the existence of suitable propagators. Therefore, the construction forms a valid satisfiability certificate as defined in Definition \ref{def:certificate}.
\end{proof}

For coming up with an algorithm, let us first simplify the two conditions: Pushing negation over quantifiers, we get:
\begin{itemize}
	\item  for all $t\in args(F, f)$, for all $x$ with $\max I<x$, $\alpha(t)<x+c^{f_{i^*}}_{l_{i^*}}$
	\item for all $t\in args(F, f)$, for all $x$ with $x<\min I$, $x+c^{f_{i^{*}}}_1<\alpha(t)$
\end{itemize}
And eliminating the inner universal quantifier, we get
\begin{itemize}
	\item  for all $t\in args(F, f)$, $\alpha(t)<\max I + 1 +c^{f_{i^*}}_{l_{i^*}}$
	\item for all $t\in args(F, f)$, $\min I-1+c^{f_{i^{*}}}_1<\alpha(t)$
\end{itemize}
which simplifies to
\[ \text{for all } t\in args(F, f), \min I+c^{f_{i^{*}}}_1\leq\alpha(t)\leq\max I +c^{f_{i^*}}_{l_{i^*}}.\]
Using this condition, we get a first (inefficient) algorithm for constructing a certificate. Here we use the notation that for a formula $F$, $\smt(F)$ is a model of $F$, if it exists (i.e., $F$ is satisfiable), and $\bot$, otherwise
% \mj{Is this condition really correct? If $F$ is empty, there's no condition on
%     $I$ (it can be empty), but how are we sure that we can glue together the two functions (the negative
%     and the positive)?}
% \todoSR{We closed the gap in the proof of Property~\ref{prop:cert}. Non-emptyness of $I$ seems to be enough.}

\subsection{Propagation Algorithm}

\todoSR{The current algorithm uses a fixed $i^*$, a witness for the existential quantifier in \req (the current text does not explicitly say this). It may also be possible to search for it, if there is several such witnesses.}
\mj{Potentially, in the implementation, use cores to determine which way to increase the size of~$I$. If a certain condition does not appear in the core, it might be possible to not move in one of the directions.}

\begin{algorithm}
	\caption{Satisfiability Check}%
	\label{alg:sr}
	\textbf{Input:} Formula $F \wedge \forall x \:.\: Q$ as above\\
	\textbf{Output:} SAT or UNSAT
	\begin{algorithmic}[1]
		% \Procedure{OriginalSMT}{$F, f, k, l, Q$}
		\State $\underline{I} \leftarrow 0$, $\overline{I} \leftarrow 0$ \Comment{Start with singleton interval}
		\State $\alpha \leftarrow \smt\left(F \wedge \bigwedge_{x=\underline{I}}^{\overline{I}} Q\right)$

		\While{$\alpha \neq \bot$}

		\State $\text{condition} \leftarrow \bigwedge_{t \in \args(F,f_{i^*})} \underline{I} + c^{f_{i^{*}}}_1 \leq t \leq \overline{I} + c^{f_{i^*}}_{l_{i^*}}$
		\If{$\smt(F \wedge \bigwedge_{x=\underline{I}}^{\overline{I}} Q \wedge \text{condition}) \neq \bot$} \Comment{with clash condition}\label{ln:check}
		\State \Return \textsc{Sat} \Comment{Certificate can be constructed}
		\EndIf

		%        \State \textbf{Expand interval symmetrically:}
		\State $\underline{I} \leftarrow \underline{I} - 1$
		\State $\overline{I} \leftarrow \overline{I} + 1$

		%       \State \textbf{Solve extended formula:}
		\State $\alpha \leftarrow \smt\left(F \wedge \bigwedge_{x=\underline{I}}^{\overline{I}} Q\right)$ \Comment{with updated bounds}
		\EndWhile

		\State \Return \textsc{Unsat}
		% \EndProcedure
	\end{algorithmic}
\end{algorithm}


We are currently polishing a completeness proof for the \textsc{Sat} case. For the \textsc{Unsat} case, the essential argument seems to be the same as for Ge and de~Moura~\cite[paragraph ``compactness'']{ge-cav09}.

\begin{theorem}
    \label{thm:satisfiableThenSAT}
    Let $\phi$ be a formula of the form
    \begin{align*}
        \phi:=F\land \forall x.\ Q\big(f_1(x+c_1^{f_1}),...,f_1(x+c_{l_1}^{f_1}),...,f_r(x+c_1^{f_r}),...,f_r(x+c_{l_r}^{f_r})\big)
    \end{align*}
    where
    \begin{enumerate}
        \item $F$ is quantifier-free.
        \item For every $i\in\{1,...,r\}$, the constants $c_1^{f_i},...,c_{l_i}^{f_i}$ are sorted and pairwise different.
        \item $\phi$ is satisfiable.
        \item $\phi$ satisfies \req for a specific critical function $f_{i^*}$
    \end{enumerate}
    Then, Algorithm~\ref{alg:sr}, upon input $\phi$, will terminate and return \textsc{Sat}.
\end{theorem}

\begin{proof}
    Since $\phi$ is satisfiable, there exists a model $\mathcal{M} \models \phi$. From $\mathcal{M}$, we can extract an entity interpretation $I^*$ that serves as a pre-satisfiability certificate (Definition~\ref{def:pre-sat-cert}). This $I^*$ assigns integer values to all ground entities in $F$ and provides values for the entities appearing in instantiations of the quantified formula.
    
    Let $S$ be the set of all integer arguments for the critical function $f_{i^*}$ that appear in the ground part $F$:
    \begin{align*}
        S = \{I^*(t) \mid t \in \args(F, f_{i^*})\}
    \end{align*}
    Since $\args(F, f_{i^*})$ is finite, $S$ is finite. Define $L = \min(S)$ and $U = \max(S)$. Now define the critical interval $[K_{\min}, K_{\max}]$ where:
    \begin{align*}
        K_{\min} = L - c_{l_{i^*}}^{f_{i^*}} \quad\text{and}\quad K_{\max} = U - c_1^{f_{i^*}}
    \end{align*}
    \begin{claim}
        \label{claim:bounds-satisfied}
        For the interval $[K_{\min}, K_{\max}]$, $I^*$ satisfies the bound condition:
        \begin{align*}
            \forall t \in \args(F, f_{i^*}).\ K_{\min} + c_1^{f_{i^*}} \leq I^*(t) \leq K_{\max} + c_{l_{i^*}}^{f_{i^*}}
        \end{align*}
    \end{claim}
    \begin{proof}[Proof of Claim~\ref{claim:bounds-satisfied}]
        For any $t \in \args(F, f_{i^*})$, we have $L \leq I^*(t) \leq U$ by definition of $L$ and $U$. Therefore:
        \begin{itemize}
            \item $I^*(t) \geq L = (L - c_{l_{i^*}}^{f_{i^*}}) + c_{l_{i^*}}^{f_{i^*}} \geq (L - c_{l_{i^*}}^{f_{i^*}}) + c_1^{f_{i^*}} = K_{\min} + c_1^{f_{i^*}}$, since $c_{l_{i^*}}^{f_{i^*}} \geq c_1^{f_{i^*}}$.
            \item $I^*(t) \leq U = (U - c_1^{f_{i^*}}) + c_1^{f_{i^*}} \leq (U - c_1^{f_{i^*}}) + c_{l_{i^*}}^{f_{i^*}} = K_{\max} + c_{l_{i^*}}^{f_{i^*}}$, since $c_{l_{i^*}}^{f_{i^*}} \geq c_1^{f_{i^*}}$.\qedhere
        \end{itemize}
    \end{proof}
    Now, let $N = \max(|K_{\min}|, |K_{\max}|)$ and consider Algorithm~\ref{alg:sr}. We trace its execution:
    \begin{enumerate}
        \item \textbf{Initialisation (lines 1--2):} The algorithm sets $\underline{I} = \overline{I} = 0$ and calls $\smt(F \wedge Q(0))$. This succeeds because $\mathcal{M}$ is a model of $\phi$.
        \item \textbf{Loop progression:} The algorithm enters the while-loop. At each iteration, it expands the interval symmetrically: $\underline{I} \leftarrow \underline{I} - 1$, $\overline{I} \leftarrow \overline{I} + 1$.
        \item \textbf{At iteration where interval becomes $[-N, N]$:} We show that the algorithm returns \textsc{Sat} at this iteration.
        \begin{itemize}
            \item By construction, $[K_{\min}, K_{\max}] \subseteq [-N, N]$.
            \item Consider the following entity interpretation $\alpha$:
            \begin{itemize}
                \item For all entities in $F$ and for all instantiations with $x \in [K_{\min}, K_{\max}]$, use the values from $I^*$.
                \item For $x > K_{\max}$ (up to $N$), use the upward \req propagator to assign values to the existential entity $f_{i^*}(x+c_{l_{i^*}}^{f_{i^*}})$.
                \item For $x < K_{\min}$ (down to $-N$), use the downward \req propagator to assign values to the existential entity $f_{i^*}(x+c_1^{f_{i^*}})$.
            \end{itemize}
            \item We claim $\alpha$ satisfies:
            \begin{enumerate}
                \item $F \wedge \bigwedge_{x \in [-N, N]} Q(x)$ by construction.
                \item The clash condition $C \equiv \bigwedge_{t \in \args(F, f_{i^*})} -N + c_1^{f_{i^*}} \leq t \leq N + c_{l_{i^*}}^{f_{i^*}}$.
            \end{enumerate}
            \item To see why $\alpha$ satisfies $C$:
            \begin{itemize}
                \item For any $t \in \args(F, f_{i^*})$, $\alpha(t) = I^*(t)$ (since we use $I^*$ for ground part).
                \item From Claim~\ref{claim:bounds-satisfied}, $K_{\min} + c_1^{f_{i^*}} \leq I^*(t) \leq K_{\max} + c_{l_{i^*}}^{f_{i^*}}$.
                \item Since $K_{\min} \geq -N$ and $K_{\max} \leq N$, we have: $-N + c_1^{f_{i^*}} \leq I^*(t) \leq N + c_{l_{i^*}}^{f_{i^*}}$.
                \item Therefore, under interpretation $\alpha$, each term $t$ evaluates to a value within the bounds.
            \end{itemize}
            \item Since such an $\alpha$ exists, the $\smt$ call on line~5 will find a model that satisfies all constraints, and the algorithm returns \textsc{Sat}.\qedhere
        \end{itemize}
    \end{enumerate}
\end{proof}

\section{Experiments}

\section{Conclusion}

\bibliographystyle{abbrv}
\bibliography{refs}



\appendix

\section{Discussion on Completeness}\label{sec:completeness}
The completeness of algorithms that operate on integers in SMT is tricky because
integers themselves are not recursively axiomatizable.
% Hence, it is meaningful to discuss completeness with respect to some set
% of axioms.
Further, nonlinear integer arithmetic is undecidable already without
quantifiers. So for the following discussion we assume that ground problems are
always decided on line~\ref{ln:check} of \cref{alg:sr}.

% \cref{alg:sr} terminates if the given formula satisfies \req and is satisfiable in integers.
% Unsatisfible formulas are more nuanced. Consider the following formula,
% which requires $f$ to be bounded by 0 but to be strictly increasing.
% \begin{equation}\label{eq:completeness}
%     \forall{x}. \,f(x)<0 \,\land \,\forall{x}. \,f(x)<f(x+1)
% \end{equation}
% The formula is unsatisfiable as long as we have access to induction.%
% \footnote{%
% By induction show that $\forall n\in\mathbb{N}.\,f(n)\geq n+f(0)$.
% From~\eqref{eq:completeness}, $f(0)<0$, substituting $-f(0)$ for $n$ gives the
% contradiction $f(-f(0))\geq 0$.
% }
%%%%%%%%%%%
\cref{alg:sr} terminates if the given formula satisfies \req and is satisfiable in integers.
Unsatisfiable formulas are more nuanced. Consider the following formula,
which requires $f$ to be constantly $0$, yet different from $0$ at some point.
\begin{equation}\label{eq:completeness}
	f(0)=0\land f(c)\neq 0\land\forall x.\,f(x)=f(x+1)
\end{equation}
The formula is unsatisfiable as long as we have access to induction.%
\footnote{Apply induction in both directions to obtain $\forall n.\,f(n)=0$.}
%%%%%%%%%%%
Formula~\eqref{eq:completeness} satisfies \req but
\cref{alg:sr} does not terminate since the interval~$I$ will grow
indefinitely. This is due to the fact that instantiating~\eqref{eq:completeness}
finitely many times always yields a satisfiable ground formula by setting the
value of $c$ to an arbitrary large integer.
Further, the formula has a model, which does not admit induction.
Consider all polynomials on $\mathbb{Z}$, which gives the ring $\mathbb{Z}[X]$,
where two polynomials are ordered lexicographically---giving a total order.
Then, the function $f(p)$ can be defined as $0$ for all constant polynomials and
$1$ everywhere else and then set $c$ to  an arbitrary non-constant polynomial,
such as $x$.
% Further, the formula has a model, which does not admit induction.
% Consider all polynomials on $\mathbb{Z}$, which gives the ring $\mathbb{Z}[X]$,
% where two polynomials are ordered lexicographically---giving a total order.
% Then, the function $f(p)$ can be defined as $-x + \text{``constant term of }p\text{''}$.
% Such function is always below the $0$ polynomial, and it is increasing.

\cref{alg:sr} terminates if the given formula is unsatisfiable in
arithmetic without induction.\mj{We need to make more
	specific what this means. Is it clear that it hols?}

\todoSN{So I think we need to remove the above sentence because of the counter example $f(c)=f(c+1)\land\forall x.f(x)<f(x+1)$? If we need to say something about \textsc{Unsat} formulas, perhaps like this one below?}
~\cref{alg:sr} terminates with \textsc{Unsat} for formulas whose unsatisfiability can be detected through finite instantiation alone. Formally:
\begin{theorem}
    \label{thm:finiteunsatThenUNSAT}
    Let $\phi$ be a formula of the form described in \cref{thm:satisfiableThenSAT} that is unsatisfiable in the standard model of integer arithmetic. If there exists a finite set of instantiations $\{x = k_1, \dots, x = k_n\}$ such that $F\land\bigwedge_{i=1}^n Q[x\mapsto k_i]$ is unsatisfiable, then Algorithm~\ref{alg:sr} will terminate and return \textsc{Unsat}.
\end{theorem}
\begin{proof}
    If such a finite set exists, let $M = \max\{|k_1|, \dots, |k_n|\}$. Algorithm~\ref{alg:sr} expands the interval $I$ symmetrically from $[0,0]$ to $[-m,m]$ at each iteration. When $m\geq M$, the interval $[-m,m]$ contains all $k_i$, making the formula $F \land \bigwedge_{x=-m}^{m} Q$ unsatisfiable. At this iteration, the $\smt$ call on line~9 returns $\bot$, causing the algorithm to exit the while-loop and return \textsc{Unsat}.
\end{proof}

In general, \cref{alg:sr} is complete in the following senses:
\begin{itemize}
    \item For \textsc{Sat}: It terminates on all satisfiable formulas within the fragment that satisfy \req (\cref{thm:satisfiableThenSAT}).
    \item For \textsc{Unsat}: It terminates on formulas whose unsatisfiability is detectable through finite instantiation (\cref{thm:finiteunsatThenUNSAT}).
    \item For formulas whose unsatisfiability relies on instantiations at offsets not captured by the expanding interval $I$, the algorithm may not terminate. This includes both inductive cases like Formula \eqref{eq:completeness} and non‑inductive cases like $f(c)=f(c+1)\land\forall x.f(x)<f(x+1)$ whose unsatisfiability does not require induction over all integers.
    \end{itemize}

    \section{Potential Benchmark Problems}
    \begin{itemize}
    \item smtlib
      \begin{itemize}
      \item UFLIA: difficult to find problems with addition in function argument, yet without nested functions, but there might be problems where the nesting can be stratified
      \item array theories: examples without writes? eliminating writes?        
      \end{itemize}
    \item Reynolds et al.~\cite{reynolds2016model}
    \item program analysis
      \begin{itemize}
      \item verification conditions on programs with arrays: There are two basic reasons why verification conditions may fail to hold: (1) a bug, (2) underlying assertions not being inductive. In the first case, the counter-model will typically be finite, since program executions only modify finite memory. In the second case, the counter-model may be infinite. However, even in the first case our method may improve upon methods such as MBQI, due to two reasons:
        \begin{itemize}
        \item the models produced by MBQI are very difficult to read
        \item run-time of MBQI increases with the size of the model
        \end{itemize}
        For example, on my brand-new notebook, CVC5 with MBQI needs roughly 15sec to show the formula
        \[ f(0)=0 \wedge \forall x \;.\; x<0\vee x>1000\vee f(x+1)=f(x)+1 \]
        to be satisfiable, and then produces an unreadable model of size 25K. After changing the upper bound to 10000, CVC5 does not terminate in 10 minutes, so apparently, the growth is super-linear.
        
       

%         Universal quantifiers occur on the left-hand side of implications and might refer to infinitely many elements (for real-world programs, due to a programmer mistake). A tiny (and stupid) example\todoSR{I will think of something more interesting}:
%         \begin{tabbing}\quad\=\kill
%           \textbf{assert} $a[i+1]> a[i]$\\
%           $x\leftarrow a[0]$\\
%           \textbf{assert} $x\geq 0$
%         \end{tabbing}
% For proving the verification condition
% \[ [\forall i \,.\, a[i+1]> a[i]\wedge x=a[0]] \Rightarrow x\geq 0 \]
% one has to show its negation
% \[ \forall i \,.\, a[i+1]> a[i]\wedge x=a[0] \wedge x<0 \]
% to be unsatisfiable. However, the program has a bug (any array where $a[0]<0$), and hence the formula  is satisfiable. Moreover, the initial assertion speaks about infinitely many array elements, and hence the formula does not have  a finite model. Our method is able to prove that the formula is satisfiable.
\item reactive programming, where uninterpreted function symbols model data streams 
\item finding counter-examples in protocol verification        
\item non-termination: Most techniques seem to look for program traces ending in a cycle where the program state keeps returning into a state it already reached before. But programs over integers (as opposed machine integers) may also diverge without a cycle. There are some techniques~\cite{chen2014proving} that can take this info account, and even use conditions similar to ReqPivot on transitions systems. 

Usage of our techniques:  For example, for the program
\begin{tabbing}\quad\=\kill
$i\leftarrow 0$\\
\texttt{while} $i\geq 0$\\
\> $i\leftarrow i+1$
\end{tabbing}
satisfiability of
\[ f(0)=0 \wedge \forall x \;.\; f(x+1)=f(x)+1 \wedge f(x)\geq 0\]
implies non-termination.

This formula does not satisfy ReqPivot since it does not include reasoning about invariants:
\[ \forall u\exists u' \;.\; u'=u+1 \wedge u\geq 0\]
  However, its extension with $k$-induction might do the job:
\[ \forall u, u'\exists u'' \;.\; [u'=u+1 \wedge u\geq 0]\Rightarrow [u''=u'+1 \wedge u'\geq 0]\]

\item ranking function synthesis: for a formula $\Phi(x,x')$ modeling a loop iteration from program state $x$ to $x'$, find a function $f$ such that
  \[ \forall x, x' \;.\; \Phi(x,x') \Rightarrow f(x')<f(x)\]
Problem: the program state usually consists of several variables, resulting in many universally quantified variables in the formula.
      \end{itemize}
    \end{itemize}

\section{Extensions}

\subsection{K-Induction}\label{sec:kinduction}
The condition \req can be generalized to be able to see~$k$ steps
ahead, in the spirit of $k$-induction~\cite{kinduction,En2003}. The value of~$k$ can be
increased gradually. This is useful for example for periodic functions, such as
\begin{equation}\label{eq:kind}
	2\mid x \Rightarrow (f(x)=2\land f(x+1)=3)
\end{equation}
The formula~\eqref{eq:kind} does not satisfy \req but satisfies the property
that assuming that if it is satisfied for~$i$ and $i+1$, the values for~$i+2$ and
$i+3$ can be calculated, i.e., prove the following.
\begin{equation}\label{eq:kind:prove}
	\forall x_0x_1
	\exists x_2x_3.\
	\left(2\mid x_0 \Rightarrow (x_0=2\land x_1=3)\right)
	\Rightarrow
	\left(2\mid x_2 \Rightarrow (x_2=2\land x_3=3)\right)
\end{equation}

In this case, $k=2$ and \cref{alg:sr} has to be
modified so that $|I|\geq k$ to start with.
Analogously, backward.


\subsection{Conjunction}\label{sec:conj}

Suppose the following formula.
\begin{equation}\label{eq:conj1}
	\forall x.\,f(x + 7) > f(x) - f(x + 3)
	\,\land \,f(x + 3) > f(x)
\end{equation}
Formula~\eqref{eq:conj1} does not satisfy the \req condition because
for values of $f(x+3)$ and $f(x)$ with $f(x+3)\leq f(x)$, it is no longer
possible to find a value of $f(x+7)$ to satisfy the formula. On the other hand,
\req holds for downward propagation.

Since the literals are in conjunction, for all $x$ both of them have to be satisfied. This means
the formula is equivalent to the formula where the conjunction is split into two
universally quantified formulas
\[
	\forall x. \,f(x + 7) > f(x) - f(x + 3)
	\,\land \,\forall x. \,f(x + 3) > f(x)
\]
Using substitution $y = x + 3$ we ``normalize'' the formulas as follows
\[
	\forall x. \,f(x) > f(x - 7) - f(x - 4)
	\,\land \,\forall y. \,f(y) > f(y - 3)
\]
Using the previous argument, we can merge the two universal quantifiers into a single formula
\begin{equation}\label{eq:normalized}
	\forall x. \,f(x) > f(x - 7) - f(x - 4)
	\,\land \, \,f(x) > f(x - 3)
\end{equation}
Note that the condition \emph{ReqPivot} now holds for
Formula~\eqref{eq:normalized} for upward propagation too, so our algorithm can be applied.

In general, for a formula $\bigwedge_i F_i$, for forward propagation,
shift the  offsets so that the highest offset is $0$, i.e.\ $f(x)$ is being
propagated  forward. Analogously, for backward propagation, shift the offsets so that the
lowest offset is $0$, i.e.\  $f(x)$ is being propagated backward.

Note that shifting the arguments does not change the formula semantically.
More precisely, for a formula $F$ where $f$ is applied to arguments $t_i$,
construct a formula $F'$ where $f$ is applied to arguments $t_i+k$ for some
$k\in\mathbb{Z}$. Whenever $F$ has a model, so does $F'$; we can simply transform
any model of $F$ to a model of $F'$ by setting $f_{F'}(x) \triangleq f_{F}(x-k)$.


This approach does not generally work for disjunction, however, which
we address in the following section.


\subsection{Disjunction}\label{sec:disj}

First note that we can't in general split the formula $\forall x. \,\varphi[x] \,\lor \,\psi[x]$ into
$(\forall x. \,\varphi[x]) \,\lor (\forall x. \,\psi[x])$.

If there exists a disjunct that satisfies \req then the problem trivially reduces to the
case of a single literal by running the original algorithm on this one disjunct.

Otherwise, the \req condition is not useful in the case of disjunctions, since
assume we are propagating in the increasing direction and we have set arbitrary
values to all cells except the maximal one.

\begin{definition}[Offset Term]
	An \emph{offset term} is a term of the form $x + k$, where $x$ is a variable and $k\in\mathbb{Z}$.
\end{definition}

We are interested in formulas where only offset terms are allowed as arguments of uninterpreted
function symbols.

\begin{definition}[Maximal Offset Term]
	The \emph{maximal offset term} of an uninterpreted function symbol $f$ in a formula $\varphi$
	is the offset term $x + k$ such that $f(x + k)$ occurs in $\varphi$ and for any other offset term
	$x + k'$ occurring as an argument of $f$ in $\varphi$ we have $k' < k$.
\end{definition}
We define the \emph{minimal offset term} in an analogous way.

I use the term ``cell'' for ``entity'' here.

\begin{definition}[Maximal Cell]
	The \emph{maximal cell} of $f$ in a formula $\varphi[x \mapsto a]$ is the cell $f(t(a))$ where $t$ is the maximal
	offset term of $f$ in $\varphi$.
\end{definition}
We define the \emph{minimal cell} in an analogous way.

In our algorithm, we define the value for the maximal cell of $f_{i*}$ in the increasing
direction and for the minimal cell in the decreasing direction.
Let us for convenience define the following terminology.
\marek{In the following I still haven't thought through what exactly
	$\underline{I}, \bar{I}$ are.}
\begin{definition}[Write to a Cell]
	We say a formula $\varphi[x\mapsto a]$ \emph{writes to a cell} $f(n)$ if either
	\begin{enumerate}
		\item $a > \bar{I}$ and for the maximal offset term $t_{\mathit{max}}$ of $f$ in $\varphi$
		      we have $t_{\mathit{max}}(a) = n$, or
		\item $a < \underline{I}$ and for the minimal offset term $t_{\mathit{min}}$ of $f$ in $\varphi$
		      we have $t_{\mathit{min}}(a) = n$.
	\end{enumerate}
	In the first case we also say $\varphi[x\mapsto a]$ \emph{writes to a cell} $f(n)$
	\emph{in the increasing direction}. Analogously for the \emph{decreasing direction} in the second case.
\end{definition}

Suppose we are given the formula $\varphi = \forall x. \,\varphi_1(x) \lor \dots \lor \varphi_n(x)$.
If we can construct formulas $\mathit{pre}_1, \dots, \mathit{pre}_n$ so that
they contain only $x$ and interpreted function symbols, and in addition
\begin{enumerate}
	\item\label{pre:1} $\forall x. \,\bigvee_{i = 1}^n \mathit{pre}_i(x)$ is valid,
	\item\label{pre:2} given $a$, if $\mathit{pre}_{i_1}(a) \land \dots \land \mathit{pre}_{i_n}(a)$ holds,
	      we can apply \req condition on $\varphi_{i_1}(a)\lor \dots \lor \varphi_{i_n}(a)$, and
	\item\label{pre:3} there are no $i\not=j, x_1\not=x_2$ such that $\mathit{pre}_i(x_1) \land \mathit{pre}_j(x_2)$
	      and $\varphi_i[x \mapsto x_1]$, $\varphi_j[x \mapsto x_2]$ write to the same cell in the same direction,
\end{enumerate}
then $\varphi$ is satisfiable. The argument is similar as before.\marek{I will elaborate on this later.}
However, finding such precondition formulas is a difficult synthesis problem and shall be left
as a subject of future work.

As an illustration of this approach consider the formula
\[\forall{x}. \,2*f(x + 5) = x \,\lor \,2*f(x + 1) = x + 1\]
The preconditions are $2 \mid x$ and $2 \nmid x$ for the first and second disjunct respectively.
In this case the preconditions are complementary -- for each $x$ exactly one precondition
is satisfied. At the same time the requirement~\ref{pre:3} holds here since the difference of
the offsets is even.

However, the \req condition doesn't hold for this formula. Suppose we are propagating to the right
direction and we've propagated up to an odd $x$. The condition allows us to set an arbitrary value
to $f(x+1)$. Let us set $f(x+1)$ so that
$2*f(x + 1) \not= x + 1$. To make the instance true, we need to set $f(x + 5)$ so that
$2*f(x + 5) = x$, which cannot be done.

As a negative example, consider
\[\forall{x}. \,2*f(x + 4) = x \,\lor \,2*f(x + 1) = x + 1\]
with the same preconditions as before, that is $2 \mid x$ and $2 \nmid x$.
Note that this formula doesn't satisfy the requirement~\ref{pre:3} since for $x_1=2$ and $x_2=5$
we try to write to $f(6)$ two times with different values. Furthermore, the
formula is unsatisfiable.

\section{Algorithm Improvement}

\begin{algorithm}
	\caption{Satisfiability Check}%
	\label{alg:sr2}
	\begin{algorithmic}[1]
		\Require $\phi = F \wedge \forall x \:.\: Q$, where $F$ is ground and $Q$ satisfies \req
		\Ensure \textsc{sat} or \textsc{unsat}
		\State $\ubar{I} \gets 0$, $\bar{I} \gets 0$ \Comment{Start with singleton interval}
		\State $\alpha \gets \smt(F)$
		\State $d = |c^{f_{i^{*}}}_1 - c^{f_{i^*}}_{l_{i^*}}|$

		\While{$\alpha \neq \bot$}

		\State $\text{condition} \gets d = |\mathit{c_{min}} - \mathit{c_{max}}| \land%
			\bigwedge_{t \in \args(F,f)} \ubar{I} + \mathit{c_{min}} \leq t \leq \bar{I} + \mathit{c_{max}}$
		\If{$\smt(F \wedge \bigwedge_{x=\ubar{I}}^{\bar{I}} Q \wedge \text{condition}) \neq \bot$}
		\State \Return \textsc{sat} \Comment{Certificate can be constructed}
		\EndIf

		\State $\mathcal{C} \gets \textsc{core}(F \wedge \bigwedge_{x=\ubar{I}}^{\bar{I}} Q \wedge \text{condition})$
		\Comment{Compute an \textsc{unsat} core}

		\If{for some $t$, $t \leq \bar{I} + \mathit{c_{max}} \in \mathcal{C}$}
		\State $\bar{I} \gets \bar{I} + 1$
		\EndIf
		\If{for some $t$, $\ubar{I} + \mathit{c_{min}} \leq t \in \mathcal{C}$}
		\State $\ubar{I} \gets \ubar{I} - 1$
		\EndIf

		\State $\alpha \gets \smt\left(F \wedge \bigwedge_{x=\ubar{I}}^{\bar{I}} Q\right)$
		\EndWhile

		\State \Return \textsc{unsat}
	\end{algorithmic}
\end{algorithm}


\subsection*{Few More Examples}

\begin{example}
	\[
		\forall{x}. \,f(x) < f(x + 1) + f(x + 2)
		\,\land \,f(x) < f(x + 1)
	\]
	ReqPivot is satisfied here. In the decreasing direction simply set $f(x+1), f(x+2)$ arbitrarily
	and set $f(x)$ as $\mathit{min}\{f(x + 1) + f(x + 2), f(x + 1)\} - 1$. In the increasing direction,
	first normalize the problem
	\[
		\forall{x}. \,f(x - 2) - f(x - 1) < f(x)
		\,\land \,f(x - 1) < f(x)
	\]
	Here we set $f(x)$ as $\mathit{max}\{f(x - 2) - f(x - 1), f(x - 1)\} + 1$.
\end{example}


\begin{example}\label{ex:ind-needed}
	\[
		\forall{x}. \,f(x) < f(x + 1) - f(x + 2)
		\,\land \,\forall{x}. \,f(x) < f(x + 1)
	\]
	Since $f$ is increasing there has to exist an $a$ for which $f(a) \geq 0$
	(this requires an inductive proof, see Section~\ref{sec:ind}).
	At the same time, $f(a) < f(a+1) - f(a+2)$ and $f(a+1) < f(a+2) - f(a+3)$. That means
	$f(a) < -f(a+3)$ but also $f(a) < f(a+3)$. Therefore, $f(a) < \text{min}\{-f(a+3), f(a+3)\}$.
	In other words $f(a) < 0$, a contradiction.
	\req is also not satisfied here. If we normalize the formulas like so
	\[
		\forall{x}. \,f(x)  < f(x - 1) - f(x - 2)
		\,\land \,f(x - 1) < f(x)
	\]
	and set $f(x - 2) > f(x - 1) > 0$, we can never find a value for $f(x)$ to satisfy the formula.
\end{example}


\section{Induction}\label{sec:ind}

In the solution of Example~\ref{ex:ind-needed}, we implicitly used the fact that the following
formula is \textsc{unsat}
\begin{equation}\label{eq:ind-needed}
	\forall{x}. \,f(x)<0 \,\land \,\forall{x}. \,f(x)<f(x+1)
\end{equation}
Note that one cannot prove that by instantiating the formula.\footnote{
	In general, we could look for bounds of the form $\forall x. \,f(x) < G$ for $G$ ground.
	If from the other quantified subformulas we can derive that $f$ is strictly increasing, we can conclude
	the entire formula is \textsc{unsat} over the integers.}
Indeed, every finite set of instantiations is satisfiable.
A similar result can be found in~\cite{ge-cav09}, where from compactness we have that
the above formula has as models only non-standard models of arithmetic (e.g.\ polynomials over $\mathbb{Z}$).

Using $\forall{x}. \,f(x)<f(x+1)$ we can prove by induction the lemma
\begin{equation}\label{eq:ind-needed-lemma}
	\forall{v}\exists{x}. \,f(x) \geq f(0) + v
\end{equation}
For the base case we have $\exists x. \,f(x) \geq f(0) + 0$ is valid when setting $x = 0$. For the induction step
assume for some $v$ and $x$ we have $f(x) \geq f(0) + v$. Now,
\[
	f(x) \geq f(0) + v \implies f(x) + 1 \geq f(0) + v + 1 \implies f(x+1) \geq f(0) + v + 1,
\]
where the second implication holds by the assumption that $f$ is increasing.
Instantiating the Lemma~\eqref{eq:ind-needed-lemma} by $v = -f(0)$
now proves Formula~\eqref{eq:ind-needed} is \textsc{unsat}, since we get
\[
	\forall{x}. \,f(x)<0 \land \exists{x}. \,f(x) \geq 0
\]

Another example where induction is needed is
\[
	f(0) = 0 \,\land \,f(c) = 3 \,\land \,\forall{x}. \,f(x+1) = f(x)
\]
Note that Algorithm~\ref{alg:sr} does not terminate on this example because in every $\alpha$
we can set $c$ to be outside $I$. The same goes for any instantiation method.
We can easily prove the lemma
\[
	\forall{x}. \,f(x) = 0
\]
from the first and third conjunct by induction. Again, only non-standard models of arithmetic satisfy this formula.

\section{\req}
\label{sec:req}

% \subsection{Terminology}

% The current version uses the term ``entity'' in a way that is not correct. There are three potential solutions:
% \begin{enumerate}
% 	\item Introduce a new term.
% 	\item Replace these terms by fresh variables that are then quantified.
% 	\item Use the weakened version of \req described below.
% \end{enumerate}
% The first solution is slightly informal, but more intuitive, the second one is formally rigorous, but may be unnecessarily convoluted, and the third depends on a version of the condition we have not yet discussed.

\subsection{Generalised ReqPivot: From Single to Multiple Pivot Functions}

The \req condition introduced in \cref{sec:alg} requires the existence of a \emph{single} pivot function $f_{i^*}$ whose maximal and minimal offset terms can be propagated, and it assumes that arguments to uninterpreted functions in the quantified part are of the form $x + k$ where $k$ is a numeral. We now generalise this notion in two ways:\todoSR{The generalization to higher arity is not difficult, but results in messy notation.}

\begin{enumerate}
    \item We allow \emph{multiple} functions to serve as pivots.
    \item We permit offset terms that are ground LIA terms $t$, not just numerals. Thus function arguments in the quantified part have the form $x + t$ where $t$ is a ground term.
\end{enumerate}

The core construction remains similar, i.e. we seek an interval $B = [b_{\min}, b_{\max}]$ —the ``base interval''—and an interpretation that satisfies the ground constraints together with all quantified instantiations inside $B$. Additionally, we require that the interpretation admits \emph{extension formulas} that guarantee the solution can be propagated outward from $B$ in both directions without clashing with the ground part. When such a $B$ and interpretation exist, a complete satisfiability certificate can be built, certifying that the formula is satisfiable.

\paragraph{Multi-\req Condition} First, we formalise the condition that enables propagation in both directions, generalising the single-pivot \req condition to allow multiple functions to serve as pivots.

\begin{definition}[Multi-\req Condition (parametric version)]
\label{def:multi-reqpivot-param}
Let $f_1, \dots, f_r$ be the uninterpreted function symbols appearing in $Q$, with $T_i = \{t^{f_i}_1, \dots, t^{f_i}_{l_i}\}$ being the offset terms for $f_i$.

For any choice of subsets $\mathcal{S} = (S_1,\dots,S_r)$ with $S_i \subseteq T_i$, define:

\begin{itemize}
    \item \textbf{Maximality condition $\Phi_{\text{max}}(\mathcal{S})$:}
        \[
        \bigwedge_{i=1}^{r} \left(
        \bigwedge_{t,t' \in S_i} t = t' \;\land\;
        \bigwedge_{t \in S_i, t' \in T_i \setminus S_i} t > t'
        \right).
        \]
    \item \textbf{Upward propagability condition $\Phi_{\text{prop-up}}(\mathcal{S})$:}\\
        \[\forall x \forall \bar{u}_1 \dots \forall \bar{u}_r \exists v_1\dots \exists v_r.\ Q'(\mathcal{S})\] where  $Q'(\mathcal{S})$ is the formula obtained from $Q$ by simultaneously replacing for all $i\in\{1,\dots,r\}$,
        \begin{itemize}
            \item every $f_i(x+t)$ such that $t \in S_i$ by $v_i$,
            \item every $f_i(x+t)$ such that $t \in T_i \setminus S_i$ by the corresponding $u_i^t \in \bar{u}_i$, where $\bar{u}_i = \{u_i^t \mid t \in T_i \setminus S_i\}$.
        \end{itemize}
\end{itemize}

Symmetrically, for downward propagation with subsets $\mathcal{S}' = (S'_1,\dots,S'_r)$, define 
$\Phi_{\text{min}}(\mathcal{S}')$ (with $<$ instead of $>$) and $\Phi_{\text{prop-down}}(\mathcal{S}')$.

We say that $Q$ satisfies the \emph{multi-\req condition for $(\mathcal{S}, \mathcal{S}')$} if
\begin{itemize}
    \item $\Phi_{\text{max}}(\mathcal{S})$ and $\Phi_{\text{prop-up}}(\mathcal{S})$ hold,
    \item $\Phi_{\text{min}}(\mathcal{S}')$ and $\Phi_{\text{prop-down}}(\mathcal{S}')$ hold.
\end{itemize}

We say $Q$ satisfies the \emph{multi-\req condition} if there exists \emph{some} pair~$(\mathcal{S}, \mathcal{S}')$ such that $Q$ satisfies the multi-\req condition for $(\mathcal{S}, \mathcal{S}')$.
\end{definition}

Intuitively, the multi‑\req condition generalises the single‑pivot \req condition by allowing \emph{multiple functions} to serve as pivots simultaneously. For upward propagation, we select for each function $f_i$ a subset $S_i$ of its offsets that are maximal (all equal and strictly greater than other offsets of $f_i$). The propagability condition then guarantees that, no matter what values are assigned to the non‑maximal occurrences, we can find values $v_1,\dots,v_r$ such that assigning $v_i$ to all occurrences $f_i(x+t)$ with $t\in S_i$ makes $Q$ true. Different functions may receive different values. The old single‑pivot \req is the special case where exactly one $S_i$ is non‑empty and contains a single offset. The downward condition is symmetric.


\begin{example}[Multi-\req Illustration---parameterised]
Consider the formula:
\[
\forall x.\ f(x+c+3) + f(x+4) + f(x+1) = g(x+2) + h(x)
\]
where $c$ is a ground constant. The offset terms for each function are:
\begin{align*}
T_f &= \{c+3,\ 4,\ 1\}, \quad T_g = \{2\}, \quad T_h = \{0\}.
\end{align*}
We have three offsets for $f$: a ground term $c+3$, and two numerals $4$ and $1$.

\medskip\noindent\textbf{Upward propagation:}
% Consider two possible choices:

% \begin{enumerate}
%     \item \textbf{Choice 1: Take only the numerically maximal offset}
Consider the choice $\mathcal{S} = (S_f, S_g, S_h) = (\{4\}, \{2\}, \emptyset)$.
    \begin{enumerate}
        \item \textbf{Maximality $\Phi_{\text{max}}(\mathcal{S})$:}
        \begin{itemize}
        \item For $f$: $S_f = \{4\}$, $T_f \setminus S_f = \{c+3, 1\}$
          % $4 > 1$ is true. $4 > c+3$ becomes a constraint: $c < 1$.
            \item For $g$: $S_g = \{2\}$, $T_g \setminus S_g = \emptyset$
            \item For $h$: $S_h = \emptyset$
            \end{itemize}
This results in $\Phi_{\text{max}}(\mathcal{S})\equiv 4 = 4 \land 4 > c+3 \land 4 > 1 \land\ 2=2$, which is true 
provided $c < 1$.

        \item \textbf{Propagability $\Phi_{\text{prop-up}}(\mathcal{S})$:}
        We introduce
        \begin{itemize}
            \item $v_f$ for $f(x+4)$,
            \item $v_g$ for $g(x+2)$,
            \item $u_f^{c+3}$ for $f(x+c+3)$ and $u_f^1$ for $f(x+1)$,
            \item $u_h^0$ for $h(x)$,
        \end{itemize}
        % The transformed $Q'$ is:
        % \[
        % u_f^{c+3} + v_f + u_f^1 = v_g + u_h^0
        % \]
         and get the propagability condition 
        \[
        \forall x \forall u_f^{c+3} \forall u_f^1 \forall u_h^0 \exists v_f \exists v_g.\ 
        u_f^{c+3} + v_f + u_f^1 = v_g + u_h^0.
        \]
        This is true: for any $u_f^{c+3}, u_f^1, u_h^0$, choose $v_g = 0$ and $v_f = u_h^0 - u_f^{c+3} - u_f^1$.
    \end{enumerate}
    
%     \item \textbf{Choice 2: Take the general term if it's maximal}
%     Alternatively, if $c+3 \geq 4$ (i.e., $c \geq 1$), we could choose:
%     \[
%     S_f = \{c+3\}, \quad S_g = \{2\}, \quad S_h = \emptyset.
%     \]
%     Then $\Phi_{\text{max}}$ requires $c+3 > 4$ and $c+3 > 1$, i.e., $c > 1$.
% \end{enumerate}

\medskip\noindent\textbf{Downward propagation:}
Consider the choice %Choice for downward: Take the numerically minimal offset}
$\mathcal{S}' = (S'_f, S'_g, S'_h) = (\{1\}, \emptyset, \{0\})$.
\begin{enumerate}
    \item \textbf{Minimality $\Phi_{\text{min}}(\mathcal{S}')$:}
    \begin{itemize}
        \item For $f$: $S'_f = \{1\}$, $T_f \setminus S'_f = \{c+3, 4\}$
        \item For $h$: $S'_h = \{0\}$, $T_h \setminus S'_h = \emptyset$
        \item For $g$: $S'_g = \emptyset$
        \end{itemize}
This results in $\Phi_{\text{min}(\mathcal{S}')}\equiv 1 = 1\land 1 < c+3 \land 1 < 4 \ \land\  0=0$, which is true provided
 $c > -2$.

    \item \textbf{Propagability $\Phi_{\text{prop-down}}(\mathcal{S}')$:}
    We introduce
    \begin{itemize}
        \item $v'_f$ for $f(x+1)$,
        \item $v'_h$ for $h(x)$,
        \item $u_f^{c+3}$ for $f(x+c+3)$ and $u_f^4$ for $f(x+4)$,
        \item $u_g^2$ for $g(x+2)$,
    \end{itemize}
    % The transformed $Q'$ is:
    % \[
    % u_f^{c+3} + u_f^4 + v'_f = u_g^2 + v'_h
    % \]
    % The propagability condition requires:
    and get the propagability condition
    \[
    \forall x \forall u_f^{c+3} \forall u_f^4 \forall u_g^2 \exists v'_f \exists v'_h.\ 
    u_f^{c+3} + u_f^4 + v'_f = u_g^2 + v'_h
    \]
    This is true: choose $v'_h = 0$ and $v'_f = u_g^2 - u_f^{c+3} - u_f^4$.
\end{enumerate}

\noindent\textbf{Putting it together:}
$Q$ satisfies multi-\req for the pair $(\mathcal{S},\mathcal{S}')$ if we can find $c$ satisfying both:
\begin{itemize}
    \item For upward: $c < 1$
    \item For downward: $c > -2$
\end{itemize}
Thus any $c \in (-2, 1)$ works. This demonstrates that for such $c$, the specific choices $\mathcal{S} = (\{4\},\{2\},\emptyset)$ and $\mathcal{S}' = (\{1\},\emptyset,\{0\})$ witness the multi‑\req condition. %If $c \geq 1$, we could use Choice 2 for upward ($c > 1$). 
\end{example}

Now, given a concrete interval $B = [b_{\min}, b_{\max}]$, we need additional ``clash conditions'' that prevent the entities generated during propagation from clashing with the ground part $F$.

\begin{definition}[Interval Extension Formulas (parameterised)]
\label{def:interval-extension-formulas-param}
For an interval $B = [b_{\min}, b_{\max}]$ and subsets $\mathcal{S} = (S_1,\dots,S_r)$, $\mathcal{S}' = (S'_1,\dots,S'_r)$, define:

\begin{enumerate}
    \item \textbf{Upward extension formula $\Psi_{\text{up}}(B,\mathcal{S})$}:
    \[
    \Phi_{\text{max}}(\mathcal{S})\;\land\; 
    \Phi_{\text{prop-up}}(\mathcal{S}) \;\land
    \bigwedge_{i=1}^{r} \bigwedge_{\substack{t_g \in \args(F,f_i) \\ t \in S_i}} t_g \leq b_{\max}+t
    \]
    where $\Phi_{\text{max}}(\mathcal{S})$ and $\Phi_{\text{prop-up}}(\mathcal{S})$ are as defined in \cref{def:multi-reqpivot-param}.
    
    \item \textbf{Downward extension formula $\Psi_{\text{down}}(B,\mathcal{S}')$}:
    \[
    \Phi_{\text{min}}(\mathcal{S}') \;\land\; 
    \Phi_{\text{prop-down}}(\mathcal{S}') \;\land
    \bigwedge_{i=1}^{r} \bigwedge_{\substack{t_g \in \args(F,f_i) \\ t \in S_i'}} t_g \geq b_{\min}+t
    \]
    where $\Phi_{\text{min}}(\mathcal{S}')$ and $\Phi_{\text{prop-down}}(\mathcal{S}')$ are as defined in \cref{def:multi-reqpivot-param}.
\end{enumerate}
\end{definition}

Thus, for any choice of subsets $\mathcal{S} = (S_1,\dots,S_r)$, $\Psi_{\text{up}}(\mathcal{S}, B)$ (resp.\ $\Psi_{\text{down}}(\mathcal{S}', B)$) asserts that $\mathcal{S}$ satisfies the upward (resp.\ $\mathcal{S}'$ satisfies the downward) conditions of multi‑\req \emph{and additionally} satisfies the clash condition for interval $B$. The clash condition ensures that no entity $f_i(z+t)$ with $z > b_{\max}$ (resp. $z < b_{\min}$) and $t \in S_i$ already appears in the ground part $F$.

\begin{theorem}[Interval Satisfiability (parameterised version)]
\label{thm:interval-certificate-param}
Let $B = [b_{\min}, b_{\max}]$ be a non‑empty integer interval, and let $\mathcal{S} = (S_1,\dots,S_r)$, $\mathcal{S}' = (S'_1,\dots,S'_r)$ be subsets satisfying the multi-\req condition for $(\mathcal{S}, \mathcal{S}')$ as defined in \cref{def:multi-reqpivot-param}.  
Then $\phi = F \land \forall x.\, Q$ has a satisfiability certificate — and hence is satisfiable — provided that
\[
\Bigl(F \land \bigwedge_{x \in B} Q[x]\Bigr) \;\land\; \Psi_{\text{up}}(B,\mathcal{S}) \;\land\; \Psi_{\text{down}}(B,\mathcal{S}')
\]
holds.
\end{theorem}

\begin{proof}
Suppose the conditions of the theorem hold, and let $I$ be an interpretation satisfying
\[
F \land \bigwedge_{x \in B} Q[x]\;\land\; \Psi_{\text{up}}(B,\mathcal{S}) \;\land\; \Psi_{\text{down}}(B,\mathcal{S}').
\]

We construct a certificate as in \cref{def:certificate}:

\begin{enumerate}
    \item \textbf{Well‑order $\preceq$ on $\mathbb{Z}$:}
    \[0, 1, -1, 2, -2, 3, -3, \dots, b_{\max}, b_{\min},b_{\max}+1, b_{\max}+2, \dots,b_{\min}-1, b_{\min}-2, \dots\]		
        
    \item \textbf{Pre‑satisfiability certificate:} $I$ 
    
    \item \textbf{Existential entities $X_z$ for $z \in \mathbb{Z}$:}
    \[
    X_z = 
    \begin{cases}
    \emptyset & \text{if } z \in B, \\[4pt]
    \bigl\{ f_i(z+t) \mid i=1,\dots,r,\; t \in S_i \bigr\} & \text{if } z > b_{\max}, \\[4pt]
    \bigl\{ f_i(z+t) \mid i=1,\dots,r,\; t \in S_i' \bigr\} & \text{if } z < b_{\min}.
    \end{cases}
    \]
    
    \item \textbf{Satisfiability propagators:}
    \begin{itemize}
        \item For $z \in B$: $I$ itself satisfies $Q[z]$.
        \item For $z > b_{\max}$: the condition $\Phi_{\text{prop-up}}(\mathcal{S})$ provides a function that, given values for all non‑existential entities in $\Gamma_{I,z}(\phi)$, returns values $v_1,\dots,v_r$ to assign to every $f_i(z+t)$ with $t \in S_i$, thereby satisfying $Q[z]$.
        \item For $z < b_{\min}$: the condition $\Phi_{\text{prop-down}}(\mathcal{S}')$ yields a propagator for the entities $f_i(z+t)$ with $t \in S_i'$.
    \end{itemize}
\end{enumerate}

It remains to verify the disjointness condition of \cref{def:certificate}:
\[
X_z \cap (\mathit{def}(I) \cup \bigcup_{z' \prec z} \Gamma_{I,z'}(\phi)) = \emptyset.
\]

\begin{itemize}
    \item For $z \in B$, $X_z = \emptyset$ holds trivially.
    \item For $z > b_{\max}$, consider any $f_i(z+t)$ with $t \in S_i$.
    \begin{itemize}
        \item It cannot belong to $\mathit{def}(I)$ because the clash condition $t_g \leq b_{\max} + t$ in $\Psi_{\text{up}}(B,\mathcal{S})$ guarantees $I(t_g) \leq b_{\max} + I(t) < z + I(t)$ for every $t_g \in \args(F,f_i)$.
        \item It cannot appear in any $\Gamma_{I,z'}(\phi)$ with $z' \prec z$ because either:
        \begin{enumerate}
            \item $z' \leq b_{\max}$: then $z'+I(t') \leq b_{\max} + I(t') < z + I(t)$ for all $t' \in T_i$,
            \item $b_{\max} < z' < z$: then $z'+I(t') \leq z'+ \max_{t'' \in T_i} I(t'') < z + I(t)$ since $I(t)$ is maximal among $\{I(t'') \mid t'' \in T_i\}$ by $\Phi_{\text{max}}(\mathcal{S})$.
        \end{enumerate}
    \end{itemize}

    \item The case $z < b_{\min}$ is symmetric, using $\Phi_{\text{min}}(\mathcal{S}')$ and the downward clash condition.
    % \item For $z < b_{\min}$, consider any $f_i(z+t)$ with $t \in S_i'$.
    % \begin{itemize}
    %     \item It cannot belong to $\mathit{def}(I)$ because the clash condition $t_g \geq b_{\min} + t$ in $\Psi_{\text{down}}(B,\mathcal{S}')$ guarantees $I(t_g) \geq b_{\min} + I(t) > z + I(t)$ for every $t_g \in \args(F,f_i)$.
    %     \item It cannot appear in any $\Gamma_{I,z'}(\phi)$ with $z' \prec z$ because either:
    %     \begin{enumerate}
    %         \item $z' \geq b_{\min}$: then $z'+I(t') \geq b_{\min} + I(t') > z + I(t)$ for all $t' \in T_i$,
    %         \item $z < z' < b_{\min}$: then $z'+I(t') \geq z'+ \min_{t'' \in T_i} I(t'') > z + I(t)$ since $I(t)$ is minimal among $\{I(t'') \mid t'' \in T_i\}$ by $\Phi_{\text{min}}(\mathcal{S}')$.
    %     \end{enumerate}
    % \end{itemize}
\end{itemize}

Thus all certificate requirements are satisfied. By \cref{prop:certThenSat}, $\phi$ is satisfiable.
\end{proof}

\cref{thm:interval-certificate-param} immediately yields an algorithm that searches for an interval $B$ satisfying the three conditions. 
% To use the parameterised version, the algorithm can iterate over candidate pairs $(\mathcal{S},\mathcal{S}')$.

\begin{algorithm}
\caption{Interval‑Based Sat Check (par. multi-\req) with $\bigvee$}
\label{alg:interval-check-param-withBigvee}
\begin{algorithmic}[1]
\Require $\phi = F \land \forall x.\, Q$ in the fragment
\Ensure \textsc{Sat} or \textsc{Unsat}
\State $b_{\min} \gets 0$, $b_{\max} \gets 0$ 
\State $I \gets \smt\!\left(F \land Q[0]\right)$
\While{$I \neq \bot$}
    \State $\text{max}_\text{up}\gets\bigvee_{S_1\subseteq T_1,\dots,S_r\subseteq T_r}\Psi_{\text{up}}([b_{\min},b_{\max}],(S_1,\dots,S_r))$
    \State $\text{min}_\text{down}\gets\bigvee_{S_1'\subseteq T_1,\dots,S_r'\subseteq T_r}\Psi_{\text{down}}([b_{\min},b_{\max}],(S_1',\dots,S_r'))$ 
    \If{$\smt\left(F \land \bigwedge_{x=b_{\min}}^{b_{\max}} Q[x] \land \text{max}_{\text{up}} \land \text{min}_{\text{down}}\right) \neq \bot$}
        \State \Return \textsc{Sat} 
    \EndIf
    \State $b_{\min} \gets b_{\min} - 1$, $b_{\max} \gets b_{\max} + 1$ \Comment{Expand interval symmetrically}
    \State $I \gets \smt\left(F \land \bigwedge_{x=b_{\min}}^{b_{\max}} Q[x]\right)$
\EndWhile
\State \Return \textsc{Unsat}
\end{algorithmic}
\end{algorithm}

% \begin{corollary}[Soundness (parameterised version)]
% \cref{alg:interval-check-param} is sound: if it returns \textsc{Sat}, then $\phi$ is satisfiable.
% \end{corollary}
% \begin{proof}
% When the algorithm returns \textsc{Sat}, it has found an interval $B$ and an interpretation satisfying the conditions of \cref{thm:interval-certificate-param} for some $(\mathcal{S},\mathcal{S}')$. Hence $\phi$ is satisfiable.
% \end{proof}

% \begin{theorem}[Relative Completeness (parameterised version)]
% \label{thm:relative-completeness-param}
% Let $\phi = F \land \forall x.\, Q$ be a formula in our fragment. If
% \begin{enumerate}
%     \item $\phi$ is satisfiable, and
%     \item $\phi$ satisfies the multi‑\req condition for some $(\mathcal{S},\mathcal{S}')$ as defined in \cref{def:multi-reqpivot-param},
% \end{enumerate}
% then \cref{alg:interval-check-param} terminates and returns \textsc{Sat}.
% \end{theorem}

% \begin{proof}
% Assume $\phi$ is satisfiable and satisfies multi‑\req for some pair $(\mathcal{S},\mathcal{S}') = (S_1,\dots,S_r, S'_1,\dots,S'_r)$. Let $\mathcal{M}$ be a model of $\phi$ and extract the corresponding entity interpretation $I^*$.

% For each $i$, define:
% \[
% v_{\max}^i = \max\{\, I^*(t) \mid t \in T_i \,\}, \qquad
% v_{\min}^i = \min\{\, I^*(t) \mid t \in T_i \,\}.
% \]

% The conditions $\Phi_{\text{max}}(\mathcal{S})$ and $\Phi_{\text{min}}(\mathcal{S}')$ ensure that:
% \begin{itemize}
%     \item For all $t \in S_i$: $I^*(t) = v_{\max}^i$,
%     \item For all $t \in S_i'$: $I^*(t) = v_{\min}^i$.
% \end{itemize}

% Now choose
% \[
% b_{\max} = \max\{\, I^*(t_g) - v_{\max}^i \mid t_g \in \args(F,f_i),\; i=1,\dots,r \,\},
% \]
% \[
% b_{\min} = \min\{\, I^*(t_g) - v_{\min}^i \mid t_g \in \args(F,f_i),\; i=1,\dots,r \,\}.
% \]

% Set $B = [b_{\min}, b_{\max}]$. We verify that $I^*$ satisfies the three conditions:

% \begin{enumerate}
%     \item \textbf{Base interval satisfiability:} 
%     $I^* \models F \land \bigwedge_{x \in B} Q[x]$ since $\mathcal{M} \models \phi$.
    
%     \item \textbf{Upward extension:} 
%     For $\Psi_{\text{up}}(B,\mathcal{S})$, we have:
%     \begin{itemize}
%         \item $\Phi_{\text{max}}(\mathcal{S})$ holds by definition of $\mathcal{S}$.
%         \item $\Phi_{\text{prop-up}}(\mathcal{S})$ holds by the multi-\req condition for $(\mathcal{S},\mathcal{S}')$.
%         \item For each $i$ and each $t_g \in \args(F,f_i)$ with $t \in S_i$:
%         \[
%         I^*(t_g) \leq b_{\max} + v_{\max}^i = b_{\max} + I^*(t)
%         \]
%         by construction of $b_{\max}$.
%     \end{itemize}
    
%     \item \textbf{Downward extension:} 
%     For $\Psi_{\text{down}}(B,\mathcal{S}')$, we have:
%     \begin{itemize}
%         \item $\Phi_{\text{min}}(\mathcal{S}')$ holds by definition of $\mathcal{S}'$.
%         \item $\Phi_{\text{prop-down}}(\mathcal{S}')$ holds by the multi-\req condition for $(\mathcal{S},\mathcal{S}')$.
%         \item For each $i$ and each $t_g \in \args(F,f_i)$ with $t \in S_i'$:
%         \[
%         I^*(t_g) \geq b_{\min} + v_{\min}^i = b_{\min} + I^*(t)
%         \]
%         by construction of $b_{\min}$.
%     \end{itemize}
% \end{enumerate}

% Thus $I^*$ satisfies all conditions. Let $N = \max(|b_{\min}|, |b_{\max}|)$. 

% Now consider \cref{alg:interval-check-param}. For the pair $(\mathcal{S},\mathcal{S}')$, the algorithm starts with $[b_{\min}, b_{\max}] = [0, 0]$ and expands symmetrically. When it reaches iteration $n = N$, the interval becomes $[-N, N]$, which contains $B$. 

% At that iteration, the $\smt$ call on line~8 of \cref{alg:interval-check-param} will check:
% \[
% F \land \bigwedge_{x=-N}^{N} Q[x] \land \Psi_{\text{up}}([-N,N],\mathcal{S}) \land \Psi_{\text{down}}([-N,N],\mathcal{S}')
% \]
% Since $[-N, N]$ contains $B$, and $I^*$ satisfies all the conditions, this formula is satisfiable (witnessed by $I^*$). Therefore, the algorithm will return \textsc{Sat} for this pair $(\mathcal{S},\mathcal{S}')$.
% \end{proof}

We keep \cref{alg:interval-check-param-withBigvee} as simple as possible, not taking into account efficiency considerations. We will now turn to efficiency.

Observations:
\begin{itemize}
\item $\Phi_{\text{max}}$ and $\Phi_{\text{prop-up}}$ (and their dual counter-parts) do not depend on the interval $B$.
\item Some special cases (e.g., all offsets are fixed integers) might enable some more efficient treatment.
\item We may exploit the capability of SMT solvers to do incremental solving.
\item The formula used in Algorithm~\ref{alg:interval-check} is not in CNF, which is required by SMT solvers. We can either call the solver separately on the individual disjuncts of $\Psi_{\text{up}}([b_{\min},b_{\max}])$ and $\Psi_{\text{down}}([b_{\min},b_{\max}])$, or transform it into CNF using auxiliary variables.
\item The idea of using unsat cores to decide how to expand the interval (Algorithm~\ref{alg:sr2}) is also applicable.
\item The more elements $S_i$ contains, the weaker the pivot condition becomes (i.e., the easier it is to satisfy). On the other hand, if $S_i$ is empty, then the clash condition is trivially satisfied, which may avoid many algorithm iterations (e.g., in cases where $f_i$ as a big integer argument in the ground part~$F$).
\item In the case where big integers arguments occur in the ground part~$F$, we may use these integers to appropriately initialize the interval $[b_{\min},b_{\max}]$.
\item Perhaps pre‑compute candidate subsets $S_i$ that satisfy $\Phi_{\text{max}}$ or $\Phi_{\text{min}}$, then check only those disjuncts.
\end{itemize}

Idea for CNF representation:
\begin{enumerate}
\item For each offset term $t_j^{f_i}, i\in \{ 1,\dots, r\}, j\in \{ 1,\dots, l_i\} $ use a propositional variable $s_j^{f_i}$ that is true iff $s_1^{f_i}\in S_i$. 
  
\item Replace the disjunction $\bigvee_{S_1\subseteq T_1,\dots,S_r\subseteq T_r}$ by an encoding using these variables. For example, the maximality condition $\Phi_{\text{max}}$ then reads as
        % $\Phi_{\text{max}}(S_1,\dots,S_r)$:}
        \[
        \bigwedge_{i\in \{1,\dots, r\}} 
          \bigwedge_{j,j' \in \{1,\dots, l_i\} } [\neg s_j\vee \neg s_{j'}\vee  t^{f_i}_{j}=t^{f_i}_{j'}] \;\land\; [\neg s_j\vee s_{j'} \vee  t^{f_i}_{j}>t^{f_i}_{j'} ]
        \]

\end{enumerate}

\begin{algorithm}
\caption{Interval‑Based Satisfiability Check (parameterised multi-\req)}
\label{alg:interval-check-param}
\begin{algorithmic}[1]
\Require $\phi = F \land \forall x.\, Q$ in the fragment
\Ensure \textsc{Sat} or \textsc{Unsat}
\State $\mathcal{C} \gets \{(\mathcal{S},\mathcal{S}') \mid Q \text{ satisfies multi-\req for } (\mathcal{S},\mathcal{S}')\}$
\For{each $(\mathcal{S},\mathcal{S}') \in \mathcal{C}$}
    \State $b_{\min} \gets 0$, $b_{\max} \gets 0$ 
    \State $I \gets \smt\!\left(F \land Q[0]\right)$
    \While{$I \neq \bot$}
        \State Construct $\Psi_{\text{up}}([b_{\min},b_{\max}],\mathcal{S})$ and $\Psi_{\text{down}}([b_{\min},b_{\max}],\mathcal{S}')$ \Comment{\cref{def:interval-extension-formulas-param}}
        \If{$\smt\left(F \land \bigwedge_{x=b_{\min}}^{b_{\max}} Q[x] \land \Psi_{\text{up}} \land \Psi_{\text{down}}\right) \neq \bot$}
            \State \Return \textsc{Sat} 
        \EndIf
        \State $b_{\min} \gets b_{\min} - 1$, $b_{\max} \gets b_{\max} + 1$ \Comment{Expand interval symmetrically}
        \State $I \gets \smt\left(F \land \bigwedge_{x=b_{\min}}^{b_{\max}} Q[x]\right)$
    \EndWhile
\EndFor
\State \Return \textsc{Unsat}
\end{algorithmic}
\end{algorithm}



\section*{Related Work}\label{}
Synthesis of recursive functions by Hozzov\'a et al.~\cite{hozzova-ijcar24}.
Synthesis of strategies on LIA problems Murphy and Kincaid~\cite{kincaid-cav24}.
Synthesis, single invocation Kun\v cak et
al.~\cite{kuncak-pldi10,kuncak-sttt13}.
Array decision procedures~\cite{bradley-vmcai06}: no arithmetic on universally quantified variables allowed.
Habermehl et al.~\cite{habermehl-etaps08} allow difference bounded constraints on array offsets of the form $a[i+c]$. From the MBQI paper: ``For certain cases containing offsets on array indices, our procedure will result in an infinite set of instantiations, while a decision procedure of LIA\footnote{LIA does not refer to linear integer arithmetic, but to the logic allowed by Habermehl et al.}  will terminate. It leaves an open question for future research on how to reason about this type of formulas within an instantiation-based approach.''
Alberti et al.~\cite{alberti2014decision}: only one universally quantified variable allowed.
Elad et al.~\cite{elad2024infinite}: The fragment of FOL for which they prove decidability (OSC, Section~6) does not allow anything like integer arithmetic.

\cite{reynolds2016model}: needs to user to ensure admissibility (Definition~2), the underlying finite model finding algorithm~\cite{reynolds2013finite} may introduce many case splits (``merge lemmas'') for satisfying cardinality constraints. \todoSR{I added a few words here}

computer algebra algorithms for solving difference equations

\section*{What Can't the Previous Work Solve?}

Here, I am considering the works~\cite{bradley-vmcai06, ge-cav09, habermehl-etaps08}.

\subsection*{Infinitely Increasing But Bounded Integer Sequence}

\[
	\forall{x}. \,f(x)<0 \,\land \,\forall{x}. \,f(x)<f(x+1)
\]

The syntax in~\cite{habermehl-etaps08} includes $\leq$ but does not include $<$. It does include negation though, but only if it
results in the quantified variables being existential. This cannot be solved by~\cite{bradley-vmcai06} (see Theorem 4 in their paper).
\textsc{Z3} cannot solve this on its own but with the addition of Lemma~\ref{eq:ind-needed-lemma} it can.
Adding the lemma also helps Vampire but not \textsc{cvc5}.

\subsection*{Two-Valued Constant Function}

\[
	f(0) = 0 \,\land \,f(c) = 3 \,\land \,\forall{x}. \,f(x+1) = f(x)
\]

In the last meeting I hand-wavedly assumed this cannot be in the fragment of~\cite{habermehl-etaps08}.
However, it is. They accept the literals $f(x) - f(x+1) \leq 0$ and $f(x+1) - f(x) \leq 0$, which in conjunction simplify
to $f(x) = f(x+1)$. They can then universally quantify this to form an array property. The other equalities can
be formed as value expressions $A \leq B \,\land \,B \leq A$. I can look more thoroughly at the paper
to see how can they solve this.
This cannot be solved by~\cite{bradley-vmcai06}, because the
third conjunct contains $x+1$ as an argument of $f$ (Theorem 4 in their paper).
\textsc{Z3} cannot solve this -- Compactness section in~\cite{ge-cav09}.

\section*{Constructing Certificates}\marek{Is this section still relevant for us?}\todoSN{Should we put some of the examples here right after we have \cref{def:certificate}?}

Very rough idea:
\begin{enumerate}
	\item solve quantifier-free part
	\item check solution against instantiations of quantified part with all entities already assigned,
	      if not satisfied, learn a clause and backtrack to solving
	\item order all other instantiations and construct the necessary certificates
\end{enumerate}

\begin{example}
	\[ \forall x \:.\: g(x+2)=g(x)+1 \]
	\begin{itemize}
		\item order: $0,1,\dots, -1, -2, \dots$
		\item corresponding existential entities: $g(2), g(3), \dots, g(-1), g(-2), \dots$   \footnote{Formally speaking also $g(0)$ is existential for the instantiation with $0$, and $g(1)$ for the instantiation with $1$. However, assuming them to be non-existential allows for a uniform construction of satisfiability propagators. This ensures correctness, see the comment after the definition of satisfiability certificate.}
		\item satisfiability propagators for the two blocks in the order: $g(x) = g(x-2)+1$, $g(x) = g(x+2)-1$
	\end{itemize}
\end{example}

\begin{example}
	\[ g(0)=10\wedge g(2)=10\wedge\forall x \:.\: g(x+2)=g(x) \]
	\begin{itemize}
		\item order
		      \begin{enumerate}
			      \item $g(x+2)=g(x)$ for $x=0, 1, \dots$
			      \item $g(x+2)=g(x)$ for $x=-1,-2,\dots$
		      \end{enumerate}
		\item pre-satisfiability certificate $\{ g(0)\mapsto 10, g(2)\mapsto 10 \}$
		\item propagators:
		      \begin{enumerate}
			      \item $x=0$: nothing to assign
			      \item $x=1,\dots$: $g(x)=g(x-2)$
			      \item $x=-1,-2,\dots$: $g(x)=g(x+2)$
		      \end{enumerate}
	\end{itemize}
\end{example}

\begin{example}
	\[f(3, a) \geq 4 + g(b) \wedge (\forall x, y \:.\: f(x, y) <x + g(y)) \wedge (\forall x \:.\: g(x) = g(x+2))\]
	\begin{itemize}
		\item order on constraints, block-wise:
		      \begin{enumerate}
			      \item $f(x,y) <x+g(y)$ for $(x,y)= (3,0)$
			      \item $g(x) = g(x + 2)$ for $x= 0, 1, \dots$
			      \item $g(x) = g(x + 2)$, for $x= -1, -2, \dots$,
			      \item any order on the rest of $\forall x,y. \;f(x,y) < x + g(y)$ (i.e., (x,y) $\not=$ (3,0))
		      \end{enumerate}
		\item pre-satisfiability certificate: $\{ a\mapsto 0, b\mapsto 1, f(3,0)\mapsto 4, g(1)\mapsto 0\}$
		\item satisfiability propagators:
		      \begin{enumerate}
			      \item $g(0)=2$
			      \item $g(x)= g(x-2)$
			      \item $g(x)=g(x+2)$
			      \item $f(x,y)=x+g(y)-1$
		      \end{enumerate}
	\end{itemize}
\end{example}

\begin{example}
	\[\forall x \;.\; f(x) + f(x+3) < f(x+2)\]
	\begin{itemize}
		\item order on constraints:
		      \begin{enumerate}
			      \item $f(0) + f(3) < f(2)$
			      \item $f(1) + f(4) < f(3)$
			      \item $f(x) + f(x + 3) < f(x + 2)$ for $x = 2, 3, \dots$
			      \item $f(x) + f(x + 3) < f(x + 2)$ for $x = -1, -2, \dots$
		      \end{enumerate}
		\item satisfiability propagators:
		      \begin{enumerate}
			      \item $f(0) = 0, f(2) = 2, f(3) = 1$
			      \item $f(1) = 0, f(4) =0$
			      \item $f(x) = f(x-1) - f(x-3) - 1$
			      \item $f(x) = - f(x+3) + f(x+2)  - 1$
		      \end{enumerate}
	\end{itemize}
\end{example}

\addtocounter{example}{-1}
\begin{example}[Continued]
	Another approach in solving the problem in the previous example is the following.
	Let us assume that $f$ is a linear map. Then,
	\[f(x) + f(x+3) - f(x+2) = f(x+1)\]
	We can then rewrite the problem as
	\[f(y) < 0\]
	Here, $f$ is a so called \emph{single invocation} symbol. That means we can deskolemize $f$
	and get
	\[\exists z. \, z<0\]
	Next, we can eliminate $z$ and get the formula $-1<0$, which simplifies to $\top$.

	The original problem is thus satisfiable. What's more, the value for $z$ after
	elimination gives us a satisfying assignment to $f$:
	\[f = \{\mapsto -1\}\]
\end{example}

\begin{example}
	\[f(x) + g(x-1) > x\]

	\begin{itemize}
		\item deskolemize $f \longrightarrow \exists y. \;y + g(x - 1) > x$
		\item deskolemize $g \longrightarrow \exists y, z. \;y + z > x$
		\item we have the formula $\psi = \forall x \exists y, z. \; y + z > x$
		\item eliminate $z$ from $\psi \longrightarrow \forall x \exists y. \; x - y + 1 > x - y$
		\item we get the formula $\forall x \exists y. \; 1 > 0$, which simplifies to $\top$
		\item $f$ is unconstrained and $g(x-1) = x - f(x) + 1$
		\item a possible model is then
	\end{itemize}
	\begin{gather*}
		f = \{\mapsto 0\} \\
		g = \{x \mapsto x + 2\}
	\end{gather*}
\end{example}


\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
