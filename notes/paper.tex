\documentclass{article}
\usepackage[textwidth=3cm]{todonotes}
\usepackage[utf8]{inputenc}
\usepackage{amssymb, amsthm, amsmath}
\usepackage{numprint}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\usepackage{hyperref}

\renewcommand{\algorithmicrequire}{\textbf{Input:}}
\renewcommand{\algorithmicensure}{\textbf{Output:}}

\newtheorem{definition}{Definition}
\newtheorem{property}{Property}
\newtheorem{example}{Example}
\npthousandsep{,}
\newcommand{\gmodel}{\mathcal{M}}





\newcommand{\todoSR}[1]{\todo[color=blue!40]{#1}}

\title{
    Iterative Function Definitions
}
\author{Stefan Ratschan \and Marek Dančo \and Mikoláš Janota}
\date{}

\begin{document}

\maketitle

\section*{Motivating Example}
Consider the following UFLIA formula:
\[
    \varphi =
    \underbrace{(f(3, a) \geq 4 + g(b))}_{\varphi_G}\,\land \,
    \underbrace{(\forall x, y. \,f(x, y) < x + g(y))}_{\varphi_1}\,\land \,
    \underbrace{(\forall x. \,g(x) = g(x + 2))}_{\varphi_2}
\]
Note that currently, the SMT solver Z3 cannot prove $\varphi$ is satisfiable.
However, we show there is an algorithmic way of proving the satisfiability
of this formula and try to identify UFLIA fragments in which this algorithm is applicable.

Let $\gmodel$ be the following partial model of the ground part $\varphi_G$:
\begin{gather*}
    a^\gmodel = 0, \\
    b^\gmodel = 1, \\
    f^\gmodel = \{(3, 0) \mapsto 4\}, \\
    g^\gmodel = \{1 \mapsto 0\}.
\end{gather*}
The definitions of $f^\gmodel, g^\gmodel$ on the rest of the domain are not interesting at this point.
Notice that because of the structure of $\varphi_2$ and the fact that $g^{\gmodel}(1) = 0$,
we can now define $g^{\gmodel}$ on all odd integers.
Specifically, we can first order the arguments of $g$ in $\varphi_2$ with $x \prec x+2$, and define
$g^\gmodel(3), g^\gmodel(5), g^\gmodel(7), \dots$ by unifying $x$ with $1, 3, 5, \dots$ and then set $x+2 \prec x$ and define
$g^\gmodel(-1), g^\gmodel(-3), g^\gmodel(-5), \dots$ by unifying $x+2$ with $1, -1, -3, \dots$ That is, we can define
$g^\gmodel(A_2)$ using $g^\gmodel(A_1)$ if we have $A_1 \prec A_2$.
This way we can expand $\gmodel$ to also be a partial model of $\varphi_2$.

Since $f^{\gmodel}(3,0) = 4$ and it must hold that $f(3,0) < 3 + g(0)$, we can set $g^{\gmodel}(0) = 2$.
Just like above, we can now define $g^{\gmodel}$ on all even integers and thus obtain a total
interpretation of $g$.
Now, for any pair $(x, y)$ of integers, we can define $f^{\gmodel}(x, y)$ to be
$x + 1$ or $x - 1$ for even or odd $y$ respectively. In the end, we can expand $\gmodel$
to a model of $\varphi$.

Observe it must be that $a \not= b$, otherwise
$f(3, a) \geq 4 \,+ \,g(b) \,\land \,f(3, a) < 3 \,+ \,g(a)$ is unsatisfiable.
Consequently, $\gmodel$ must be such that $a^{\gmodel} \not= b^{\gmodel}$.
We can check the compatibility of $\gmodel$ with the rest of the formula
after each step of our procedure and when a conflict is found,
we can learn the new ground literals from the \textsc{unsat} core and
restart the procedure with the updated ground part.

\emph{Goal}: Proving satisfiability of UFLIA formulas (or UFNIA) formulas (which may prove unsat on the way).
In the following, a formula will always refer to a UFNIA formula whose only quantifiers are universal
quantifiers over integer variables.

\emph{Idea}: View quantifiers as something that expresses infinitely many constraints on entities. The problem is that a
single entity may occur in several such constraints and we must avoid assigning different values to the very same entity.
To prove satisfiability of a formula, order these constraints and use a symbolic representation of the satisfying assignment
that assigns values to entities in such a way that following the order of constraint avoids assigning different
values to the very same entity.

\section*{Definitions}

\begin{definition}
    Given a formula $\phi$, a \emph{satisfiability certificate}\todoSR{I slightly polished the definition, and added the property and proof below} is
    \begin{itemize}
        \item an order\footnote{We will assume this to be a well-order (i.e., a total order for which every non-empty subset has a least element), which enables induction. However, to allow sub-formulas to be at the same place in the order, we either need to combine them into equivalence classes or relax anti-symmetry.} on all instantiations of quantified sub-formulas of $\phi$, viewing the quantifier-free part as quantified with an empty tuple of quantified variables, hence having one instantiation, and
        \item for each instantiation of a quantified sub-formula of $\phi$
              \begin{itemize}
                  \item a subset of its entities marked as existential such that the existential entities do not occur in any formula instantiation occurring before according to the given order, and
                  \item a certificate showing that for all values of the non-existential entities there exist values of the existential ones satisfying this instantiation, which we will call \emph{satisfiability propagator}\footnote{Ideally, satisfiability propagators should be constructive. That is, they should take the form of an algorithm that computes these values. In many cases, they can even be synthesized automatically from the quantifier elimination problem~\cite{kuncak-sttt13}.  But at some point, we might allow satisfiability propagators of a different form, for example,
    to represent real-algebraic number solutions in the case of the reals}.
              \end{itemize}
    \end{itemize}
  \end{definition}

  \begin{property}
    Every formula that has a satisfiability certificate is satisfiable.
  \end{property}

  \begin{proof}
    We use the principle of induction on well-orders. Let $y$ be an instantiation of a quantified sub-formula, and let $X$ be the set of all instantiations of quantified sub-formulas $x$ with $x<y$. We assume that $\bigwedge_{x\in X} x$ is satisfiable, and prove that $\bigwedge_{x\in X} x\wedge y$ is satisfiable, as well. Since the formula has a satisfiability certificate, the existential entities of $y$ do not occur in any element of $X$. Let $\alpha$ be a variable assignment satisfying $\bigwedge_{x\in X} x$. Let $\alpha'$ be the extension of $\alpha$ that assigns to the existential entities of $y$ the values whose existence is  confirmed by the satisfiability propagator. Since these do not occur in $X$, for all entities occurring in $X$, the value of $\alpha'$ is the same as the value of $\alpha$. Hence $\alpha'$ satisfies both $\bigwedge_{x\in X} x$ and $y$, and so it satisfies $\bigwedge_{x\in X} x\wedge y$. 
  \end{proof} 

  The goal is now an algorithm that computes such satisfiability certificates and a converse of the property that shows for certain classes of satisfiable  formulas this algorithm succeeds.

\section*{Constructing Certificates}
Very rough idea:
\begin{enumerate}
    \item solve quantifier-free part
    \item check solution against instantiations of quantified part with all entities already assigned,
          if not satisfied, learn a clause and backtrack to solving
    \item order all other instantiations and construct the necessary certificates
\end{enumerate}

\begin{example}
    \[ \forall x \:.\: g(x+2)=g(x)+1 \]
    \begin{itemize}
        \item order: $0,1,\dots, -1, -2, \dots$
        \item corresponding existential entities: $g(2), g(3), \dots, g(-1), g(-2), \dots$   (note that g(0) and g(1) are not
              existential anywhere, and hence can be chosen arbitrarily)
        \item satisfiability propagators for the two blocks in the order: $g(x) = g(x-2)+1$, $g(x) = g(x+2)-1$
    \end{itemize}
\end{example}

\begin{example}\todoSR{new}
  \[ g(0)=10\wedge g(2)=10\wedge\forall x \:.\: g(x+2)=g(x) \]
  \begin{itemize}
  \item order (same item means both $\leq$ and $\geq$):
    \begin{enumerate}
    \item $g(0)=10$, $g(2)=10$, $g(x+2)=g(x)$ for $x=0$
    \item $g(x+2)=g(x)$ for $x=1, 2, \dots$
    \item $g(x+2)=g(x)$ for $x=-1,-2,\dots$
    \end{enumerate}
  \item corresponding existential entities (here $g(1)$ is not existential anywhere, and hence can be chosen arbitrarily):
    \begin{enumerate}
    \item $g(0), g(2)$
    \item $g(3),g(4),\dots$
    \item $g(-1),g(-2),\dots$
    \end{enumerate}
  \item propagators: 
    \begin{enumerate}
    \item $g(0)=10$, $g(2)=10$
    \item $g(x)=g(x-2)$
    \item $g(x)=g(x+2)$
    \end{enumerate}
  \end{itemize}
\end{example}

\begin{example}\todoSR{new}
  \[ g(0)=10\wedge g(2)=13\wedge\forall x \:.\: g(x+2)=g(x) \]
  does not have a satisfiability certificate:
  \begin{itemize}
  \item  If the instantiation $x\leftarrow 0$ would come before any of $g(0)=10$ and $g(2)=13$, let us say before $g(0)=10$, $g(2)$ cannot be existential for $g(2)=13$ and hence this constraint would have to hold \emph{for all} values of $g(2)$, which is not true.
  \item  If the instantiation $x\leftarrow 0$ would come after both $g(0)=10$ and $g(2)=13$, this would make both $g(0)$ and $g(2)$ non-existential. As a result, $g(0)=g(2)$ would need to be true \emph{for all} values of $g(0)$ and $g(2)$, which is does not.
  \end{itemize}

\end{example}


\begin{example}
    \[f(3, a) \geq 4 + g(b) \wedge (\forall x, y \:.\: f(x, y) <x + g(y)) \wedge (\forall x \:.\: g(x) = g(x+2))\]
    \begin{itemize}
        \item order on constraints, block-wise:
              \begin{enumerate}
                  \item $f(3, a) \geq 4 + g(b)$
                  \item $f(x,y) <x+g(y)$ for $(x,y)= (3,0)$
                  \item $g(x) = g(x + 2)$ for $x= 0, 1, \dots$
                  \item $g(x) = g(x + 2)$, for $x= -1, -2, \dots$,
                  \item any order on the rest of $\forall x,y. \;f(x,y) < x + g(y)$ (i.e., (x,y) $\not=$ (3,0))
              \end{enumerate}
        \item corresponding existential entities:
              \begin{enumerate}
                  \item $\{a, b, f(3,0), g(1)\}$
                  \item $\{ g(0)\}$
                  \item $\{ g(2) \}, \{ g(3) \}, \dots$
                  \item $\{ g(-1) \}, \{ g(-2) \}, \dots$
              \end{enumerate}
        \item satisfiability propagators:
              \begin{enumerate}
                  \item $a=0, b=1, f(3,0)=4, g(1)=0$
                  \item $g(0)=2$
                  \item $g(x)= g(x-2)$
                  \item $g(x)=g(x+2)$
                  \item $f(x,y)=x+g(y)-1$
              \end{enumerate}
    \end{itemize}
\end{example}

\begin{example}
    \[f(x) + f(x+3) < f(x+2)\]
    \begin{itemize}
        \item order on constraints:
              \begin{enumerate}
                  \item $f(0) + f(3) < f(2)$
                  \item $f(1) + f(4) < f(3)$
                  \item $f(x) + f(x + 3) < f(x + 2)$ for $x = 2, 3, \dots$ and $x = -1, -2, \dots$
              \end{enumerate}
        \item corresponding existential entities:
              \begin{enumerate}
                  \item $\{f(0), f(2)\}$
                  \item $\{f(1)\}$
              \end{enumerate}
        \item satisfiability propagators:
              \begin{enumerate}
                  \item $f(0) = 0, f(1) = 1, f(2) = 2$
                  \item $f(x) = f(x-1) - f(x-3) - 1$
              \end{enumerate}
    \end{itemize}
\end{example}

\addtocounter{example}{-1}
\begin{example}[Continued]
    Another approach in solving the problem in the previous example is the following.
    Let us assume that $f$ is a linear map. Then,
    \[f(x) + f(x+3) - f(x+2) = f(x+1)\]
    We can then rewrite the problem as
    \[f(y) < 0\]
    Here, $f$ is a so called \emph{single invocation} symbol. That means we can deskolemize $f$
    and get
    \[\exists z. \, z<0\]
    Next, we can eliminate $z$ and get the formula $-1<0$, which simplifies to $\top$.

    The original problem is thus satisfiable. What's more, the value for $z$ after
    elimination gives us a satisfying assignment to $f$:
    \[f = \{\mapsto -1\}\]
\end{example}

\begin{example}
    \[f(x) + g(x-1) > x\]

    \begin{itemize}
        \item deskolemize $f \longrightarrow \exists y. \;y + g(x - 1) > x$
        \item deskolemize $g \longrightarrow \exists y, z. \;y + z > x$
        \item we have the formula $\psi = \forall x \exists y, z. \; y + z > x$
        \item eliminate $z$ from $\psi \longrightarrow \forall x \exists y. \; x - y + 1 > x - y$
        \item we get the formula $\forall x \exists y. \; 1 > 0$, which simplifies to $\top$
        \item $f$ is unconstrained and $g(x-1) = x - f(x) + 1$
        \item a possible model is then
    \end{itemize}
    \begin{gather*}
        f = \{\mapsto 0\} \\
        g = \{x \mapsto x + 2\}
    \end{gather*}
\end{example}


\section*{Algorithm}
~\ref{alg}

\begin{algorithm}
    \caption{Algorithm Prototype}\label{alg}
    \begin{algorithmic}[1]
        \Require $\psi = \forall x. \,\varphi(x, f(x))$, where $f$ is single invocation and
        $\psi$ is satisfiable
        \Ensure A satisfying assignment to $f$
        \State $\psi_1 \gets \forall x \exists y . \, \varphi(x, y)$
        \Comment{deskolemize $f$ in $\psi$}
        \State $\psi_2 \gets \bigvee_{} \forall x. \,\varphi(x)[c]$
        \Comment{eliminite $y$ from $\psi_1$}
        \State $\psi_3 \gets \bigwedge_{d \in T}\bigvee_{c \in S}  \,\varphi[d, c]$
        \Comment{eliminite $x$ from $\psi_2$}
        \State $\mathcal{L} \gets$ true literals in \textsc{sat}($\psi_3$)
        \State $\{(d_1, c_1), \dots, (d_n, c_n)\} \gets$ values of $d, c$ in $\mathcal{L}$
        \State \Return $f = \{d_1 \mapsto c_1, \dots, d_n \mapsto c_n\}$
    \end{algorithmic}
\end{algorithm}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{Related Work}\label{}
Synthesis of recursive functions by Hozzov\'a et al.~\cite{hozzova-ijcar24}.
Synthesis of strategies on LIA problems Murphy and Kincaid~\cite{kincaid-cav24}.
Synthesis, single invocation Kun\v cak et
al.~\cite{kuncak-pldi10,kuncak-sttt13}.

\bibliographystyle{abbrv}
\bibliography{refs}

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
