\documentclass{article}
\usepackage[textwidth=3cm,tickmarkheight=3pt]{todonotes}
\usepackage[utf8]{inputenc}
\usepackage{amssymb, amsthm, amsmath}
\usepackage{numprint}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\usepackage{color}
\definecolor{citeblue}{rgb}{0.1,0,.4}
\usepackage[pdftex%
,colorlinks=true%
,bookmarks=true%
,linkcolor=citeblue%
,citecolor=citeblue%
,urlcolor=blue%
,plainpages=false]{hyperref}
\usepackage{commath}
\usepackage[most]{tcolorbox}

\renewcommand{\algorithmicrequire}{\textbf{Input:}}
\renewcommand{\algorithmicensure}{\textbf{Output:}}

\newtheorem{definition}{Definition}
\newtheorem{property}{Property}
\newtheorem{example}{Example}

\newtheorem{theorem}{Theorem}
\theoremstyle{remark}
\newtheorem{claim}{Claim}
\usepackage{etoolbox}
\AtEndEnvironment{proof}{\setcounter{claim}{0}}

\npthousandsep{,}
\newcommand{\gmodel}{\mathcal{M}}
\newcommand{\smt}{\textsc{smt}}
\newcommand{\args}{\text{args}}


\newcommand{\todoSR}[1]{\todo[color=blue!40]{#1}}
\newcommand{\mj}[1]{\todo[color=green!30]{#1 -mik}}
\newcommand{\marek}[1]{\todo[color=red!10]{#1 -MD}}
\newcommand{\todoSN}[1]{\todo[color=orange!50]{#1 -SN}}

\title{
    Inductive Function Definitions
}
\author{Stefan Ratschan \and Stefan Nugraha \and Mikoláš Janota \and Marek Dančo}
\date{}

\begin{document}

\maketitle

\section{Introduction}
\cite{ge-cav09}
\cite{habermehl-etaps08}
\cite{bradley-manna07,bradley-vmcai06}

\section*{Motivating Example}
Consider the following UFLIA formula:
\[
	\varphi =
	\underbrace{(f(3, a) \geq 4 + g(b))}_{\varphi_G}\,\land \,
	\underbrace{(\forall x, y. \,f(x, y) < x + g(y))}_{\varphi_1}\,\land \,
	\underbrace{(\forall x. \,g(x) = g(x + 2))}_{\varphi_2}
\]
Note that currently, the SMT solver Z3 cannot prove $\varphi$ is satisfiable.
However, we show there is an algorithmic way of proving the satisfiability
of this formula and try to identify UFLIA fragments in which this algorithm is applicable.

Let $\gmodel$ be the following partial model of the ground part $\varphi_G$:
\begin{gather*}
	a^\gmodel = 0, \\
	b^\gmodel = 1, \\
	f^\gmodel = \{(3, 0) \mapsto 4\}, \\
	g^\gmodel = \{1 \mapsto 0\}.
\end{gather*}
The definitions of $f^\gmodel, g^\gmodel$ on the rest of the domain are not interesting at this point.
Notice that because of the structure of $\varphi_2$ and the fact that $g^{\gmodel}(1) = 0$,
we can now define $g^{\gmodel}$ on all odd integers.
Specifically, we can first order the arguments of $g$ in $\varphi_2$ with $x \prec x+2$, and define
$g^\gmodel(3), g^\gmodel(5), g^\gmodel(7), \dots$ by unifying $x$ with $1, 3, 5, \dots$ and then set $x+2 \prec x$ and define
$g^\gmodel(-1), g^\gmodel(-3), g^\gmodel(-5), \dots$ by unifying $x+2$ with $1, -1, -3, \dots$ That is, we can define
$g^\gmodel(A_2)$ using $g^\gmodel(A_1)$ if we have $A_1 \prec A_2$.
This way we can expand $\gmodel$ to also be a partial model of $\varphi_2$.

Since $f^{\gmodel}(3,0) = 4$ and it must hold that $f(3,0) < 3 + g(0)$, we can set $g^{\gmodel}(0) = 2$.
Just like above, we can now define $g^{\gmodel}$ on all even integers and thus obtain a total
interpretation of $g$.
Now, for any pair $(x, y)$ of integers, we can define $f^{\gmodel}(x, y)$ to be
$x + 1$ or $x - 1$ for even or odd $y$ respectively. In the end, we can expand $\gmodel$
to a model of $\varphi$.

Observe it must be that $a \not= b$, otherwise
$f(3, a) \geq 4 \,+ \,g(b) \,\land \,f(3, a) < 3 \,+ \,g(a)$ is unsatisfiable.
Consequently, $\gmodel$ must be such that $a^{\gmodel} \not= b^{\gmodel}$.
We can check the compatibility of $\gmodel$ with the rest of the formula
after each step of our procedure and when a conflict is found,
we can learn the new ground literals from the \textsc{unsat} core and
restart the procedure with the updated ground part.

\emph{Goal}: Proving satisfiability of UFLIA formulas (or UFNIA) formulas (which may prove unsat on the way).
In the following, a formula will always refer to a UFNIA formula whose only quantifiers are universal
quantifiers over integer variables.

\emph{Idea}: View quantifiers as something that expresses infinitely many constraints on entities. The problem is that a
single entity may occur in several such constraints and we must avoid assigning different values to the very same entity.
To prove satisfiability of a formula, order these constraints and use a symbolic representation of the satisfying assignment
that assigns values to entities in such a way that following the order of constraint avoids assigning different
values to the very same entity.

\section*{Definitions}

We will view quantifier-free formulas as formulas with a universal quantifier that ranges over an empty tuple of variables. Hence quantifier-free formulas have precisely one instantiation.

\begin{definition}
	An \emph{entity} is a term of the form $f(c_1,\dots, c_k)$ where $f$ is an uninterpreted function symbols and $c_1,\dots, c_k$ are  integers.\todoSR{Mikoláš used the term ``cell'', which might more succinct and descriptive.}
\end{definition}
Examples of entities are $c$, and $f(7)$. The term $f(c+7)$ is not an entity.

% For now, we restrict ourselves to the case where the arguments of uninterpreted function symbols may not include further uninterpreted function symbols (e.g., $\forall x\;.\; f(x+1)=f(x)+1$ is OK, but $\forall x\;.\; f(x+c)=f(x)+1$ not). As a consequence, in each instantiation, all arguments to uninterpreted function symbols evaluate to constants, and hence the instantiation constrains a fixed finite set of entities, which we call the \emph{entities of the instantiation}.

\begin{definition}
	An \emph{entity interpretation} is a function from a set of entities to integers.
\end{definition}

Given a term $t$ and an entity interpretation $I$, we can define the semantics $I(t)$ of the term under this interpretation as usual---with the difference that the result is $\bot$ if the entity interpretation does not assign a value to an entity needed for evaluating the term. For example, for $I=\{ f(0) \mapsto 7 \}$, $I(f(0))=7$, but for $I=\{ f(1) \mapsto 7 \}$, $I(f(0))=\bot$.

\begin{definition}\todoSR{I added and changed definitions here to allow for a more general form of arguments of uninterpreted function symbols in quantified sub-formulas}
	We say that an entity interpretation $I$ \emph{grounds} a formula $\phi$ iff for all argument terms $t$ of uninterpreted function symbols in $\phi$, $I(t)\neq\bot$. For an entity interpretation $I$ grounding a formula $\phi$, we say that an entity $f(c_1,\dots, c_k)$ is an \emph{$I$-grounded entity in $\phi$} iff $\phi$ has a sub-term of the form $f(t_1,\dots, t_k)$, and $I(t_1)=c_1$, $\dots$, $I(t_k)=c_k$.
\end{definition}
For example, the interpretation $I=\{ a\mapsto 5 \}$ grounds the formula $f(a)\geq 0$, and the entity $f(5)$ is an $I$-grounded entity in $f(a)\geq 0$.

\begin{definition}
	\label{def:pre-sat-cert}
	Given a formula $\phi$, we call an entity interpretation $I$ that satisfies the quantifier-free part of $\phi$ and  that grounds  all instantiations of quantified sub-formulas of $\phi$ a \emph{pre-satisfiability certificate} of $\phi$. For any instantiation $\psi$ of a quantified sub-formula of $\phi$, we denote by $\Gamma_I(\psi)$ the resulting set of entities.
\end{definition}

For example, $I=\{ c\mapsto 5 \}$ is a pre-satisfiability certificate of $c\geq 5 \wedge \forall x \;.\; f(x+c+1)= f(x+c)+1$, and after instantiating the quantified sub-formula with $x=10$ to $\psi\equiv f(10+c+1)= f(10+c)+1$, $\Gamma_I(\psi)=\{ f(15), f(16)\}$.

\begin{definition}
	Given a formula $\phi$, a \emph{satisfiability certificate} is
	\begin{itemize}
		\item an order $\preceq$\footnote{We will assume this to be a well-order (i.e., a total order for which every non-empty subset has a least element), which enables induction. If we want to allow sub-formulas to be at the same place in the order, we either need to combine them into equivalence classes, or relax anti-symmetry (i.e., work with a pre-wellorder).} on all instantiations of quantified sub-formulas of $\phi$,
		\item a pre-satisfiability certificate $I$, which for every instantiation $\psi$ of a quantified sub-formula of $\phi$ partitions $\Gamma_I(\psi)$ into
		      \begin{itemize}
			      \item entities assigned a value by $I$,
			      \item entities not assigned a value by $I$ where $\psi$ is the first instantiation wrt. $\prec$ where the entity occurs in $\Gamma_I(\psi)$ (\emph{existential entitites}),
			      \item entities not assigned a value by $I$ for which there is an instantiation $\psi'\prec\psi$ where the entity occurs in $\Gamma_I(\psi')$
			            (\emph{non-existential entities}), and
		      \end{itemize}
		\item for each instantiation $\psi$ of a quantified sub-formula of $\phi$,
		      a certificate (the \emph{satisfiability propagator}) showing that for all values of non-existential entities, there exist
		      values for the existential ones such that the extension of~$I$ assigning these values to $\Gamma_I(\psi)$ satisfies~$\psi$.
		      \footnote{For the sake of generality, at this point we do not require the satisfiability propagator to be constructive. Below, we will then work with algorithms computing the values only required to exist, here.}
	\end{itemize}
\end{definition}

Note that, a fortiori, a satisfiability propagator for a certain partition of entities into the three sets above, stays a satisfiability propagator when moving entities from being non-existential to being existential.

\begin{property}
	Every formula that has a satisfiability certificate is satisfiable.
\end{property}

\begin{proof}
	Assume a formula $\phi$ that has a satisfiability certificate.
	The corresponding pre-satisfiability certificate $I$ satisfies the quantifier free part of $\phi$. We use the principle of induction on well-orders to show that for every instantiation~$\psi$ of a quantified-subformula, the set of formulas $\{ \psi' \mid \psi'\prec \psi\}$ is satisfied by an extension of $I$.

	Let $\psi$ be an instantiation of a quantified sub-formula, and let $X$ be $\{ \psi' \mid \psi'\prec \psi\}$. We assume that $X$ is satisfiable by an extension $I_X$ of $I$, and prove that $X\cup \{ \psi\}$ is satisfiable by an extension of $I$, as well. Since the formula has a satisfiability certificate, the existential entities of $\psi$ do not occur in any element of $X$. Let $I'$ be the extension of $I_X$ that assigns to the existential entities of $\psi$ the values whose existence is  confirmed by the satisfiability propagator. Since these do not occur in $X$, for all entities occurring in $X$, the value of $I'$ is the same as the value of $I_X$. Hence $I'$ satisfies both $X$ and $\psi$, and so it satisfies $X\cup \{ \psi\}$.

	Now denote for every instantiation~$\psi$ of a quantified-subformula the entity interpretation $I$  satisfying $\psi$ as constructed in the previous paragraph by $I_{\psi}$.
	% From the well-order $\prec$ we get a corresponding well-order on these entity interpretations.
	Let $I_{\phi}$ be the entity interpretation that, for any entity $u$, assigns the value to $u$ that $I_{\psi}$ assigns to it for the smallest $\psi$ (wrt. $\prec$) that assigns a value to $u$. This smallest $\psi$ exists, since $\prec$ is a well-order. This entity interpretation $I_{\phi}$ satisfies $\phi$, and any classical interpretation compatible with the values assigned by $I_{\phi}$ satisfies $\phi$, as well.
\end{proof}

A satisfiability certificate only shows that a formula is satisfiable. It does not provide concrete values of the corresponding model of the formula. We now show how to compute such values from a given satisfiability certificate containing a pre-satisfiability certificate $I$.

For this, let $inst(u)$ either be the  instantiation $\psi$ of a quantified sub-formula with $u\in\Gamma_I(\psi)$ and where $u$ is existential, or $\bot$ if there is no such instantiation. For any instantiation $\psi$ of a quantified sub-formula with existential entities $u_1,\dots, u_s$ and non-existential entities $v_1,\dots, v_r$, the satisfiability propagator defines  functions $valprop_{u_1},\dots, valprop_{u_s}$ such that for any $\hat{v}_1,\dots,\hat{v}_r$, the entity interpretation
\[\{ v_1\mapsto \hat{v}_1,\dots,v_r\mapsto \hat{v}_1, u_1\mapsto  valprop_{u_1}(\hat{v}_1,\dots, \hat{v}_r),\dots, u_s\mapsto valprop_{u_s}(\hat{v}_1,\dots,\hat{v}_r)\} \] satisfies $\psi$. In many cases, these functions can be synthesized automatically from the corresponding quantifier elimination problem~\cite{kuncak-sttt13}.
Then, a program to compute the value $val(u)$ of a given entity $u$ looks as follows:
\begin{tabbing}\hspace*{0.4cm}\=\hspace*{0.4cm}\=\kill
	\textbf{if} $I$ assigns a value $x$ to $u$ \textbf{then} \textbf{return} $x$\\
	\textbf{if} $inst(u)=\bot$ \textbf{then} \textbf{return} 0 \`// in this case, any value (including $0$) is o.k\\
	let $v_1,\dots, v_k$ be the non-existential entities in $inst(u)$\\
	\textbf{return} $valprop(u)(val(v_1),\dots, val(v_k))$
\end{tabbing}

\begin{property}
	Let $u$ be an entity such that $inst(u)\neq\bot$. Then for any non-existential entity $v$ of $inst(u)$ with $inst(v)\neq\bot$, $inst(v)\prec inst(u)$.
\end{property}

So each recursive call of the program $val$ either results in $inst(u)$ either decreasing or being $\bot$. In the latter case, the program terminates immediately, and the former case cannot happen infinitely often, since the used order is well-founded. So we have:
\begin{property}
	The program $val$ terminates.
\end{property}

The goal is now an algorithm that computes such satisfiability certificates and a converse of the property that shows for certain classes of satisfiable  formulas this algorithm succeeds.



\section*{Constructing Certificates}
Very rough idea:
\begin{enumerate}
	\item solve quantifier-free part
	\item check solution against instantiations of quantified part with all entities already assigned,
	      if not satisfied, learn a clause and backtrack to solving
	\item order all other instantiations and construct the necessary certificates
\end{enumerate}

\begin{example}
	\[ \forall x \:.\: g(x+2)=g(x)+1 \]
	\begin{itemize}
		\item order: $0,1,\dots, -1, -2, \dots$
		\item corresponding existential entities: $g(2), g(3), \dots, g(-1), g(-2), \dots$   \footnote{Formally speaking also $g(0)$ is existential for the instantiation with $0$, and $g(1)$ for the instantiation with $1$. However, assuming them to be non-existential allows for a uniform construction of satisfiability propagators. This ensures correctness, see the comment after the definition of satisfiability certificate.}
		\item satisfiability propagators for the two blocks in the order: $g(x) = g(x-2)+1$, $g(x) = g(x+2)-1$
	\end{itemize}
\end{example}

\begin{example}
	\[ g(0)=10\wedge g(2)=10\wedge\forall x \:.\: g(x+2)=g(x) \]
	\begin{itemize}
		\item order
		      \begin{enumerate}
			      \item $g(x+2)=g(x)$ for $x=0, 1, \dots$
			      \item $g(x+2)=g(x)$ for $x=-1,-2,\dots$
		      \end{enumerate}
		\item pre-satisfiability certificate $\{ g(0)\mapsto 10, g(2)\mapsto 10 \}$
		\item propagators:
		      \begin{enumerate}
			      \item $x=0$: nothing to assign
			      \item $x=1,\dots$: $g(x)=g(x-2)$
			      \item $x=-1,-2,\dots$: $g(x)=g(x+2)$
		      \end{enumerate}
	\end{itemize}
\end{example}

\newpage
\begin{example}
	\[f(3, a) \geq 4 + g(b) \wedge (\forall x, y \:.\: f(x, y) <x + g(y)) \wedge (\forall x \:.\: g(x) = g(x+2))\]
	\begin{itemize}
		\item order on constraints, block-wise:
		      \begin{enumerate}
			      \item $f(x,y) <x+g(y)$ for $(x,y)= (3,0)$
			      \item $g(x) = g(x + 2)$ for $x= 0, 1, \dots$
			      \item $g(x) = g(x + 2)$, for $x= -1, -2, \dots$,
			      \item any order on the rest of $\forall x,y. \;f(x,y) < x + g(y)$ (i.e., (x,y) $\not=$ (3,0))
		      \end{enumerate}
		\item pre-satisfiability certificate: $\{ a\mapsto 0, b\mapsto 1, f(3,0)\mapsto 4, g(1)\mapsto 0\}$
		\item satisfiability propagators:
		      \begin{enumerate}
			      \item $g(0)=2$
			      \item $g(x)= g(x-2)$
			      \item $g(x)=g(x+2)$
			      \item $f(x,y)=x+g(y)-1$
		      \end{enumerate}
	\end{itemize}
\end{example}

\begin{example}
	\[\forall x \;.\; f(x) + f(x+3) < f(x+2)\]
	\begin{itemize}
		\item order on constraints:
		      \begin{enumerate}
			      \item $f(0) + f(3) < f(2)$
			      \item $f(1) + f(4) < f(3)$
			      \item $f(x) + f(x + 3) < f(x + 2)$ for $x = 2, 3, \dots$
			      \item $f(x) + f(x + 3) < f(x + 2)$ for $x = -1, -2, \dots$
		      \end{enumerate}
		\item satisfiability propagators:
		      \begin{enumerate}
			      \item $f(0) = 0, f(2) = 2, f(3) = 1$
			      \item $f(1) = 0, f(4) =0$
			      \item $f(x) = f(x-1) - f(x-3) - 1$
			      \item $f(x) = - f(x+3) + f(x+2)  - 1$
		      \end{enumerate}
	\end{itemize}
\end{example}

\addtocounter{example}{-1}
\begin{example}[Continued]
	Another approach in solving the problem in the previous example is the following.
	Let us assume that $f$ is a linear map. Then,
	\[f(x) + f(x+3) - f(x+2) = f(x+1)\]
	We can then rewrite the problem as
	\[f(y) < 0\]
	Here, $f$ is a so called \emph{single invocation} symbol. That means we can deskolemize $f$
	and get
	\[\exists z. \, z<0\]
	Next, we can eliminate $z$ and get the formula $-1<0$, which simplifies to $\top$.

	The original problem is thus satisfiable. What's more, the value for $z$ after
	elimination gives us a satisfying assignment to $f$:
	\[f = \{\mapsto -1\}\]
\end{example}

\begin{example}
	\[f(x) + g(x-1) > x\]

	\begin{itemize}
		\item deskolemize $f \longrightarrow \exists y. \;y + g(x - 1) > x$
		\item deskolemize $g \longrightarrow \exists y, z. \;y + z > x$
		\item we have the formula $\psi = \forall x \exists y, z. \; y + z > x$
		\item eliminate $z$ from $\psi \longrightarrow \forall x \exists y. \; x - y + 1 > x - y$
		\item we get the formula $\forall x \exists y. \; 1 > 0$, which simplifies to $\top$
		\item $f$ is unconstrained and $g(x-1) = x - f(x) + 1$
		\item a possible model is then
	\end{itemize}
	\begin{gather*}
		f = \{\mapsto 0\} \\
		g = \{x \mapsto x + 2\}
	\end{gather*}
\end{example}

\section{Algorithm}\label{sec:alg}

Class of formulas:
\[ F\wedge \forall x\;.\; Q(f_1(x+c^{f_1}_1),\dots,f_1(x+c^{f_1}_{l_1}),\dots,f_r(x+c^{f_r}_1),\dots,f_r(x+c^{f_r}_{l_r})),\]
where $F$ is quantifier free, for every $i\in \{1,\dots,r\}$, the constants $c^{f_i}_{1},\dots,c^{f_i}_{l_i}$ are sorted and pairwise different.\todoSR{Up to now, we have assumed the offsets to be non-negative. We should make everything work for negative offsets, as well.}

This does not yet address:
\begin{itemize}
	\item uninterpreted function symbols of higher arity
	\item more interesting argument terms containing uninterpreted constants or function symbols
	\item several quantified variables
	\item several quantified sub-formulas
\end{itemize}
The first item looks like a straightforward extension of the below (choose one argument to base everything on), just introducing messy notation. So we might leave it out for now. The others are interesting extensions we should think about.

We will satisfy the universal quantifier by an inductive argument going both up and down. For making this argument work, we require that for one of the $f_1,\dots,f_r$, let us say for $f_{i^*}$, for both its highest argument $f_{i^*}(x+c^{f_{i^*}}_{l_{i^*}})$ and lowest argument $f_{i^*}(x+c^{f_{i^*}}_1)$ we can always find values satisfying $Q$. More formally, there must be an $i^*\in \{1,\dots, r\}$ such that
\begin{itemize}
	\item for all values of entities\mj{the terminology does not make sense to me here} in $Q$ except for $f_{i^*}(x+c^{f_{i^*}}_{l_{i^*}})$ there is a value for $f_{i^*}(x+c^{f_{i^*}}_{l_{i^*}})$ satisfying $Q$, and
	\item for all values of entities in $Q$ except for $f_{i^*}(x+c^{f_{i^*}}_1)$ there is a value for $f_{i^*}(x+c^{f_{i^*}}_1)$ satisfying $Q$.
\end{itemize}

\mj{Just to be clear, the requirement above does not apply to $f(x)<f(x+1)\land f(x+1)<f(x+3)$?}
\todoSR{Correct. It applies to both parts individually, but not to the conjunction. This is  restrictive, of course, but allowed for an easy generalization to the case of several occurrences of the same function symbol with different arguments.}
\marek{It applies to both if we shift the second conjunct to the left by 1 in the left direction and to the left by 2 in the right direction. See Section~\ref{sec:conj}.}

For increasing $x$, this will propagate values to the entity $f_{i^*}(x+c^{f_{i^*}}_{l_{i^*}})$ which, since the offset $c^{f_{i^*}}_{l_{i^*}}$ is the biggest for $f_{i^*}$ has not been propagated a value to, before. Analogically, for decreasing $x$, it will propagate values to the entity with the smallest offset. Note that there might be weaker requirements (with fewer entities universally quantified) that also might do the job, but this needs more investigation.

In the following, $args(F, f)$ will denote the set of argument terms of $f$ in $F$.



\begin{property}
	Assume an integer interval $I$ and an entity interpretation $\alpha$ s.t.
	\begin{itemize}
		\item $\alpha\models F\wedge \bigwedge_{x\in I} Q$
		\item there is no $t\in args(F, f)$, $\max I<x$  s.t.\ $x+c^{f_{i^*}}_{l_{i^*}}=\alpha(t)$ (no entity propagated to by upward induction clashes with an argument of $f$ in $F$)
		\item there is no $t\in args(F, f)$, $x<\min I$  s.t.\ $x+c^{f_{i^{*}}}_1=\alpha(t)$ (no entity propagated to by downward induction clashes with an argument of $f$ in $F$)
	\end{itemize}
	Then the order $\max I+1, \max I+2, \dots, \min I-1, \min I-2,\dots$, together with the entity interpretation $\alpha$, and propagators for ReqPivot form a satisfiability certificate for $F\wedge \bigwedge_{x\in I} Q\wedge \forall_{x\not\in I} Q$.
\end{property}

Since $F\wedge \bigwedge_{x\in I} Q\wedge \forall_{x\not\in I} Q$ is equivalent to $F\wedge \forall x \,.\, Q$, this also certifies satisfiability of this formula.

% The corresponding certificate is:
% \begin{itemize}
% \item order on constraints:
%   \begin{enumerate}
%   \item $F$, $Q(f(x+k),f(x+l))$ for $x\in I$
%   \item $Q(f(x+k),f(x+l))$ for $x=\max I+1, \max I+2, \dots$
%   \item $Q(f(x+k),f(x+l))$ for $x=\min I-1, \min I-2, \dots$
%   \end{enumerate}
% \item existential entities:
%   \begin{enumerate}
%   \item $\{ x+k \mid x \in I \}\cup \{ x+l \mid x \in I \}$
%   \item $\max I + l+1, \max I+l+2, \dots$
%   \item $\min I + k -1, \min I+k-2, \dots$
%   \end{enumerate}
% \end{itemize}
For coming up with an algorithm, let us first simplify the two conditions: Pushing negation over quantifiers, we get:
\begin{itemize}
	\item  for all $t\in args(F, f)$, for all $x$ with $\max I<x$, $\alpha(t)<x+c^{f_{i^*}}_{l_{i^*}}$
	\item for all $t\in args(F, f)$, for all $x$ with $x<\min I$, $x+c^{f_{i^{*}}}_1<\alpha(t)$
\end{itemize}
And eliminating the inner universal quantifier, we get
\begin{itemize}
	\item  for all $t\in args(F, f)$, $\alpha(t)<\max I + 1 +c^{f_{i^*}}_{l_{i^*}}$
	\item for all $t\in args(F, f)$, $\min I-1+c^{f_{i^{*}}}_1<\alpha(t)$
\end{itemize}
which simplifies to
\[ \text{for all } t\in args(F, f), \min I+c^{f_{i^{*}}}_1\leq\alpha(t)\leq\max I +c^{f_{i^*}}_{l_{i^*}}.\]
Using this condition, we get a first (inefficient) algorithm for constructing a certificate. Here we use the notation that for a formula $F$, $smt(F)$ is a model of $F$, if it exists (i.e., $F$ is satisfiable), and $\bot$, otherwise
\mj{Is this condition really correct? If $F$ is empty, there's no condition on
	$I$ (it can be empty), but how are we sure that we can glue together the two functions (the negative
	and the positive)?}

\begin{algorithm}
	\caption{Satisfiability Check}%
	\label{alg:sr}
	\textbf{Input:} Formula $F \wedge \forall x \:.\: Q$ as above\\
	\textbf{Output:} SAT or UNSAT
	\begin{algorithmic}[1]
		% \Procedure{OriginalSMT}{$F, f, k, l, Q$}
		\State $\underline{I} \leftarrow 0$, $\overline{I} \leftarrow 0$ \Comment{Start with singleton interval}
		\State $\alpha \leftarrow \smt\left(F \wedge \bigwedge_{x=\underline{I}}^{\overline{I}} Q\right)$

		\While{$\alpha \neq \bot$}

		\State $\text{condition} \leftarrow \bigwedge_{t \in \args(F,f)} \underline{I} + c^{f_{i^{*}}}_1 \leq \alpha(t) \leq \overline{I} + c^{f_{i^*}}_{l_{i^*}}$
		\If{$\smt(F \wedge \bigwedge_{x=\underline{I}}^{\overline{I}} Q \wedge \text{condition}) \neq \bot$} \Comment{with clash condition}
		\State \Return \textsc{Sat} \Comment{Certificate can be constructed}
		\EndIf

		%        \State \textbf{Expand interval symmetrically:}
		\State $\underline{I} \leftarrow \underline{I} - 1$
		\State $\overline{I} \leftarrow \overline{I} + 1$

		%       \State \textbf{Solve extended formula:}
		\State $\alpha \leftarrow \smt\left(F \wedge \bigwedge_{x=\underline{I}}^{\overline{I}} Q\right)$ \Comment{with updated bounds}
		\EndWhile

		\State \Return \textsc{Unsat}
		% \EndProcedure
	\end{algorithmic}
\end{algorithm}

We are currently polishing a completeness proof for the \textsc{Sat} case. For the \textsc{Unsat} case, the essential argument seems to be the same as for Ge and de~Moura~\cite[paragraph ``compactness'']{ge-cav09}.

\begin{theorem}
	Let $\phi$ be a formula of the form
	\begin{align*}
		\phi:=F\land Q\big(f_1(x+c_1^{f_1}),...,f_1(x+c_{l_1}^{f_1}),...,f_r(x+c_1^{f_r}),...,f_r(x+c_{1_r}^{f_r})\big)
	\end{align*}
	where
	\begin{enumerate}
		\item $F$ is quantifier-free.
		\item For every $i\in\{1,...,r\}$, the constants $c_1^{f_i},...,c_{l_i}^{f_i}$ are sorted and pairwise different.
		\item $\phi$ is satisfiable.
		\item $\phi$ satisfies ReqPivot for a specific critical function $f_{i^*}$ \todoSN{ReqPivot is the $f_{i^*}$ requirement.}
	\end{enumerate}
	Then, Algorithm~\ref{alg:sr}, upon input $\phi$, will terminate and return SAT.
\end{theorem}

\begin{proof}
	Since $\phi$ is satisfiable, there exists a model $\gmodel\vDash\phi$. From $\gmodel$, we can extract a pre-satisfiability certificate $I^*$ (Definition \ref{def:pre-sat-cert}). This $I^*$ provides concrete integer values for all ground terms in $F$ and for the entities appearing in the instantiations of the quantified formula that make $\phi$ true.
	Let $S$ be the finite set of all integer arguments for the critical function $f_{i^*}$ that appear in the ground part $F$:
	\begin{align*}
		S=\{I^*(t)\,|\,t\in\args(F,f_{i^*})\}
	\end{align*}
	Define the minimal and maximal elements of this set: $L=\min(S)$ and $U=\max(S)$. Now we define this critical interval $[K_{\text{min}},K_{\text{max}}]$ where:
	\begin{align*}
		K_{\text{min}}=L-c_{l_{i^*}}^{f_{i^*}} \hspace{0.5em}\text{and}\hspace{0.5em} K_{\text{max}}=U-c_1^{f_{i^*}}
	\end{align*}
	\begin{claim}
		For the interval $[K_{\text{min}},K_{\text{max}}]$, $I^*$ satisfies the clash condition:
		\begin{align*}
			\forall t\in\args(F,f_{i^*}).K_{\text{min}}+c_1^{f_{i^*}}\leq I^*(t)\leq K_{\text{max}}+c_{l_{i^*}}^{f_{i^*}}
		\end{align*}
		\textit{Proof:} For any $t\in\args(F,f_{i^*})$, we have $L\leq I^*(t)\leq U$. Therefore,
		\begin{itemize}
			\item $K_{\text{min}}+c_1^{f_{i^*}}=\big(L-c_{l_{i^*}}^{f_{i^*}}\big)+c_1^{f_{i^*}}\leq L\leq I^*(t)$ since $c_1^{f_{i^*}}\leq c_{l_{i^*}}^{f_{i^*}}$
			\item $I^*(t)\leq U\leq\big(U-c_1^{f_{i^*}}\big)+c_{l_{i^*}}^{f_{i^*}}=K_{\text{max}}+c_{l_{i^*}}^{f_{i^*}}$ since $c_{l_{i^*}}^{f_{i^*}}\geq c_1^{f_{i^*}}$
		\end{itemize}
	\end{claim}

	Now let $N=\max(\abs{K_{\text{min}}},\abs{K_{\text{max}}})$ and consider Algorithm \ref{alg:sr}.
	\begin{enumerate}
		\item Line 1: initialisation.
		\item Line 2: First SMT call. This succeeds because $\phi$ is satisfiable.
		\item Loop progression: the algorithm enters the while-loop and expands symmetrically.
		\item At iteration where interval becomes $[-N,N]$:
		      \begin{itemize}
			      \item Line 9. This will succeed because we can construct a mnodel as follows:
			            \begin{itemize}
				            \item For $F$ and $Q(x)$ with $x\in[K_\text{min},K_{\text{max}}]$, use values from $I^*$;
				            \item use the ReqPivot propagators to extend the instantiations in $[-N,N]\setminus[K_\text{min},K_\text{max}]$)
			            \end{itemize}
			      \item Line 5: $\smt(F \wedge \bigwedge_{x=-N}^N Q \wedge C)$ where $C$ is the clash condition $\forall t\in\args(F,f_{i^*}).-N+c_1^{f_{i^*}}\leq \alpha(t)\leq N+c_{l_{i^*}}^{f_{i^*}}$. This will succeed because the model constructed above also satisfies $C$ (followed from Claim 1 and the fact that $[K_{\text{min}},K_{\text{max}}]\subseteq[-N,N]$).
			      \item $\therefore$ Algorithm \ref{alg:sr} returns SAT.\qedhere
		      \end{itemize}
	\end{enumerate}
\end{proof}


\section{Extensions}
\subsection{Conjunction}\label{sec:conj}

The proposed new \emph{ReqPivot} condition addressing the extension to conjunction of literals.
It doesn't deal with formulas with only nonstandard models such as Formula~\eqref{eq:ind-needed}.
\begin{tcolorbox}[enhanced,breakable,skin first=enhanced,skin middle=enhanced,skin last=enhanced]
	\paragraph{ReqPivot Condition.}
	Let $f_1, \dots, f_r$ be the functions appearing in $Q$.
	We say that $Q$ satisfies the \emph{ReqPivot condition} if there exists an index $i^* \in \{1,\dots,r\}$ such that:
	\begin{itemize}
		\item For the smallest offset $c_1^{f_{i^*}}$, require that the values of the non-existential variables in $Q$ are such that all literals not containing $f_{i^*}(x+c_1^{f_{i^*}})$ are satisfied. Then $f_{i^*}(x+c_1^{f_{i^*}})$ can be chosen to satisfy the remaining literal(s) containing it.
		\item Symetrically, for the biggest offset $c_{l_{i^*}}^{f_{i^*}}$, require that the values of the non-existential variables in $Q$ satisfy all literals not containing $f_{i^*}(x+c_{l_{i^*}}^{f_{i^*}})$. Then $f_{i^*}(x+c_{l_{i^*}}^{f_{i^*}})$ can be chosen to satisfy the remaining literal(s) containing it.
	\end{itemize}
\end{tcolorbox}

Suppose the following formula.
\begin{equation}\label{eq:conj1}
	\forall x.\,f(x + 7) > f(x) - f(x + 3)
	\,\land \,f(x + 3) > f(x)
\end{equation}
Formula~\eqref{eq:conj1} does not satisfy the precondition of our algorithm because
for values of $f(x+3)$ and $f(x)$ with $f(x+3)\leq f(x)$, it is no longer
possible to find a value of $f(x+7)$  to satisfy the formula.

Since the literals are in conjunction, for all $x$ both of them have to be satisfied. This means we can
split the formula into two universally quantified formulas like so
\[
	\forall x. \,f(x + 7) > f(x) - f(x + 3)
	\,\land \,\forall x. \,f(x + 3) > f(x)
\]
Using substitution we ``normalize'' the formulas as follows
\[
	\forall x. \,f(x) > f(x - 7) - f(x - 4)
	\,\land \,\forall x. \,f(x) > f(x - 3)
\]
We can then merge the two foralls into one and continue out algorithm normally.
This normalization may potentially significantly reduce the amount of iterations in the while
cycle of Algorithm~\ref{alg:sr}.

In general, for a formula $\bigwedge_i F_i$, for forward propagation,
shift the  offsets so that the highest offset is $0$, i.e.\ $f(x)$ is being
propagated  forward. Analogously, for backward propagation, shift the offsets so that the
lowest offset is $0$, i.e.\  $f(x)$ is being propagated backward.

\subsubsection*{Correctness Argument}
Shifting the arguments does not change the formula semantically.
More precisely, for a formula $F$ where $f$ is applied to arguments $t_i$,
construct a formula $F'$ where $f$ is applied to arguments $t_i+k$ for some
$k\in\mathbb{Z}$. The formulas $F$ and $F'$  have the same set of models
because any model of $F$ can be transformed to a model of $F'$
by setting $f_{F'}(x) \triangleq f_{F}(x-k)$.

Note that this approach does not generally work for disjunction, which we address in the
following section.

\subsection{Disjunction}\label{sec:disj}


To deal with disjunctions, Mikol\'a\v s proposed we could work
with preconditions\footnote{Here I am talking about preconditions in the sense
	of the Kuncak paper. By precondition I don't mean the \emph{ReqPivot} condition.
	Sorry for the confusion Mikoláš.}~\cite{kuncak-pldi10, kuncak-sttt13}.
For each disjunct we can form a precondition on $x$ in a way that
if the precondition holds, that literal has to be satisfied.
More precisely, suppose we are given a formula of the form
$\forall x. \,l_1(x) \lor \dots \lor l_n(x)$.
We may attempt to form a precondition $\mathit{pre}_i$ for each $i$  so that
$\forall x. \, \mathit{pre}_i(x) \implies l_i(x)$ is satisfiable and
$\forall x. \,\bigvee_{i = 1}^n pre_i(x)$ is valid.
We can then construct the formula
$\forall x. \,\mathit{pre}_1(x)\implies l_1(x) \lor \dots \lor \mathit{pre}_n(x)\implies l_n(x)$.

\[\forall{x}. \,2*f(x + 5) = x \,\lor \,2*f(x + 1) = x + 1\]

The preconditions are $2 \mid x$ and $2 \nmid x$ for the first and second disjunct respectively.
In this case the preconditions are complementary -- for each $x$ exactly one precondition
is satisfied. If we can form complementary preconditions, then we can do the normalization trick.
Notice we never assign to the same entity twice, because the difference between the offsets is even.
The formula is thus satisfiable.

\[
	\forall{x}. \,f(x + 3) > f(x + 7) \,\lor \,f(x + 4) < f(x + 5)
\]

Here, both of the disjuncts satisfy \emph{ReqPivot}. That means we can form complementary preconditions
$\top$ and $\bot$ for the first and second disjunct respectively and satisfy only the first for all $x$.

\subsection*{Few More Examples}


\begin{example}
	\[
		\forall{x}. \,f(x) < f(x + 1) + f(x + 2)
		\,\land \,\forall{x}. \,f(x) < f(x + 1)
	\]
	From $-2$ to the right use identity function. For $x \leq -3$ use
	\[
		f(x) = f(x + 1) + f(x + 2) -1
	\]
\end{example}


\begin{example}\label{ex:ind-needed}
	\[
		\forall{x}. \,f(x) < f(x + 1) - f(x + 2)
		\,\land \,\forall{x}. \,f(x) < f(x + 1)
	\]
	Since $f$ is increasing there has to exist an $a$ for which $f(a) \geq 0$
	(this requires an inductive proof, see Section~\ref{sec:ind}).
	At the same time, $f(a) < f(a+1) - f(a+2)$ and $f(a+1) < f(a+2) - f(a+3)$. That means
	$f(a) < -f(a+3)$ but also $f(a) < f(a+3)$. Therefore, $f(a) < \text{min}\{-f(a+3), f(a+3)\}$.
	In other words $f(a) < 0$, a contradiction.
\end{example}


\section{Induction}\label{sec:ind}

In the solution of Example~\ref{ex:ind-needed}, we implicitly used the fact that the following
formula is \textsc{unsat}
\begin{equation}\label{eq:ind-needed}
	\forall{x}. \,f(x)<0 \,\land \,\forall{x}. \,f(x)<f(x+1)
\end{equation}
Note that one cannot prove that by instantiation\mj{instantiating the original
formula (we can still instantiate the induction schema)}\footnote{
	In general, we could look for bounds of the form $\forall x. \,f(x) < G$ for $G$ ground.
	If from the other quantified subformulas we can derive that $f$ is strictly increasing, we can conclude
	the entire formula is \textsc{unsat} over the integers.}.
Indeed, every finite set of instantiations of the above formula is satisfiable.
A similar result can be found in~\cite{ge-cav09}, where from compactness we have that
the above formula has as models only non-standard models of arithmetic (e.g.\ polynomials over $\mathbb{Z}$).

Using $\forall{x}. \,f(x)<f(x+1)$ we can prove by induction the lemma
\begin{equation}\label{eq:ind-needed-lemma}
	\forall{v}\exists{x}. \,f(x) \geq f(0) + v
\end{equation}
For the base case we have $\exists x. \,f(x) \geq f(0) + 0$ is valid when setting $x = 0$. For the induction step
assume for some $v$ and $x$ we have $f(x) \geq f(0) + v$. Now,
\[
	f(x) \geq f(0) + v \implies f(x) + 1 \geq f(0) + v + 1 \implies f(x+1) \geq f(0) + v + 1,
\]
where the second implication holds by the assumption that $f$ is increasing.
Instantiating the Lemma~\eqref{eq:ind-needed-lemma} by $v = -f(0)$
now proves Formula~\eqref{eq:ind-needed} is \textsc{unsat}, since we get
\[
	\forall{x}. \,f(x)<0 \land \exists{x}. \,f(x) \geq 0
\]

Another example where induction is needed is
\[
	f(0) = 0 \,\land \,f(c) = 3 \,\land \,\forall{x}. \,f(x+1) = f(x)
\]
Note that applying Algorithm~\ref{alg:sr} results in an infinite loop\mj{better
say ``does not terminate'''}
because in every $\alpha$ we can set $c$ to be outside $I$. The same goes for any instantiation method.
We can easily prove the lemma
\[
	\forall{x}. \,f(x) = 0
\]
from the first and third conjunct by induction. Again, only non-standard models of arithmetic satisfy this formula.


\section*{Related Work}\label{}
Synthesis of recursive functions by Hozzov\'a et al.~\cite{hozzova-ijcar24}.
Synthesis of strategies on LIA problems Murphy and Kincaid~\cite{kincaid-cav24}.
Synthesis, single invocation Kun\v cak et
al.~\cite{kuncak-pldi10,kuncak-sttt13}.
Array decision procedures~\cite{bradley-vmcai06}: no arithmetic on universally quantified variables allowed.
Habermehl et al.~\cite{habermehl-etaps08} allow difference bounded constraints on array offsets of the form $a[i+c]$. From the MBQI paper: ``For certain cases containing offsets on array indices, our procedure will result in an infinite set of instantiations, while a decision procedure of LIA\footnote{LIA does not refer to linear integer arithmetic, but to the logic allowed by Habermehl et al.}  will terminate. It leaves an open question for future research on how to reason about this type of formulas within an instantiation-based approach.''
Alberti et al.~\cite{alberti2014decision}: only one universally quantified variable allowed.
Elad et al.~\cite{elad2024infinite}: The fragment of FOL for which they prove decidability (OSC, Section~6) does not allow anything like integer arithmetic.


\section*{What Can't the Previous Work Solve?}

Here, I am considering the works~\cite{bradley-vmcai06, ge-cav09, habermehl-etaps08}.

\subsection*{Infinitely Increasing But Bounded Integer Sequence}

\[
	\forall{x}. \,f(x)<0 \,\land \,\forall{x}. \,f(x)<f(x+1)
\]

The syntax in~\cite{habermehl-etaps08} includes $\leq$ but does not include $<$. It does include negation though, but only if it
results in the quantified variables being existential. This cannot be solved by~\cite{bradley-vmcai06} (see Theorem 4 in their paper).
\textsc{Z3} cannot solve this on its own but with the addition of Lemma~\ref{eq:ind-needed-lemma} it can.
Adding the lemma also helps Vampire but not \textsc{cvc5}.

\subsection*{Two-Valued Constant Function}

\[
	f(0) = 0 \,\land \,f(c) = 3 \,\land \,\forall{x}. \,f(x+1) = f(x)
\]

In the last meeting I hand-wavedly assumed this cannot be in the fragment of~\cite{habermehl-etaps08}.
However, it is. They accept the literals $f(x) - f(x+1) \leq 0$ and $f(x+1) - f(x) \leq 0$, which in conjunction simplify
to $f(x) = f(x+1)$. They can then universally quantify this to form an array property. The other equalities can
be formed as value expressions $A \leq B \,\land \,B \leq A$. I can look more thoroughly at the paper
to see how can they solve this.
This cannot be solved by~\cite{bradley-vmcai06}, because the
third conjunct contains $x+1$ as an argument of $f$ (Theorem 4 in their paper).
\textsc{Z3} cannot solve this -- Compactness section in~\cite{ge-cav09}.

\bibliographystyle{abbrv}
\bibliography{refs}

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
